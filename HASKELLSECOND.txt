--hello.hs 
x=

ghc hello.hs
[1 of 1] Compiling Main
Linking hello ...

hello (Windows hello.exe);
hello.hi;
hello.o.

$ ghci
GHCi> :q
Leaving GHCi.

ghci> 1+1
2

ghci> x=2+2
ghci> x
4

ghci> let f x = x+x
ghci> f 2
4

ghci hello.hs
[1 of 1] Compiling Main
Ok, modules loaded: Main.

:l :load
ghci
GHCi> :l hello.hs
[1 of 1] Compiling Main
Ok, modules loaded: Main.

ghci> :l hello.hs
ghci> main
Hello!


main = do
putStrLn "Hello, Will!"
GHCi> :l hello.hs
GHCi> main
Hello, Will!

x = 

$ ghci
GHCi> :l first_prog.hs
[1 of 1] Compiling Main ( first_prog.hs, interpreted)
Ok, modules loaded: Main.

GHCi> messyMain
ÐšÑ‚Ð¾ Ð¿Ð¾Ð»ÑƒÑ‡Ð°Ñ‚ÐµÐ»ÑŒ ÑÑ‚Ð¾Ð³Ð¾ Ð¿Ð¸ÑÑŒÐ¼Ð°?
Ã—Ã¨Ã²Ã Ã²Ã¥Ã«Ã¼
ÃÃ Ã§Ã¢Ã Ã­Ã¨Ã¥ ÃªÃ­Ã¨Ã£Ã¨:
ÃÃ°Ã®Ã£Ã°Ã Ã¬Ã¬Ã¨Ã°Ã³Ã© Ã­Ã  Haskell
ÃŠÃ²Ã® Ã Ã¢Ã²Ã®Ã° Ã½Ã²Ã®Ã£Ã® Ã¯Ã¨Ã±Ã¼Ã¬Ã ?
Ã“Ã¨Ã«Ã«
Ã„Ã®Ã°Ã®Ã£Ã®Ã© Ã—Ã¨Ã²Ã Ã²Ã¥Ã«Ã¼!
Ã‘Ã¯Ã Ã±Ã¨Ã¡Ã® Ã§Ã  Ã²Ã®, Ã·Ã²Ã® ÃªÃ³Ã¯Ã¨Ã«Ã¨ "ÃÃ°Ã®Ã£Ã°Ã Ã¬Ã¬Ã¨Ã°Ã³Ã© Ã­Ã  Haskell"!
Ã‘ Ã³Ã¢Ã Ã¦Ã¥Ã­Ã¨Ã¥Ã¬,
Ã“Ã¨Ã«Ã«

simple x = x

GHCi> simple 2
2
GHCi> simple "dog"
"dog"

x=2

calcChange owed given = if given - owed > 0
                        then given - owed
                        else 0

calcChange owed given = if change > 0
                        then change
                        else 0
           where change = given - owed

doublePlusTwo x = doubleX + 2
      where doubleX = x*2

GHCi> x = 7
GHCi> x
7
GHCi> x = [1,2,3]
GHCi> x
[1,2,3]

GHCi> let x = 7
GHCi> x
7

GHCi> let f x = x^2
GHCi> f 8
64

GHCi> let x = simple simple
GHCi> let x = 6
GHCi> x
6

\x -> x
GHCi> (\x -> x) 4
4
GHCi> (\x -> x) "Ð¿Ñ€Ð¸Ð²ÐµÑ‚"
Ð¿Ñ€Ð¸Ð²ÐµÑ‚
GHCi> (\x -> x) [1,2,3]
[1,2,3]

GHCi> (\x -> x*2) 2
4
GHCi> (\x -> x*2) 4
8

sumSquareOrSquareSum x y = if sumSquare > squareSum
                           then sumSquare
                           else squareSum
    where sumSquare = x^2 + y^2
          squareSum = (x+y)^2

sumSquareOrSquareSum x y = if (x^2 + y^2) > ((x+y)^2)
                           then (x^2 + y^2)
                           else (x+y)^2

body sumSquare squareSum = if sumSquare > squareSum
                           then sumSquare
                           else squareSum

sumSquareOrSquareSum x y = body (x^2 + y^2) ((x+y)^2)

body = (\sumSquare squareSum ->
         if sumSquare > squareSum
         then sumSquare
         else squareSum)

sumSquareOrSquareSum x y = (\sumSquare squareSum ->
                             if sumSquare > squareSum
                             then sumSquare
                             else squareSum) (x^2 + y^2) ((x+y)^2)

doubleDouble x = dubs*2
    where dubs = x*2

sumSquareOrSquareSum x y = let sumSquare = (x^2 + y^2)
                               squareSum = (x+y)^2
                           in
			     if sumSquare > squareSum
                             then sumSquare:}:
                             else squareSum

doubleDouble x = (\dubs -> dubs*2) (x*2)

overwrite x = let x = 2
              in let x = 3
               in let x = 4
                in x

GHCi> let x = 2
GHCi> x
2
GHCi> let x = 3
GHCi> x
3

overwrite x = (\x ->
                (\x ->
                  (\x -> x) 4) 3) 2

x = 4
add1 y = y + x
add2 y = (\x -> y + x) 3
add3 y = (\y ->
             (\x -> y + x) 1 ) 2

GHCi> add1 1
5
GHCi> add2 1
4
GHCi> add3 1
3

error
auth

ifEvenInc n = if even n
              then n+1
              else n

ifEvenDouble n = if even n
                 then n*2
                 else n

ifEvenSquare n = if even n
                 then n^2
                 else n

ifEven myFunction x = if even x
                      then myFunction x
                      else x

inc n = n + 1
double n = n * 2
square n = n^2

ifEvenInc n = ifEven inc n
ifEvenDouble n = ifEven double n
ifEvenSquare n = ifEven square n

GHCi> 1 + 2 * 3
7
GHCi> inc 2 * 3
9
GHCi> add x y = x + y
GHCi> add 1 2 * 3
9

GHCi> ifEven (\x -> x*2) 6
12

GHCi> ifEven (\x -> x^3) 4

author = ("Ð£Ð¸Ð»Ð»","ÐšÑƒÑ€Ñ‚")
GHCi> fst author
"Ð£Ð¸Ð»Ð»"
GHCi> snd author
"ÐšÑƒÑ€Ñ‚"

names = [("Ð˜ÑÐ½","ÐšÐµÑ€Ñ‚Ð¸Ñ"),
         ("Ð‘ÐµÑ€Ð½Ð°Ñ€Ð´","Ð¡Ð°Ð¼Ð½ÐµÑ€"),
         ("ÐŸÐ¸Ñ‚ÐµÑ€","Ð¥ÑƒÐº"),
         ("Ð¡Ñ‚Ð¸Ð²ÐµÐ½","ÐœÐ¾Ñ€Ñ€Ð¸Ñ")]

names = [("Ian", "Curtis"),
          ("Bernard", "Sumner"),
          ("Peter", "Hook"),
          ("Stephen", "Morris")]

Prelude Data.List> :{
Prelude Data.List| names = [("Ian", "Curtis"),
Prelude Data.List|           ("Bernard", "Sumner"),
Prelude Data.List|           ("Peter", "Hook"),
Prelude Data.List|           ("Stephen", "Morris")]
Prelude Data.List| :}
Prelude Data.List> sort names
[("Bernard","Sumner"),("Ian","Curtis"),("Peter","Hook"),("Stephen","Morris")]


import Data.List
GHCi> sort names
[("Ð‘ÐµÑ€Ð½Ð°Ñ€Ð´","Ð¡Ð°Ð¼Ð½ÐµÑ€"),("Ð˜ÑÐ½","ÐšÐµÑ€Ñ‚Ð¸Ñ"),("ÐŸÐ¸Ñ‚ÐµÑ€","Ð¥ÑƒÐº"), ("Ð¡Ñ‚Ð¸Ð²ÐµÐ½","ÐœÐ¾Ñ€Ñ€Ð¸Ñ")]

compareLastNames name1 name2 = if lastName1 > lastName2
                               then GT
                               else
                                 if lastName1 < lastName2
                                 then LT
                                 else EQ
   where lastName1 = snd name1
         lastName2 = snd name2

GHCi> sortBy compareLastNames names
[("Ð˜ÑÐ½","ÐšÐµÑ€Ñ‚Ð¸Ñ"),("Ð¡Ñ‚Ð¸Ð²ÐµÐ½","ÐœÐ¾Ñ€Ñ€Ð¸Ñ"),("Ð‘ÐµÑ€Ð½Ð°Ñ€Ð´","Ð¡Ð°Ð¼Ð½ÐµÑ€"),
 (""ÐŸÐ¸Ñ‚ÐµÑ€","Ð¥ÑƒÐº"")]

Prelude Data.List> sortBy compareLastNames names
[("Ian","Curtis"),("Peter","Hook"),("Stephen","Morris"),("Bernard","Sumner")]

compareLastNames name1 name2 =
       if lastName1 > lastName2
       then GT
       else if lastName1 < lastName2
       then LT
       else if firstName1 > firstName2
          then GT
          else if firstName1 < firstName2
               then LT
               else EQ
  where lastName1 = snd name1
        lastName2 = snd name2
        firstName1 = fst name1
        firstName2 = fst name2

relude Data.List> sortBy compareLastNames names
[("Ian","Curtis"),("Peter","Hook"),("Stephen","Morris"),("Bernard","Sumner")]


addressLetter name location = nameText ++ " - " ++ location
      where nameText = (fst name) ++ " " ++ (snd name)

GHCi> addressLetter ("Ð‘Ð¾Ð±","Ð¡Ð¼Ð¸Ñ‚") "Ð/Ñ 1234, Ð¡Ð°Ð½-Ð¤Ñ€Ð°Ð½Ñ†Ð¸ÑÐºÐ¾, ÑˆÑ‚Ð°Ñ‚ ÐšÐ°Ð»Ð¸Ñ„Ð¾Ñ€Ð½Ð¸Ñ, 94111"
"Ð‘Ð¾Ð± Ð¡Ð¼Ð¸Ñ‚ - Ð/Ñ 1234, Ð¡Ð°Ð½-Ð¤Ñ€Ð°Ð½Ñ†Ð¸ÑÐºÐ¾, ÑˆÑ‚Ð°Ñ‚ ÐšÐ°Ð»Ð¸Ñ„Ð¾Ñ€Ð½Ð¸Ñ, 94111"

Prelude Data.List> addressLetter ("Bob", "Smith") "PO Box 1234, San Francisco, CA 94111"
"Bob Smith - PO Box 1234, San Francisco, CA 94111"

sfOffice name =
   if lastName < "Ã‹"
   then nameText ++
        " - Ð/Ñ 1234, Ð¡Ð°Ð½-Ð¤Ñ€Ð°Ð½Ñ†Ð¸ÑÐºÐ¾, ÑˆÑ‚Ð°Ñ‚ ÐšÐ°Ð»Ð¸Ñ„Ð¾Ñ€Ð½Ð¸Ñ, 94111"
   else nameText ++
        " - Ð/Ñ 1010, Ð¡Ð°Ð½-Ð¤Ñ€Ð°Ð½Ñ†Ð¸ÑÐºÐ¾, ÑˆÑ‚Ð°Ñ‚ ÐšÐ°Ð»Ð¸Ñ„Ð¾Ñ€Ð½Ð¸Ñ, 94109"

  where lastName = snd name
        nameText = (fst name) ++ " " ++ lastName

nyOffice = nameText ++
           ": Ð/Ñ 789, ÐÑŒÑŽ-Ð™Ð¾Ñ€Ðº, ÑˆÑ‚Ð°Ñ‚ ÐÑŒÑŽ-Ð™Ð¾Ñ€Ðº, 10013"
   where nameText = (fst name) ++ " " ++ (snd name)

renoOffice = nameText ++ " - Ð/Ñ 456, Ð Ð¸Ð½Ð¾, ÑˆÑ‚Ð°Ñ‚ ÐÐµÐ²Ð°Ð´Ð°, 89523"
   where nameText = snd name

getLocationFunction location =
      case location of
        "ny" -> nyOffice
        "sf" -> sfOffice
        "reno" -> renoOffice
          _ -> (\name ->
                (fst name) ++ " " ++ (snd name))

addressLetter name location = locationFunction name
   where locationFunction = getlocationFunction location

GHCi> addressLetter ("Ð‘Ð¾Ð±","Ð¡Ð¼Ð¸Ñ‚") "ny"
"Ð‘Ð¾Ð± Ð¡Ð¼Ð¸Ñ‚: Ð/Ñ 789, ÐÑŒÑŽ-Ð™Ð¾Ñ€Ðº, ÑˆÑ‚Ð°Ñ‚ ÐÑŒÑŽ-Ð™Ð¾Ñ€Ðº, 10013"
GHCi> addressLetter ("Ð‘Ð¾Ð±","Ð”Ð¶Ð¾Ð½Ñ") "ny"
"Ð‘Ð¾Ð± Ð”Ð¶Ð¾Ð½Ñ: Ð/Ñ 789, ÐÑŒÑŽ-Ð™Ð¾Ñ€Ðº, ÑˆÑ‚Ð°Ñ‚ ÐÑŒÑŽ-Ð™Ð¾Ñ€Ðº, 10013"
GHCi> addressLetter ("Ð”ÐµÐ¹Ð·Ð¸","Ð¡Ð¼Ð¸Ñ‚") "sf"
"Ð”ÐµÐ¹Ð·Ð¸ Ð¡Ð¼Ð¸Ñ‚ - Ð/Ñ 1010, Ð¡Ð°Ð½-Ð¤Ñ€Ð°Ð½Ñ†Ð¸ÑÐºÐ¾, ÑˆÑ‚Ð°Ñ‚ ÐšÐ°Ð»Ð¸Ñ„Ð¾Ñ€Ð½Ð¸Ñ, 94109"
GHCi> addressLetter ("Ð‘Ð¾Ð±","Ð¡Ð¼Ð¸Ñ‚") "reno"
"Ð¡Ð¼Ð¸Ñ‚ - Ð/Ñ 456, Ð Ð¸Ð½Ð¾, ÑˆÑ‚Ð°Ñ‚ ÐÐµÐ²Ð°Ð´Ð°, 89523"
GHCi> addressLetter ("Ð‘Ð¾Ð±","Ð¡Ð¼Ð¸Ñ‚") "la"
"Ð‘Ð¾Ð± Ð¡Ð¼Ð¸Ñ‚"

Ð—Ð°Ð¼Ñ‹ÐºÐ°Ð½Ð¸Ñ â€” ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑÐ¼Ð¸
ifEvenInc n = ifEven inc n
ifEvenDouble n = ifEven double n
ifEvenSquare n = ifEven square n

genIfEven f = (\x -> ifEven f x)

ifEvenInc = genIfEven inc
(\x -> ifEven f x)
(\x -> ifEven inc x)
ifEvenInc = (\x -> ifEven inc x)

ifEven f x = if even x
             then f x
             else x
genIfEvenX x = (\f -> ifEven f x)

http://example.com/book/1234?token=1337hAsk3ll

getRequestUrl host apiKey resource id =
   host ++ "/" ++ resource ++ "/" ++ id ++ "?token=" ++ apiKey

GHCi> getRequestUrl "http://example.com" "1337hAsk3ll" "book" "1234"
"http://example.com/book/1234?token=1337hAsk3ll"

genHostRequestBuilder host = (\apiKey resource id ->
                               getRequestUrl host apikey resource id)

exampleUrlBuilder = genHostRequestBuilder "http://example.com"

GHCi> exampleUrlBuilder "1337hAsk3ll" "book" "1234"
"http://example.com/book/1234?token=1337hAsk3ll"

genApiRequestBuilder hostBuilder apiKey =
      (\resource id -> hostBuilder apiKey resource id)

myExampleUrlBuilder = genApiRequestBuilder exampleUrlBuilder
                      "1337hAsk3ll"

GHCi> myExampleUrlBuilder "book" "1234"
"http://example.com/book/1234?token=1337hAsk3ll"

add4 a b c d = a + b + c + d
addXto3 x = (\b c d -> add4 x b c d)
genApiRequestBuilder hostBuilder apiKey resource =
                     (\id -> hostBuilder apiKey resource id)

addXYto2 x y = (\c d -> add4 x y c d)
GHCi> mystery = add4 3

GHCi> mystery 2 3 4
12
GHCi> mystery 5 6 7
21

GHCi> anotherMystery = add4 2 3
GHCi> anotherMystery 1 2
8
GHCi> anotherMystery 4 5
14

exampleUrlBuilder = getRequestUrl "http://example.com"
myExampleUrlBuilder = exampleUrlBuilder "1337hAsk3ll"

exampleUrlBuilder = getRequestUrl "http://example.com" ? ? ?
myExampleUrlBuilder = exampleUrlBuilder "1337hAsk3ll" ? ?
myExampleUrlBuilder resource id

exampleBuilder = getRequestUrl "http://example.com"
                               "1337hAsk3ll"
                               "book"

addressLetter name location = locationFunction name
   where locationFunction = getLocationFunction location

addressLetterV2 location name = addressLetter name location

flipBinaryArgs binaryFunction = (\x y -> binaryFunction y x)

addressLetterV2 = flipBinaryArgs addressLetter
addressLetterNY = addressLetterV2 "ny"

GHCi> addressLetterNY ("Ð‘Ð¾Ð±", "Ð¡Ð¼Ð¸Ñ‚")
Ð‘Ð¾Ð± Ð¡Ð¼Ð¸Ñ‚: Ð/Ñ 789, ÐÑŒÑŽ-Ð™Ð¾Ñ€Ðº, ÑˆÑ‚Ð°Ñ‚ ÐÑŒÑŽ-Ð™Ð¾Ñ€Ðº, 10013

GHCi> 2 + 3
5
GHCi> (+) 2 3
5
GHCi> 10 / 2
5.0
GHCi> (/) 10 2
5.0

subtract2 = flip (-) 2

GHCi> head [1,2,3]
1
GHCi> head [[1,2],[3,4],[5,6]]
[1,2]

GHCi> tail [1,2,3]
[2,3]
GHCi> tail [3]
[]

GHCi> 1:[]
[1]

GHCi> 1:2:3:4:[]
[1,2,3,4]

GHCi> (1,2):(3,4):(5,6):[]
[(1,2),(3,4),(5,6)]

GHCi> 1:[2,3,4]
[1,2,3,4]

GHCi>[â€™Ð¿â€™,â€™Ñ€â€™,â€™Ð¸â€™,â€™Ð²â€™,â€™Ðµâ€™,â€™Ñ‚â€™]
"Ð¿Ñ€Ð¸Ð²ÐµÑ‚"
GHCi> â€™Ð¿â€™:â€™Ñ€â€™:â€™Ð¸â€™:â€™Ð²â€™:â€™Ðµâ€™:â€™Ñ‚â€™:[]
"Ð¿Ñ€Ð¸Ð²ÐµÑ‚"

GHCi> â€™Ð¿â€™:"Ñ€Ð¸Ð²ÐµÑ‚"
"Ð¿Ñ€Ð¸Ð²ÐµÑ‚"

GHCi> "Ð¿":"Ñ€Ð¸Ð²ÐµÑ‚"
GHCi> [â€™Ð¿â€™]:[â€™Ñ€â€™,â€™Ð¸â€™,â€™Ð²â€™,â€™Ðµâ€™,â€™Ñ‚â€™]
GHCi> â€™Ð¿â€™:[]:â€™Ñ€â€™:â€™Ð¸â€™:â€™Ð²â€™:â€™Ðµâ€™:â€™â€™Ñ‚":[]

GHCi> "Ð¿" ++ "Ñ€Ð¸Ð²ÐµÑ‚"
"Ð¿Ñ€Ð¸Ð²ÐµÑ‚"
GHCi> [1] ++ [2,3,4]
[1,2,3,4]

GHCi> [1 .. 10]
[1,2,3,4,5,6,7,8,9,10]
GHCi> [1,3 .. 10]
[1,3,5,7,9]
GHCi> [1, 1.5 .. 5]
[1.0,1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0]
GHCi> [1,0 .. -10]
[1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]

GHCi> [1..]
[1,2,3,4,5,6,7,8,9,10,11,12 ..

simple x = x
longList = [1 .. ]
stillLongList = simple longList

backwardsInfinity = reverse [1..] compiled
GHCi> backwardsInfinity problem

GHCi> [1,2,3] !! 0
1
GHCi> "Ñ‰ÐµÐ½ÐºÐ¸" !! 3
â€™Ðºâ€™
GHCi> [1..10] !! 11
*** Exception: Prelude.!!: index too large

GHCi> (!!) [1,2,3] 0
1

GHCi> paExample1 = (!!) "ÑÐ¾Ð±Ð°ÐºÐ°"
GHCi> paExample1 2
â€™Ð±â€™
ÑÐµÑ‡ÐµÐ½Ð¸Ðµ
GHCi> paExample2 = ("ÑÐ¾Ð±Ð°ÐºÐ°" !!)
GHCi> paExample2 2
â€™Ð±â€™

GHCi> length [1..20]
20
GHCi> length [(10,20),(1,2),(15,16)]
3
GHCi> length "ÐŸÑ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ð¸Ñ€ÑƒÐ¹ Ð½Ð° Haskell"
23

GHCi> reverse [1,2,3]
[3,2,1]
GHCi> reverse " ÑÑ‹Ñ€"
"Ñ€Ñ‹Ñ"

isPalindrome word = word == reverse word
GHCi> isPalindrome "ÑÑ‹Ñ€"
False
GHCi> isPalindrome "Ñ‚Ð¾Ð¿Ð¾Ñ‚"
True
GHCi> isPalindrome [1,2,3]
False
GHCi> isPalindrome [1,2,1]
True

GHCi> elem 13 [0,13 .. 100]
True
GHCi> elem â€™Ð¿â€™ " ÑÑ‹Ñ€"
False

respond phrase = if â€™!â€™ â€˜elemâ€˜ phrase
                 then "ÐžÐ³Ð¾!"
                 else "ÐÑƒ, Ð¾Ðº"
GHCi> respond "Ð¿Ñ€Ð¸Ð²ÐµÑ‚"
"ÐÑƒ, Ð¾Ðº"
GHCi> respond "Ð¿Ñ€Ð¸Ð²ÐµÑ‚!"
"ÐžÐ³Ð¾!"

GHCi> take 5 [2,4..100]
[2,4,6,8,10]
GHCi> take 3 "Ð·Ð°Ð¼ÐµÑ‡Ð°Ñ‚ÐµÐ»ÑŒÐ½Ð¾"
"Ð·Ð°Ð¼"

GHCi> take 1000000 [1]
[1]

takeLast n aList = reverse (take n (reverse aList))
GHCi> takeLast 10 [1..100]
[91,92,93,94,95,96,97,98,99,100]

GHCi> drop 2 [1,2,3,4,5]
[3,4,5]
GHCi> drop 6 "ÐžÑ‡ÐµÐ½ÑŒ Ð·Ð´Ð¾Ñ€Ð¾Ð²Ð¾"
"Ð·Ð´Ð¾Ñ€Ð¾Ð²Ð¾"

GHCi> zip [1,2,3] [2,4,6]
[(1,2),(2,4),(3,6)]
GHCi> zip "Ð¿Ñ‘Ñ" "ÐºÑ€Ð¾Ð»Ð¸Ðº"
[(â€™Ð¿â€™,â€™Ðºâ€™),(â€™Ñ‘â€™,â€™Ñ€â€™),(â€™Ñâ€™,â€™Ð¾â€™)]
GHCi> zip [â€™aâ€™ .. â€™fâ€™] [1 .. ]
[(â€™aâ€™,1),(â€™bâ€™,2),(â€™câ€™,3),(â€™dâ€™,4),(â€™eâ€™,5),(â€™fâ€™,6)]

ones n = take n (cycle [1])
GHCi> ones 2
[1,1]
GHCi> ones 4
[1,1,1,1]

assignToGroups n aList = zip groups aList
where groups = cycle [1..n]
GHCi> assignToGroups 3 ["Ñ„Ð°Ð¹Ð»1.txt","Ñ„Ð°Ð¹Ð»2.txt","Ñ„Ð°Ð¹Ð»3.txt"
 ,"Ñ„Ð°Ð¹Ð»4.txt","Ñ„Ð°Ð¹Ð»5.txt","Ñ„Ð°Ð¹Ð»6.txt"
 ,"Ñ„Ð°Ð¹Ð»7.txt","Ñ„Ð°Ð¹Ð»8.txt","Ñ„Ð°Ð¹Ð»9.txt"]
[(1,"Ñ„Ð°Ð¹Ð»1.txt"),(2,"Ñ„Ð°Ð¹Ð»2.txt"),(3,"Ñ„Ð°Ð¹Ð»3.txt"),
Ã‡ (1,"Ñ„Ð°Ð¹Ð»4.txt"),(2,"Ñ„Ð°Ð¹Ð»5.txt"),(3,"Ñ„Ð°Ð¹Ð»6.txt"),
Ã‡ (1,"Ñ„Ð°Ð¹Ð»7.txt"),(2,"Ñ„Ð°Ð¹Ð»8.txt"),(3,"Ñ„Ð°Ð¹Ð»9.txt")]
GHCi> assignToGroups 2 ["Ð‘Ð¾Ð±","ÐšÑÑ‚","Ð¡ÑŒÑŽ","Ð”Ð¶Ð¾Ð°Ð½","ÐœÐ°Ð¹Ðº"]
[(1,"Ð‘Ð¾Ð±"),(2,"ÐšÑÑ‚"),(1,"Ð¡ÑŒÑŽ"),(2,"Ð”Ð¶Ð¾Ð°Ð½"),(1,"ÐœÐ°Ð¹Ðº")]

GHCi> take 3 [1,2,3,4]
[1,2,3]

myGCD a b = if remainder == 0
            then b
            else myGCD b remainder
   where remainder = a â€˜modâ€˜ b

sayAmount n = case n of
    1 -> "Ð¾Ð´Ð¸Ð½"
    2 -> "Ð´Ð²Ð°"
    n -> "Ð¼Ð½Ð¾Ð³Ð¾"

sayAmount 1 = "Ð¾Ð´Ð¸Ð½"
sayAmount 2 = "Ð´Ð²Ð°"
sayAmount n = "Ð¼Ð½Ð¾Ð³Ð¾"

isEmpty [] = True
isEmpty aList = False

isEmpty [] = True
isEmpty _ = False

myHead (x:xs) = x

myHead [1,2,3]
myHead (1:[2,3])
myHead (x:xs) = x 
(x=1)

myHead (x:xs) = x
myHead [] = error "Ð“Ð¾Ð»Ð¾Ð²Ð° Ñƒ Ð¿ÑƒÑÑ‚Ð¾Ð³Ð¾ ÑÐ¿Ð¸ÑÐºÐ° Ð¾Ñ‚ÑÑƒÑ‚ÑÐ²ÑƒÐµÑ‚"

myTail (_:xs) = xs

GHCi> drop 3 [1, 2, 3, 4]
[4]

myLength [] = 0
myLength xs = 1 + myLength (tail xs)

myLength [] = 0
myLength (x:xs) = 1 + myLength xs

myTake _ [] = []
myTake 0 _ = []
myTake n (x:xs) = x:rest
where rest = myTake (n - 1) xs

finiteCycle (first:rest) = first:rest ++ [first]
myCycle (first:rest) = first : myCycle (rest++[first])

ackermann 0 n = n + 1
ackermann m 0 = ackermann (m - 1) 1
ackermann m n = ackermann (m - 1) (ackermann m (n - 1))

GHCi> :set +s
GHCi> ackermann 3 3
61
(0.01 secs)
GHCi> ackermann 3 8
2045
(3.15 secs)
GHCi> ackermann 3 9
4093
(12.97 secs)

collatz 1 = 1
collatz n =
if even n
then 1 + collatz (n â€˜divâ€˜ 2)
else 1 + collatz (n*3 + 1)

GHCi> collatz 9
20
GHCi> collatz 999
50
GHCi> collatz 92
18
GHCi> collatz 91
93

GHCi> map collatz [100 .. 120]
[26,26,26,88,13,39,13,101,114,114,114,70, 21, 13, 34, 34, 21, 21, 34, 34, 21]

fib 0 = 0
fib 1 = 1
fib n = fib (n - 1) + fib (n - 2)

add3ToAll [] = []
add3ToAll (x:xs) = (3 + x) : add3ToAll xs
mul3ByAll [] = []
mul3ByAll (x:xs) = (3 * x) : mul3ByAll xs

GHCi> map reverse ["ÑÐ¾Ð±Ð°ÐºÐ°", "ÐºÐ¾Ñ‚", "Ð»Ð¾ÑÑŒ"]
["Ð°ÐºÐ°Ð±Ð¾Ñ","Ñ‚Ð¾Ðº","ÑŒÑÐ¾Ð»"]
GHCi> map head ["ÑÐ¾Ð±Ð°ÐºÐ°", "ÐºÐ¾Ñ‚", "Ð»Ð¾ÑÑŒ"]
"ÑÐºÐ»"
GHCi> map (take 4) ["Ñ‚Ñ‹ÐºÐ²Ð°", "Ð¿Ð¸Ñ€Ð¾Ð³", "Ð°Ñ€Ð°Ñ…Ð¸ÑÐ¾Ð²Ð¾Ðµ Ð¼Ð°ÑÐ»Ð¾"]
["Ñ‚Ð°ÐºÐ²","Ð¿Ð¸Ñ€Ð¾","Ð°Ñ€Ð°Ñ…"]

GHCi> map (++"!") ["Ð¿Ð¾ÐµÐ·Ð´","ÑÐ°Ð¼Ð¾Ð»Ñ‘Ñ‚","Ð»Ð¾Ð´ÐºÐ°"]
["Ð¿Ð¾ÐµÐ·Ð´!","ÑÐ°Ð¼Ð¾Ð»Ñ‘Ñ‚!","Ð»Ð¾Ð´ÐºÐ°!"]
GHCi> map (^2) [1,2,3] [1,4,9]
[1,4,9]

addBang [] = []
addBang (x:xs) = (x ++ "!") : addBang xs

squareAll [] = []
squareAll (x:xs) = x^2 : squareAll xs

myMap f [] = []
myMap f (x:xs) = (f x) : myMap f xs

GHCi> filter even [1,2,3,4]
[2,4]
GHCi> filter (\(x:xs) -> x == â€™aâ€™) ["Ð°Ñ€Ð±ÑƒÐ·","Ð±Ð°Ð½Ð°Ð½","Ð°Ð²Ð¾ÐºÐ°Ð´Ð¾"]
["Ð°Ñ€Ð±ÑƒÐ·","Ð°Ð²Ð¾ÐºÐ°Ð´Ð¾"]

myFilter test [] = []
myFilter test (x:xs) = if test x
                       then x:myFilter test xs
                       else myFilter test xs

GHCi> foldl (+) 0 [1,2,3,4]
10

foldl (+) 0 [1,2,3,4]
0 + 1 = 1
foldl (+) 1 [2,3,4]
1 + 2 = 3
foldl (+) 3 [3,4]
3 + 3 = 6
foldl (+) 6 [4]
6 + 4 = 10
foldl (+) 10 [] = 10

concatAll xs = foldl (++) "" xs

remove test [] = []
remove test (x:xs) = if test x
                     then remove test xs
                     else x:remove test xs

sumOfSquares xs = foldl (+) 0 (map (^2) xs)

rcons xs y = y:xs
myReverse xs = foldl rcons [] xs

foldl rcons [] [1,2,3]
1:[]
foldl rcons [1] [2,3]
2:[1]
foldl rcons [2,1] [3]
3:[2,1]
foldl rcons [3,2,1] [] = [3,2,1]

myFoldl f init [] = init
myProduct xs = foldl (*) 1 xs

myFoldl f init [] = init
myFoldl f init (x:xs) = myFoldl f newInit xs
   where newInit = f init x

myFoldr f init [] = init
myFoldr f init (x:xs) = f x rightResult
  where rightResult = myFoldr f init xs

GHCi> foldl (+) 0 [1,2,3,4]
10
GHCi> foldr (+) 0 [1,2,3,4]
10

GHCi> foldl (-) 0 [1,2,3,4]
-10
GHCi> foldr (-) 0 [1,2,3,4]
-2

foldl
foldlâ€™ â€” Ð½ÐµÐ»ÐµÐ½Ð¸Ð²Ð°Ñ Ð²ÐµÑ€ÑÐ¸Ñ
foldr

cup ml = \_ -> ml
cup ml = \message -> message ml
GHCi> aCup = cup 180
coffeeCup = cup 500
getMl aCup = aCup (\ml -> ml)
GHCi> getMl coffeeCup
500

drink aCup mlDrank = cup (ml - mlDrank)
      where ml = getMl aCup 

GHCi> afterASip = drink coffeeCup 30
GHCi> getMl afterASip
470
GHCi> afterTwoSips = drink afterASip 30
GHCi> getMl afterTwoSips
440

GHCi> afterGulp = drink afterTwoSips 120
GHCi> getMl afterGulp
320

drink aCup mlDrank = if mlDiff >= 0
                     then cup mlDiff
                     else cup 0
    where ml = getMl aCup
          mlDiff = ml - mlDrank

GHCi> afterBigGulp = drink coffeeCup 1000
GHCi> getMl afterBigGulp
0

isEmpty aCup = getMl aCup == 0
afterManySips = foldl drink coffeeCup [30, 30, 30, 30, 30]

GHCi> getMl afterManySips
350

robot (name, attack, hp) = \message ->
                              message (name, attack, hp)

killerRobot = robot ("ÑƒÐ±Ð¸Ð¹Ñ†Ð°", 25, 200)

name (n, _, _) = n
attack (_, a, _) = a
hp (_, _, hp) = hp

getName aRobot = aRobot name
getAttack aRobot = aRobot attack
getHP aRobot = aRobot hp

GHCi> getAttack killerRobot
25
GHCi> getHP killerRobot
200

setName aRobot newName = aRobot (\(n, a, h) ->
                                  robot (newName, a, h))
setAttack aRobot newAttack = aRobot (\(n, a, h) ->
                                       robot (n, newAttack, h))
setHP aRobot newHP = aRobot (\(n, a, h) ->
                                robot (n, a, newHP))

nicerRobot = setName killerRobot "ÐºÐ¾Ñ‚Ñ‘Ð½Ð¾Ðº"
gentlerRobot = setAttack killerRobot 5
softerRobot = setHP killerRobot 50

printRobot aRobot = aRobot (\(n, a, h) ->
                              n ++
                              " Ð°Ñ‚Ð°ÐºÐ°:" ++ (show a) ++
                              " Ð·Ð´Ð¾Ñ€Ð¾Ð²ÑŒÐµ:" ++ (show h))

GHCi> printRobot killerRobot
"ÑƒÐ±Ð¸Ð¹Ñ†Ð° Ð°Ñ‚Ð°ÐºÐ°:25 Ð·Ð´Ð¾Ñ€Ð¾Ð²ÑŒÐµ:200"
GHCi> printRobot nicerRobot
"ÐºÐ¾Ñ‚Ñ‘Ð½Ð¾Ðº Ð°Ñ‚Ð°ÐºÐ°:25 Ð·Ð´Ð¾Ñ€Ð¾Ð²ÑŒÐµ:200"
GHCi> printRobot gentlerRobot
"ÑƒÐ±Ð¸Ð¹Ñ†Ð° Ð°Ñ‚Ð°ÐºÐ°:5 Ð·Ð´Ð¾Ñ€Ð¾Ð²ÑŒÐµ:200"
GHCi> printRobot softerRobot
"ÑƒÐ±Ð¸Ð¹Ñ†Ð° Ð°Ñ‚Ð°ÐºÐ°:25 Ð·Ð´Ð¾Ñ€Ð¾Ð²ÑŒÐµ:50"

damage aRobot attackDamage =
         aRobot (\(n, a, h) -> robot (n, a, h - attackDamage))

GHCi> afterHit = damage killerRobot 90
GHCi> getHP afterHit
110

fight aRobot defender = damage defender attack
  where attack = if getHP aRobot > 10
                 then getAttack aRobot
                 else 0

gentleGiant = robot ("ÐœÐ¸ÑÑ‚ÐµÑ€ Ð”Ñ€ÑƒÐ¶ÐµÐ»ÑŽÐ±Ð½Ñ‹Ð¹", 10, 300)

gentleGiantRound1 = fight killerRobot gentleGiant
killerRobotRound1 = fight gentleGiant killerRobot
gentleGiantRound2 = fight killerRobotRound1 gentleGiantRound1
killerRobotRound2 = fight gentleGiantRound1 killerRobotRound1
gentleGiantRound3 = fight killerRobotRound2 gentleGiantRound2
killerRobotRound3 = fight gentleGiantRound2 killerRobotRound2

GHCi> printRobot gentleGiantRound3
"ÐœÐ¸ÑÑ‚ÐµÑ€ Ð”Ñ€ÑƒÐ¶ÐµÐ»ÑŽÐ±Ð½Ñ‹Ð¹ Ð°Ñ‚Ð°ÐºÐ°:10 Ð·Ð´Ð¾Ñ€Ð¾Ð²ÑŒÐµ:225"
GHCi> printRobot killerRobotRound3
"ÑƒÐ±Ð¸Ð¹Ñ†Ð° Ð°Ñ‚Ð°ÐºÐ°:25 Ð·Ð´Ð¾Ñ€Ð¾Ð²ÑŒÐµ:170"

fastRobot = robot ("Ð±Ñ‹ÑÑ‚Ñ€Ñ‹Ð¹", 15, 40)
slowRobot = robot ("Ñ‚Ð¾Ñ€Ð¼Ð¾Ð·", 20, 30)

fastRobotRound1 = fight slowRobot fastRobot
slowRobotRound1 = fight fastRobot slowRobot
fastRobotRound2 = fight slowRobotRound1 fastRobotRound1
slowRobotRound2 = fight fastRobotRound1 slowRobotRound1
fastRobotRound3 = fight slowRobotRound2 fastRobotRound2
slowRobotRound3 = fight fastRobotRound2 slowRobotRound2

GHCi> printRobot fastRobotRound3
"Ð±Ñ‹ÑÑ‚Ñ€Ñ‹Ð¹ Ð°Ñ‚Ð°ÐºÐ°:15 Ð·Ð´Ð¾Ñ€Ð¾Ð²ÑŒÐµ:0"
GHCi> printRobot slowRobotRound3
"Ñ‚Ð¾Ñ€Ð¼Ð¾Ð· Ð°Ñ‚Ð°ÐºÐ°:20 Ð·Ð´Ð¾Ñ€Ð¾Ð²ÑŒÐµ:0"

slowRobotRound1 = fight fastRobot slowRobot
fastRobotRound1 = fight slowRobotRound1 fastRobot
fastRobotRound2 = fight fastRobotRound1 slowRobotRound1
fastRobotRound2 = fight slowRobotRound2 fastRobotRound1
fastRobotRound2 = fight fastRobotRound2 slowRobotRound2
fastRobotRound2 = fight slowRobotRound3 fastRobotRound2

GHCi> printRobot fastRobotRound3
"Ð±Ñ‹ÑÑ‚Ñ€Ñ‹Ð¹ Ð°Ñ‚Ð°ÐºÐ°:15 Ð·Ð´Ð¾Ñ€Ð¾Ð²ÑŒÐµ:20"
GHCi> printRobot slowRobotRound3
"Ñ‚Ð¾Ñ€Ð¼Ð¾Ð· Ð°Ñ‚Ð°ÐºÐ°:20 Ð·Ð´Ð¾Ñ€Ð¾Ð²ÑŒÐµ:-15"

fastRobotRound3 = fight slowRobotRound3 fastRobotRound2
fastRobotRound2 = fight slowRobotRound2 fastRobotRound1
fastRobotRound1 = fight slowRobotRound1 fastRobot
slowRobotRound2 = fight fastRobotRound1 slowRobotRound1
slowRobotRound3 = fight fastRobotRound2 slowRobotRound2
slowRobotRound1 = fight fastRobot slowRobot

GHCi> printRobot fastRobotRound3
"Ð±Ñ‹ÑÑ‚Ñ€Ñ‹Ð¹ Ð°Ñ‚Ð°ÐºÐ°:15 Ð·Ð´Ð¾Ñ€Ð¾Ð²ÑŒÐµ:20"
GHCi> printRobot slowRobotRound3
"Ñ‚Ð¾Ñ€Ð¼Ð¾Ð· Ð°Ñ‚Ð°ÐºÐ°:20 Ð·Ð´Ð¾Ñ€Ð¾Ð²ÑŒÐµ:-15"


x :: Int
x = 2

x :: Int
x = 2
GHCi> x*2000
4000
GHCi> x^2000
0

y :: Integer
y = 2

GHCi> y*2000
4000
GHCi> y^2000
11481306952742545242328332011776819840223177020886952004776427
36825766261392370313856659486316506269918445964638987462773447
11896086305533142593135616665318539129989145312280000688779148
24004487142892699006348624478161546364638836394731702604046635
39709049965581623988089446296056233116495361642219703326813441
68908984458505602379484807914058900934776500429002716706625830
52200813223628129176126788331720659899539641812702177985840404
21598531832515408894339020919205549577835896720391600819572166
30582755380425583726015528348786419432054508915275783882625175
435528800822842770817965453762184851149029376

letter :: Char
letter = â€™aâ€™

interestRate :: Double
interestRate = 0.375

isFun :: Bool
isFun = True

values :: [Int]
values = [1,2,3]

testScores :: [Double]
testScores = [0.99,0.7,0.8]

letters :: [Char]
letters = [â€™aâ€™,â€™bâ€™,â€™câ€™]

GHCi> letters == "abc"
True

aPet :: [Char]
aPet = "ÐºÐ¾ÑˆÐºÐ°"

anotherPet :: String
anotherPet = "ÑÐ¾Ð±Ð°ÐºÐ°"

ageAndHeight ::(Int,Int)
ageAndHeight = (34,74)

firstLastMiddle :: (String,String,Char)
firstLastMiddle = ("ÐžÑÐºÐ°Ñ€","Ð“Ñ€Ð¾ÑƒÑˆ",â€™Ð”â€™)

streetAddress :: (Int,String)
streetAddress = (123,"ÑƒÐ». Ð¡Ñ‡Ð°ÑÑ‚ÑŒÑ")

double :: Int -> Int
double n = n * 2

half :: Int -> Double
half n = n/2

half n = (fromIntegral n) / 2
GHCi> 5/2
2.5

halve :: Integer -> Integer
halve value = value â€˜divâ€˜ 2

GHCi> show 6
"6"
GHCi> show â€™câ€™
"â€™câ€™"
GHCi> show 6.0
"6.0"

z = read "6"
q = z / 2

printDouble :: Int -> String
printDouble value = show (value*2)

anotherNumber :: Int
anotherNumber = read "6"

GHCi> read "6" :: Int
6
GHCi> read "6" :: Double
6.0

makeAddress :: Int -> String -> String -> (Int, String, String)
makeAddress number street town = (number,street,town)

makeAddress number street town = (number, street, town)

makeAddressLambda = (\number ->
                      (\street ->
                       (\town -> (number, street, town)))

GHCi> (((makeAddressLambda 123) "ÑƒÐ». Ð¡Ñ‡Ð°ÑÑ‚ÑŒÑ") "Ð¥Ð°ÑÐºÐµÐ»ÑŒÑ‚Ð°ÑƒÐ½")
(123,"ÑƒÐ». Ð¡Ñ‡Ð°ÑÑ‚ÑŒÑ","Ð¥Ð°ÑÐºÐµÐ»ÑŒÑ‚Ð°ÑƒÐ½")

GHCi> (((makeAddress 123) "ÑƒÐ». Ð¡Ñ‡Ð°ÑÑ‚ÑŒÑ") "Ð¥Ð°ÑÐºÐµÐ»ÑŒÑ‚Ð°ÑƒÐ½")
(123,"ÑƒÐ». Ð¡Ñ‡Ð°ÑÑ‚ÑŒÑ","Ð¥Ð°ÑÐºÐµÐ»ÑŒÑ‚Ð°ÑƒÐ½")

GHCi> makeAddressLambda 123 "ÑƒÐ». Ð¡Ñ‡Ð°ÑÑ‚ÑŒÑ" "Ð¥Ð°ÑÐºÐµÐ»ÑŒÑ‚Ð°ÑƒÐ½"
(123,"ÑƒÐ». Ð¡Ñ‡Ð°ÑÑ‚ÑŒÑ","Ð¥Ð°ÑÐºÐµÐ»ÑŒÑ‚Ð°ÑƒÐ½")

ifEven :: (Int -> Int) -> Int -> Int
          ifEven f n = if even n
                       then f n
                       else n

makeAddress :: Int -> String -> String -> (Int,String,String)

String -> String -> (Int,String,String)

((makeAddress 123) "ÑƒÐ». Ð¡Ñ‡Ð°ÑÑ‚ÑŒÑ")

String -> (Int,String,String)

(((makeAddress 123) "ÑƒÐ». Ð¡Ñ‡Ð°ÑÑ‚ÑŒÑ") "Ð¥Ð°ÑÐºÐµÐ»ÑŒÑ‚Ð°ÑƒÐ½")
(Int,String,String)

simpleInt :: Int -> Int
simpleInt n = n

simpleChar :: Char -> Char
simpleChar c = c

simple :: a -> a
simple x = x

makeTriple :: a -> b -> c -> (a,b,c)
makeTriple x y z = (x,y,z)

nameTriple = makeTriple "ÐžÑÐºÐ°Ñ€" â€™Ð“â€™ "Ð“Ñ€Ð¾ÑƒÑˆ"

makeTriple :: String -> Char -> String -> (String,Char,String)

f1 :: a -> a
f2 :: a -> b

map :: (a -> b) -> [a] -> [b]
map :: (a -> a) -> [a] -> [a] ? Why not
map show [1,2,3,4]

myFoldl f init [] = init
myFoldl f init (x:xs) = myFoldl f newInit xs
  where newInit = f init x

areaOfCircle :: Double -> Double
areaOfCircle :: Diameter -> Area

patientInfo :: String -> String -> Int -> Int -> String
patientInfo fname lname age height = name ++ " " ++ ageHeight
   where name = lname ++ ", " ++ fname
         ageHeight = "(Ð’Ð¾Ð·Ñ€Ð°ÑÑ‚: " ++ show age ++
                     "; Ñ€Ð¾ÑÑ‚: " ++ show height ++ "ÑÐ¼)"

GHCi> patientInfo "Ð”Ð¶Ð¾Ð½" "Ð”Ð¾Ñƒ" 43 188
"Ð”Ð¾Ñƒ, Ð”Ð¶Ð¾Ð½ (Ð’Ð¾Ð·Ñ€Ð°ÑÑ‚: 43; Ñ€Ð¾ÑÑ‚: 188ÑÐ¼)"
GHCi> patientInfo "Ð”Ð¶ÐµÐ¹Ð½" "Ð¡Ð¼Ð¸Ñ‚" 25 156
"Ð¡Ð¼Ð¸Ñ‚, Ð”Ð¶ÐµÐ¹Ð½ (Ð’Ð¾Ð·Ñ€Ð°ÑÑ‚: 25; Ñ€Ð¾ÑÑ‚: 156ÑÐ¼)"

type FirstName = String
type LastName = String
type Age = Int
type Height = Int

patientInfo :: FirstName -> LastName -> Age -> Height -> String

type PatientName = (String, String)

firstName :: PatientName -> String
firstName patient = fst patient

lastName :: PatientName -> String
lastName patient = snd patient


GHCi> testPatient = ("Ð”Ð¶Ð¾Ð½", "Ð”Ð¾Ñƒ")
GHCi> firstName testPatient
"Ð”Ð¶Ð¾Ð½"
GHCi> lastName testPatient
"Ð”Ð¾Ñƒ"

data Sex = Male | Female

patientInfoV2 :: PatientName -> Int -> Int -> String
patientInfoV2 (fname, lname) age height = name ++ " " ++
                                          ageHeight
   where name = lname ++ ", " ++ fname
         ageHeight = "(Ð’Ð¾Ð·Ñ€Ð°ÑÑ‚: " ++ show age ++
                     "; Ñ€Ð¾ÑÑ‚: " ++ show height ++ "ÑÐ¼)"

data Bool = True | False
sexInitial :: Sex -> Char
sexInitial Male = â€™Mâ€™
sexInitial Female = â€™Fâ€™

data RhType = Pos | Neg
data ABOType = A | B | AB | O

data BloodType = BloodType ABOType RhType

patient1BT :: BloodType
patient1BT = BloodType A Pos

patient2BT :: BloodType
patient2BT = BloodType O Neg

patient3BT :: BloodType
patient3BT = BloodType AB Pos

showRh :: RhType -> String
showRh Pos = "+"
showRh Neg = "-"

showABO :: ABOType -> String
showABO A = "A"
showABO B = "B"
showABO AB = "AB"
showABO O = "O"

showBloodType :: BloodType -> String
showBloodType (BloodType abo rh) = showABO abo ++ showRh rh

canDonateTo :: BloodType -> BloodType -> Bool
canDonateTo (BloodType O _) _ = True
canDonateTo _ (BloodType AB _) = True
canDonateTo (BloodType A _) (BloodType A _) = True
canDonateTo (BloodType B _) (BloodType B _) = True
canDonateTo _ _ = False

GHCi> canDonateTo patient1BT patient2BT
False
GHCi> canDonateTo patient2BT patient1BT
True
GHCi> canDonateTo patient2BT patient3BT
True
GHCi> canDonateTo patient1BT patient3BT
True
GHCi> canDonateTo patient3BT patient1BT
False

type MiddleName = String
data Name = Name FirstName LastName
          | NameWithMiddle FirstName MiddleName LastName  

showName :: Name -> String
showName (Name f l) = f ++ " " ++ l
showName (NameWithMiddle f m l) = f ++ " " ++ m ++ " " ++ l

name1 = Name "Ð”Ð¶ÐµÑ€Ð¾Ð¼" "Ð¡ÑÐ»Ð¸Ð½Ð´Ð¶ÐµÑ€"
name2 = NameWithMiddle "Ð”Ð¶ÐµÑ€Ð¾Ð¼" "Ð”ÑÐ²Ð¸Ð´" "Ð¡ÑÐ»Ð¸Ð½Ð´Ð¶ÐµÑ€"

GHCi> showName name1
"Ð”Ð¶ÐµÑ€Ð¾Ð¼ Ð¡ÑÐ»Ð¸Ð½Ð´Ð¶ÐµÑ€"
GHCi> showName name2
"Ð”Ð¶ÐµÑ€Ð¾Ð¼ Ð”ÑÐ²Ð¸Ð´ Ð¡ÑÐ»Ð¸Ð½Ð´Ð¶ÐµÑ€"

patientInfo :: String -> String -> Int -> Int -> String
patientInfo fname lname age height = name ++ " " ++ ageHeight
where name = lname ++ ", " ++ fname
ageHeight = "(Ð’Ð¾Ð·Ñ€Ð°ÑÑ‚: " ++ show age ++
            "; Ñ€Ð¾ÑÑ‚: " ++ show height ++ "ÑÐ¼)"

data Patient = Patient Name Sex Int Int Int BloodType

johnDoe :: Patient
johnDoe = Patient (Name "Ð”Ð¶Ð¾Ð½" "Ð”Ð¾Ñƒ") Male 43 188 92
                                      (BloodType AB Pos)

janeESmith :: Patient
janeESmith = Patient
               (NameWithMiddle "Ð”Ð¶ÐµÐ¹Ð½" "Ð­Ð»Ð¸Ð·Ð°Ð±ÐµÑ‚" "Ð¡Ð¼Ð¸Ñ‚")
               Female 28 157 64
               (BloodType O Neg)

getName :: Patient -> Name
getName (Patient n _ _ _ _ _) = n

getAge :: Patient -> Int
getAge (Patient _ _ a _ _ _) = a

getBloodType :: Patient -> BloodType
getBloodType (Patient _ _ _ _ _ bt) = bt


data Patient = Patient { name :: Name
                         , sex :: Sex
                         , age :: Int
                         , height :: Int
                         , weight :: Int
                         , bloodType :: BloodType}

jackieSmith :: Patient
jackieSmith = Patient { name = Name "Ð”Ð¶ÐµÐºÐ¸" "Ð¡Ð¼Ð¸Ñ‚"
                      , age = 43
                      , sex = Female
                      , height = 157
                      , weight = 52
                      , bloodType = BloodType O Neg }

GHCi> height jackieSmith
157
GHCi> showBloodType (bloodType jackieSmith)
"O-"

jackieSmithUpdated = jackieSmith { age = 44 }
showName (name jackieSmith)

simple x = x
GHCi> :t simple
simple :: t -> t

GHCi> :t (\x -> x)
(\x -> x) :: r -> r

GHCi> :t (+)
(+) :: Num a => a -> a -> a

aList = ["ÐºÐ¾Ñ‚","ÑÐ¾Ð±Ð°ÐºÐ°","Ð¼Ñ‹ÑˆÑŒ"]
GHCi> :t aList
aList :: [[Char]]

GHCi> :info Num
class Num a where
    (+) :: a -> a -> a
    (-) :: a -> a -> a
    (*) :: a -> a -> a
    negate :: a -> a
    abs :: a -> a
    signum :: a -> a

myAdd :: a -> a -> a
addThenDouble :: Num a => a -> a -> a
addThenDouble x y = (x + y)*2

class TypeName a where
   fun1 :: a -> a
   fun2 :: a -> String
   fun3 :: a -> a -> Bool

GHCi> describe True
"Ð—Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Ñ‚Ð¸Ð¿Ð° Bool, True - ÑÑ‚Ð¾ Ð¾Ð±Ñ€Ð°Ñ‚Ð½Ð¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Ðº False"
GHCi> describe False
"Ð—Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Ñ‚Ð¸Ð¿Ð° Bool, False - ÑÑ‚Ð¾ Ð¾Ð±Ñ€Ð°Ñ‚Ð½Ð¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Ðº True"

class Describable a where
      describe :: a -> String

GHCi> :t (>)
(>) :: Ord a => a -> a -> Bool

class Eq a => Ord a where
  compare :: a -> a -> Ordering
  (<) :: a -> a -> Bool
  (<=) :: a -> a -> Bool
  (>) :: a -> a -> Bool
  (>=) :: a -> a -> Bool
  max :: a -> a -> a
  min :: a -> a -> a

class Eq a where
  (==) :: a -> a -> Bool
  (/=) :: a -> a -> Bool

GHCi> :info Int
data Int = GHC.Types.I# GHC.Prim.Int# -- Defined in â€™GHC.Typesâ€™
instance Bounded Int -- Defined in â€™GHC.Enumâ€™
instance Enum Int -- Defined in â€™GHC.Enumâ€™
instance Eq Int -- Defined in â€™GHC.Classesâ€™
instance Integral Int -- Defined in â€™GHC.Realâ€™
instance Num Int -- Defined in â€™GHC.Numâ€™
instance Ord Int -- Defined in â€™GHC.Classesâ€™
instance Read Int -- Defined in â€™GHC.Readâ€™
instance Real Int -- Defined in â€™GHC.Realâ€™
instance Show Int -- Defined in â€™GHC.Showâ€™

class Bounded a where
   minBound :: a
   maxBound :: a

GHCi> minBound :: Int
-9223372036854775808
GHCi> maxBound :: Int
9223372036854775807
GHCi> minBound :: Char
â€™\NULâ€™
GHCi> maxBound :: Char
â€™\1114111â€™

class Show a where
  show :: a -> String

data Icecream = Chocolate | Vanilla

GHCi> True
True
GHCi> False
False

GHCi> Chocolate
<interactive>:404
:1:
No instance for (Show Icecream) arising from a use of â€˜printâ€™
In a stmt of an interactive GHCi command: print it

data Icecream = Chocolate | Vanilla deriving (Show)

GHCi> Chocolate
Chocolate
GHCi> Vanilla
Vanilla

data Icecream = Chocolate | Vanilla deriving (Show, Eq)

GHCi> Vanilla == Vanilla
True
GHCi> Chocolate == Vanilla
False
GHCi> Chocolate /= Vanilla
True

inc :: Int -> Int
inc x = x + 1

data NewEngland = ME | VT | NH | MA | RI | CT

data SixSidedDie = S1 | S2 | S3 | S4 | S5 | S6
data SixSidedDie = S1 | S2 | S3 | S4 | S5 | S6 deriving (Show)
GHCi> S1
S1
GHCi> S2
S2
GHCi> S3
S3

instance Show SixSidedDie where
   show S1 = "Ð¾Ð´Ð¸Ð½"
   show S2 = "Ð´Ð²Ð°"
   show S3 = "Ñ‚Ñ€Ð¸"
   show S4 = "Ñ‡ÐµÑ‚Ñ‹Ñ€Ðµ"
   show S5 = "Ð¿ÑÑ‚ÑŒ"
   show S6 = "ÑˆÐµÑÑ‚ÑŒ"

GHCi> S1
Ð¾Ð´Ð¸Ð½
GHCi> S2
Ð´Ð²Ð°
GHCi> S6
ÑˆÐµÑÑ‚ÑŒ

data SixSidedDie = S1 | S2 | S3 | S4 | S5 | S6

instance Show SixSidedDie where
  show S1 = "I"
  show S2 = "II"
  show S3 = "III"
  show S4 = "IV"
  show S5 = "V"
  show S6 = "VI"

show :: SixSidedDie -> String
show S1 = "Ð¾Ð´Ð¸Ð½"
show S2 = "Ð´Ð²Ð°"
show S3 = "Ñ‚Ñ€Ð¸"
show S4 = "Ñ‡ÐµÑ‚Ñ‹Ñ€Ðµ"
show S5 = "Ð¿ÑÑ‚ÑŒ"
show S6 = "ÑˆÐµÑÑ‚ÑŒ"

"Ambiguous occurrence â€™showâ€™"

data TwoSidedDie = One | Two

show :: TwoSidedDie -> String
show One = "Ð¾Ð´Ð¸Ð½"
show Two = "Ð´Ð²Ð°"

Multiple declarations of â€™showâ€™

read "10" :: Int 10
read "10" :: Double 10.0

class Eq a where
  (==) :: a -> a -> Bool
  (/=) :: a -> a -> Bool

instance Eq SixSidedDie where
   (==) S6 S6 = True
   (==) S5 S5 = True
   (==) S4 S4 = True
   (==) S3 S3 = True
   (==) S2 S2 = True
   (==) S1 S1 = True
   (==) _ _ = False

GHCi> S6 == S6
True
GHCi> S6 == S5
False
GHCi> S5 == S6
False
GHCi> S5 /= S6
True
GHCi> S6 /= S6
False

class Eq a => Ord a where
   compare :: a -> a -> Ordering
   (<) :: a -> a -> Bool
   (<=) :: a -> a -> Bool
   (>) :: a -> a -> Bool
   (>=) :: a -> a -> Bool
   max :: a -> a -> a
   min :: a -> a -> a

data Ordering = LT | EQ | GT

instance Ord SixSidedDie where
   compare S6 S6 = EQ
   compare S6 _ = GT
   compare _ S6 = LT
   compare S5 S5 = EQ
   compare S5 _ = GT
   compare _ S5 = LT

data Test1 = AA | ZZ deriving (Eq, Ord)
data Test2 = ZZZ | AAA deriving (Eq, Ord)

GHCi> AA < ZZ
True
GHCi> AA > ZZ
False
GHCi> AAA > ZZZ
True
GHCi> AAA < ZZZ
False

data SixSidedDie = S1 | S2 | S3 | S4 | S5 | S6
   deriving (Show,Eq,Ord)

class Enum a where
  succ :: a -> a
  pred :: a -> a
  toEnum :: Int -> a
  fromEnum :: a -> Int
  enumFrom :: a -> [a]
  enumFromThen :: a -> a -> [a]
  enumFromTo :: a -> a -> [a]
  enumFromThenTo :: a -> a -> a -> [a]

instance Enum SixSidedDie where
  toEnum 0 = S1
  toEnum 1 = S2
  toEnum 2 = S3
  toEnum 3 = S4
  toEnum 4 = S5
  toEnum 5 = S6
  toEnum _ = error "Ð¢Ð°ÐºÐ¾Ð³Ð¾ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ Ð½ÐµÑ‚"

  fromEnum S1 = 0
  fromEnum S2 = 1
  fromEnum S3 = 2
  fromEnum S4 = 3
  fromEnum S5 = 4
  fromEnum S6 = 5

GHCi> [S1 .. S6]
[Ã®Ã¤Ã¨Ã­,Ã¤Ã¢Ã ,Ã²Ã°Ã¨,Ã·Ã¥Ã²Ã»Ã°Ã¥,Ã¯Ã¿Ã²Ã¼,Ã¸Ã¥Ã±Ã²Ã¼]

GHCi> [S2,S4 .. S6]
[Ã¤Ã¢Ã ,Ã·Ã¥Ã²Ã»Ã°Ã¥,Ã¸Ã¥Ã±Ã²Ã¼]
GHCi> [S4 .. S6]
[Ã·Ã¥Ã²Ã»Ã°Ã¥,Ã¯Ã¿Ã²Ã¼,Ã¸Ã¥Ã±Ã²Ã¼]

GHCi> [S1..]
[Ã®Ã¤Ã¨Ã­,Ã¤Ã¢Ã ,Ã²Ã°Ã¨,Ã·Ã¥Ã²Ã»Ã°Ã¥,Ã¯Ã¿Ã²Ã¼,Ã¸Ã¥Ã±Ã²Ã¼***
                Exception: Ã’Ã ÃªÃ®Ã£Ã® Ã§Ã­Ã Ã·Ã¥Ã­Ã¨Ã¿ Ã­Ã¥Ã²

data SixSidedDie = S1 | S2 | S3 | S4 | S5 | S6 deriving (Enum)
GHCi> [S1..]
[Ã®Ã¤Ã¨Ã­,Ã¤Ã¢Ã ,Ã²Ã°Ã¨,Ã·Ã¥Ã²Ã»Ã°Ã¥,Ã¯Ã¿Ã²Ã¼,Ã¸Ã¥Ã±Ã²Ã¼]


type Name = (String,String)
names :: [Name]
names = [("Ð˜ÑÐ½","ÐšÐµÑ€Ñ‚Ð¸Ñ"),
         ("Ð‘ÐµÑ€Ð½Ð°Ñ€Ð´","Ð¡Ð°Ð¼Ð½ÐµÑ€"),
         ("ÐŸÐ¸Ñ‚ÐµÑ€","Ð¥ÑƒÐº"),
         ("Ð¡Ñ‚Ð¸Ð²ÐµÐ½","ÐœÐ¾Ñ€Ñ€Ð¸Ñ")]

GHCi> import Data.List
GHCi> sort names
[("Ð‘ÐµÑ€Ð½Ð°Ñ€Ð´","Ð¡Ð°Ð¼Ð½ÐµÑ€"),("Ð˜ÑÐ½","ÐšÐµÑ€Ñ‚Ð¸Ñ"),("ÐŸÐ¸Ñ‚ÐµÑ€","Ð¥ÑƒÐº"),
 ("Ð¡Ñ‚Ð¸Ð²ÐµÐ½","ÐœÐ¾Ñ€Ñ€Ð¸Ñ")]

instance Ord Name where
   compare (f1,l1) (f2,l2) = compare (l1,f1) (l2,f2)

data Name = Name (String, String) deriving (Show, Eq)

instance Ord Name where
   compare (Name (f1,l1)) (Name (f2,l2)) =
                                         compare (l1,f1) (l2,f2)

names :: [Name]
names = [("Ð˜ÑÐ½","ÐšÐµÑ€Ñ‚Ð¸Ñ"),
         ("Ð‘ÐµÑ€Ð½Ð°Ñ€Ð´","Ð¡Ð°Ð¼Ð½ÐµÑ€"),
         ("ÐŸÐ¸Ñ‚ÐµÑ€","Ð¥ÑƒÐº"),
         ("Ð¡Ñ‚Ð¸Ð²ÐµÐ½","ÐœÐ¾Ñ€Ñ€Ð¸Ñ")]

GHCi> import Data.List
GHCi> sort names
[Name ("Ð˜ÑÐ½","ÐšÐµÑ€Ñ‚Ð¸Ñ"), Name ("Ð¡Ñ‚Ð¸Ð²ÐµÐ½","ÐœÐ¾Ñ€Ñ€Ð¸Ñ"),
 Name ("Ð‘ÐµÑ€Ð½Ð°Ñ€Ð´","Ð¡Ð°Ð¼Ð½ÐµÑ€"), Name ("ÐŸÐ¸Ñ‚ÐµÑ€","Ð¥ÑƒÐº")]

newtype Name = Name (String, String) deriving (Show, Eq)

data FourLetterAlphabet = L1 | L2 | L3 | L4
   deriving (Show,Enum,Bounded)

rotN :: (Bounded a, Enum a) => Int -> a -> a
rotN alphabetSize c = toEnum rotation
  where halfAlphabet = n â€˜divâ€˜ 2
      offset = fromEnum c + halfAlphabet
      rotation = offset â€˜modâ€˜ alphabetSize

GHCi> rotN 4 L1
L3
GHCi> rotN 4 L2
L4
GHCi> rotN 4 L3
L1
GHCi> rotN 4 L4
L2

largestCharNumber :: Int
largestCharNumber = fromEnum (maxBound :: Char)

rotChar :: Char -> Char
rotChar charToEncrypt = rotN sizeOfAlphabet charToEncrypt
   where sizeOfAlphabet = 1 + fromEnum (maxBound :: Char)

message :: [FourLetterAlphabet]
message = [L1,L3,L4,L1,L1,L2]

fourLetterAlphabetEncoder :: [FourLetterAlphabet] ->
                             [FourLetterAlphabet]

fourLetterEncoder vals = map rot4l vals
   where
       alphaSize = 1 + fromEnum (maxBound :: FourLetterAlphabet)
       rot4l = rotN alphaSize

GHCi> fourLetterEncoder message
[L3,L1,L2,L3,L3,L4]

data ThreeLetterAlphabet = Alpha
                           | Beta
                           | Kappa deriving (Show,Enum,Bounded)

threeLetterMessage :: [ThreeLetterAlphabet]
threeLetterMessage =  [Alpha,Alpha,Beta,Alpha,Kappa]

threeLetterEncoder :: [ThreeLetterAlphabet] ->
                      [ThreeLetterAlphabet]
threeLetterEncoder vals = map rot3l vals
   where
     alphaSize = 1 + fromEnum (maxBound :: ThreeLetterAlphabet)
     rot3l = rotN alphaSize

GHCi> fourLetterEncoder fourLetterMessage
[L3,L1,L2,L3,L3,L4]
GHCi> fourLetterEncoder (fourLetterEncoder fourLetterMessage)
[L1,L3,L4,L1,L1,L2]
GHCi> threeLetterMessage

[Alpha,Alpha,Beta,Alpha,Kappa]
GHCi> threeLetterEncoder threeLetterMessage
[Beta,Beta,Kappa,Beta,Alpha]
GHCi> threeLetterEncoder (threeLetterEncoder
                                         threeLetterMessage)
[Kappa,Kappa,Alpha,Kappa,Beta]

rotNdecoder :: (Bounded a, Enum a) => Int -> a -> a
rotNdecoder n c = toEnum rotation
   where halfN = n â€˜divâ€˜ 2
         offset = if even n
                  then fromEnum c + halfN
                  else 1 + fromEnum c + halfN
         rotation = offset â€˜modâ€˜ n

threeLetterDecoder :: [ThreeLetterAlphabet] ->
                      [ThreeLetterAlphabet]
threeLetterDecoder vals = map rot3ldecoder vals
   where
      alphaSize = 1 + fromEnum (maxBound :: ThreeLetterAlphabet)
      rot3ldecoder = rotNdecoder alphaSize

GHCi> threeLetterMessage
[Alpha,Alpha,Beta,Alpha,Kappa]
GHCi> threeLetterEncoder threeLetterMessage
[Beta,Beta,Kappa,Beta,Alpha]
GHCi> threeLetterDecoder (threeLetterEncoder
Ã‡ threeLetterMessage)
[Alpha,Alpha,Beta,Alpha,Kappa]


rotEncoder :: String -> String
rotEncoder text = map rotChar text
   where alphaSize = 1 + fromEnum (maxBound :: Char)
         rotChar = rotN alphaSize

rotDecoder :: String -> String
rotDecoder text = map rotCharDecoder text
   where alphaSize = 1 + fromEnum (maxBound :: Char)
         rotCharDecoder = rotNdecoder alphaSize

threeLetterEncoder :: [ThreeLetterAlphabet] ->
                      [ThreeLetterAlphabet]
threeLetterEncoder vals = map rot3l vals
   where
      alphaSize = 1 + fromEnum (maxBound :: ThreeLetterAlphabet)
      rot3l = rotN alphaSize

threeLetterDecoder :: [ThreeLetterAlphabet] ->
                      [ThreeLetterAlphabet]
threeLetterDecoder vals = map rot3ldecoder vals
   where
      alphaSize = 1 + fromEnum (maxBound :: ThreeLetterAlphabet)
      rot3ldecoder = rotNdecoder alphaSize

fourLetterAlphabetEncoder :: [FourLetterAlphabet] ->
                             [FourLetterAlphabet]
fourLetterEncoder vals = map rot4l vals
    where
       alphaSize = 1 + fromEnum (maxBound :: FourLetterAlphabet)
       rot4l = rotN alphaSize

fourLetterDecoder :: [FourLetterAlphabet] ->
                     [FourLetterAlphabet]
fourLetterDecoder vals = map rot4ldecoder vals
    where
       alphaSize = 1 + fromEnum (maxBound :: ThreeLetterAlphabet)
       rot4ldecoder = rotNdecoder alphaSize

GHCi> rotEncoder "hi"
"\557160\557161"
GHCi> rotDecoder(rotEncoder "hi")
"hi"
GHCi> rotEncoder "Jean-Paul likes Simone"

"\557130\557157\557153\55....
GHCi> rotDecoder (rotEncoder "Jean-Paul likes Simone")
"Jean-Paul likes Simone"

xorBool :: Bool -> Bool -> Bool
xorBool value1 value2 = (value1 || value2) &&
                        (not (value1 && value2))

xorPair :: (Bool,Bool) -> Bool
xorPair (v1,v2) = xorBool v1 v2

xor :: [Bool] -> [Bool] -> [Bool]
xor list1 list2 = map xorPair (zip list1 list2)

type Bits = [Bool]


intToBitsâ€™ :: Int -> Bits
intToBitsâ€™ 0 = [False]
intToBitsâ€™ 1 = [True]
intToBitsâ€™ n = if (remainder == 0)
               then False : intToBitsâ€™ nextVal
               else True : intToBitsâ€™ nextVal
where remainder = n â€˜modâ€˜ 2
      nextVal = n â€˜divâ€˜ 2

GHCi> intToBitsâ€™ 2
[False,True]
GHCi> intToBitsâ€™ 8
[False,False,False,True]

maxBits :: Int
maxBits = length (intToBitsâ€™ maxBound)

intToBits :: Int -> Bits
intToBits n = leadingFalses ++ reversedBits
   where reversedBits = reverse (intToBitsâ€™ n)
         missingBits = maxBits - (length reversedBits)
         leadingFalses = take missingBits (cycle [False])

charToBits :: Char -> Bits
charToBits char = intToBits (fromEnum char)

bitsToInt :: Bits -> Int
bitsToInt bits = sum (map (\x -> 2^(snd x)) trueLocations)
    where size = length bits
          indices = [size-1,size-2 .. 0]
          trueLocations = filter (\x -> fst x == True)
                          (zip bits indices)

GHCi> bitsToInt (intToBits 32)
32
GHCi> bitsToInt (intToBits maxBound)
9223372036854775807

bitsToChar :: Bits -> Char
bitsToChar bits = toEnum (bitsToInt bits)

GHCi> bitsToChar (charToBits â€™aâ€™)
â€™aâ€™
GHCi> bitsToChar (charToBits maxBound)
â€™\1114111â€™
GHCi> bitsToChar (charToBits minBound)
â€™\NULâ€™

myPad :: String
myPad = "Shhhhhh"

myPlainText :: String
myPlainText = "Haskell"

applyOTPâ€™ :: String -> String -> [Bits]
applyOTPâ€™ pad plaintext = map (\pair ->
                                (fst pair) â€˜xorâ€˜ (snd pair))
                          (zip padBits plaintextBits)
where padBits = map charToBits pad
      plaintextBits = map charToBits plaintext

applyOTP :: String -> String -> String
applyOTP pad plaintext = map bitsToChar bitList
    where bitList = applyOTPâ€™ pad plaintext

GHCi> applyOTP myPad myPlainText
"\ESC\t\ESC\ETX\r\EOT\EOT"

encoderDecoder :: String -> String
encoderDecoder = applyOTP myPad

GHCi> encoderDecoder "book"
"1\a\a\ETX"
GHCi> encoderDecoder "1\a\a\ETX"
"book"

class Cipher a where
   encode :: a -> String -> String
   decode :: a -> String -> String

data Rot = Rot

instance Cipher Rot where
   encode Rot text = rotEncoder text
   decode Rot text = rotDecoder text

GHCi> encode Rot "Haskell"
"\557128\557153\557171\557163\557157\557164\557164"
GHCi> decode Rot "\557128\557153\557171\557163\557157\557164
Ã‡ \557164"
"Haskell"

data OneTimePad = OTP String
instance Cipher OneTimePad where
    encode (OTP pad) text = applyOTP pad text
    decode (OTP pad) text = applyOTP pad text

myOTP :: OneTimePad
myOTP = OTP (cycle [minBound .. maxBound])

GHCi> encode myOTP "Learn Haskell"
"Ldcqj\%Nf{bogâ€˜"
GHCi> decode myOTP "Ldcqj\%Nf{bogâ€˜"
"Learn Haskell"
GHCi> encode myOTP "this is a longer sentence, I hope it encodes"
"tikp$luâ€™i)fdbjk}0bw}â€˜pxt}5:R<uqoE\SOHKW\EOT@HDGMOX"
GHCi> decode myOTP "tikp$luâ€™i)fdbjk}0bw}â€˜pxt}5:R<uqoE\SOHKW \EOT@HDGMOX"
"this is a longer sentence, I hope it encodes"

prng :: Int -> Int -> Int -> Int -> Int
prng a b maxNumber seed = (a*seed + b) â€˜modâ€˜ maxNumber

examplePRNG :: Int -> Int
examplePRNG = prng 1337 7 100

GHCi> examplePRNG 12345
72
GHCi> examplePRNG 72
71
GHCi> examplePRNG 71
34
GHCi> examplePRNG 34
65

type Document = String
Document -> [String]
[String] -> (String -> Bool) -> [String]
[String] -> [Integer]
[Integer] -> Integer

Ð¡Ñ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ñ‹ Ð² Ð¡ ÐºÐ°Ðº Ñ‚Ð¸Ð¿Ñ‹-Ð¿Ñ€Ð¾Ð¸Ð·Ð²ÐµÐ´ÐµÐ½Ð¸Ñ
struct author_name {
char *first_name;
char *last_name;
};
struct book {
author_name author;
char *isbn;
char *title;
int year_published;
double price;
}

data AuthorName = AuthorName String String
data Book = Book Author String String Int Double

Ð¡Ð¸Ð½Ñ‚Ð°ÐºÑÐ¸Ñ Ð·Ð°Ð¿Ð¸ÑÐµÐ¹ Ð´Ð»Ñ Ñ€ÐµÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ð¸ Book

data Book = Book {
author :: AuthorName
, isbn :: String
, title :: String
, year :: Int
, price :: Double}

public class Book { // in Java
Author author;
String isbn;
String title;
int yearPublished;
double price;
}

data AuthorName = AuthorName {
 firstName :: String
 , lastName :: String
}

public class VinylRecord {
String artist;
String title;
int yearPublished;
double price;
}

public class StoreItem {
String title;
int yearPublished;
double price;
}
public class Book extends StoreItem {
Author author;
String isbn;
}

public class VinylRecord extends StoreItem {
String artist;
}

public class CollectibleToy {
String name;
String description;
double price;
}

data SportsCar = SportsCar Car Spoiler

Ð¢Ð¸Ð¿Ñ‹-ÑÑƒÐ¼Ð¼Ñ‹ - Ð¾Ð±ÑŒÑÐ²Ð»ÐµÐ½Ð¸Ðµ Ñ‚Ð¸Ð¿Ð¾Ð² Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ Ð˜Ð›Ð˜

type FirstName = String
type LastName = String
type MiddleName = String

data Name = Name FirstName LastName
            | NameWithMiddle FirstName MiddleName LastName

data Creator = AuthorCreator Author | ArtistCreator Artist

data Author = Author Name

data Artist = Person Name | Band String

data Name = Name FirstName LastName
            | NameWithMiddle FirstName MiddleName LastName
            | TwoInitialsWithLast Char Char LastName

hpLovecraft :: Creator
hpLovecraft = AuthorCreator
               (Author
                (TwoInitialsWithLast â€™Hâ€™ â€™Pâ€™ "Lovecraft"))

data Name = Name FirstName LastName
            | NameWithMiddle FirstName MiddleName LastName
            | TwoInitialsWithLast Char Char LastName
            | FirstNameWithInit FirstName Char

public class Name {
   String firstName;
   String lastName;
   String middleName;
   char firstInitial;
   char middleInitial;
   char lastInitial;
}

Ð¡Ð¾Ð±Ð¸Ñ€Ð°ÐµÐ¼ ÐºÐ½Ð¸Ð¶Ð½Ñ‹Ð¹ Ð¼Ð°Ð³Ð°Ð·Ð¸Ð½
data Book = Book {
    author :: Creator
    , isbn :: String
    , bookTitle :: String
    , bookYear :: Int
    , bookPrice :: Double
}

data VinylRecord = VinylRecord {
    artist :: Creator
    , recordTitle :: String
    , recordYear :: Int
    , recordPrice :: Double
}

data Book = Book Creator String String Int Double
price :: Book -> Double
price (Book _ _ _ _ val) = val

data StoreItem = BookItem Book | RecordItem VinylRecord

data CollectibleToy = CollectibleToy {
   name :: String
   , description :: String
   , toyPrice :: Double
}

data StoreItem = BookItem Book
                 | RecordItem VinylRecord
                 | ToyItem CollectibleToy

price :: StoreItem -> Double
price (BookItem book) = bookPrice book
price (RecordItem record) = recordPrice record
price (ToyItem toy) = toyPrice toy

madeBy :: StoreItem -> String
madeBy (BookItem book) = show (author book)
madeBy (RecordItem record) = show (artist record)
madeBy _ = "unknown"

import Data.List (for sort)
myLast :: [a] -> a
myLast = head . reverse
myMin :: Ord a => [a] -> a
myMin = head . sort
myMax :: Ord a => [a] -> a
myMax = myLast . sort
myAll :: (a -> Bool) -> [a] -> Bool
myAll testFunc = (foldr (&) True) . (map testFunc)

instance Semigroup Integer where
(<>) x y = x + y
(<>) :: Semigroup a => a -> a -> a

myAny :: (a -> Bool) -> [a] -> Bool
myAny testFunc = (foldr (||) False) . (map testFunc)

GHCi> myAny even [1, 2, 3]
True

data Color = Red | Yellow | Blue | Green | Purple
             | Orange | Brown deriving (Show, Eq)

instance Semigroup Color where
   (<>) Red Blue = Purple
   (<>) Blue Red = Purple
   (<>) Yellow Blue = Green
   (<>) Blue Yellow = Green
   (<>) Yellow Red = Orange
   (<>) Red Yellow = Orange
   (<>) a b = if a == b
        then a
        else Brown

GHCi> Red <> Yellow
Orange
GHCi> Red <> Blue
Purple
GHCi> Green <> Purple
Brown

GHCi> (Green <> Blue) <> Yellow
Brown
GHCi> Green <> (Blue <> Yellow)
Green

ÐžÑ…Ñ€Ð°Ð½Ð½Ñ‹Ðµ Ð²Ñ‹Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ
howMuch :: Int -> String
howMuch n | n > 10 = "Ñ†ÐµÐ»Ð°Ñ ÐºÑƒÑ‡Ð°"
          | n > 0 = "Ð½ÐµÐ¼Ð½Ð¾Ð³Ð¾"
          | otherwise = "Ð¼Ñ‹ Ð² Ð´Ð¾Ð»Ð³Ð°Ñ…!"

instance Semigroup Color where
   (<>) Red Blue = Purple
   (<>) Blue Red = Purple
   (<>) Yellow Blue = Green
   (<>) Blue Yellow = Green
   (<>) Yellow Red = Orange
   (<>) Red Yellow = Orange
   (<>) a b
        | a == b = a
        | all (â€˜elemâ€˜ [Red, Blue, Purple]) [a, b] = Purple
        | all (â€˜elemâ€˜ [Blue, Yellow, Green]) [a, b] = Green
        | all (â€˜elemâ€˜ [Red, Yellow, Orange]) [a, b] = Orange
        | otherwise = Brown

GHCi> (Green <> Blue) <> Yellow
Green
GHCi> Green <> (Blue <> Yellow)
Green

class Semigroup a => Monoid a where
   identity :: a

Monoid Semigroup + identity

class Monoid a where
      mempty :: a
      mappend :: a -> a -> a
      mconcat :: [a] -> [a]

GHCi> [1, 2, 3] ++ []
[1, 2, 3]
GHCi> [1, 2, 3] <> []
[1, 2, 3]
GHCi> [1, 2, 3] â€˜mappendâ€˜ []
[1, 2, 3]

mappend l/<> Integer
mempty?
1, Ð¿Ð¾Ñ‚Ð¾Ð¼Ñƒ Ñ‡Ñ‚Ð¾ ð‘¥ Â‡ 1 = ð‘¥.
mconcat :: Monoid a => [a] -> [a]

GHCi> mconcat ["Ð²", " ÑÑ‚Ð¾Ð¼", " ÐµÑÑ‚ÑŒ", " ÑÐ¼Ñ‹ÑÐ»?"]
"Ð² ÑÑ‚Ð¾Ð¼ ÐµÑÑ‚ÑŒ ÑÐ¼Ñ‹ÑÐ»?"

mconcat = foldr mappend mempty
Ð—Ð°ÐºÐ¾Ð½Ñ‹ Ð¼Ð¾Ð½Ð¾Ð¸Ð´Ð¾Ð²
mappend mempty x = x
[] ++ [1, 2, 3] = [1, 2, 3];
mappend x mempty = x
[1, 2, 3] ++ [] = [1, 2, 3];
mappend x (mappend y z) = mappend (mappend x y) z
[1] ++ ([2] ++ [3]) = ([1] ++ [2]) ++ [3]
mconcat = foldr mappend mempty

type Events = [String]
type Probs = [Double]
data PTable = PTable Events Probs

Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ ÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ð¾Ð¹ Ñ‚Ð°Ð±Ð»Ð¸Ñ†Ñ‹ Ð²ÐµÑ€Ð¾ÑÑ‚Ð½Ð¾ÑÑ‚ÐµÐ¹
createPTable :: Events -> Probs -> PTable
createPTable events probs = PTable events normalizedProbs
    where totalProbs = sum probs
          normalizedProbs = map (\x -> x/totalProbs) probs

showPair :: String -> Double -> String
showPair event prob = mconcat [event, "|", show prob, "\n"]

GHCi> zipWith (+) [1, 2, 3] [4, 5, 6]
[5, 7, 9]

instance Show PTable where
  show (PTable events probs) = mconcat pairs
    where pairs = zipWith showPair events probs

GHCi> createPTable ["Ã®Ã°Â¼Ã«", "Ã°Ã¥Ã¸ÃªÃ "] [0.5, 0.5]
Ð¾Ñ€Ñ‘Ð»|0.5
Ñ€ÐµÑˆÐºÐ°|0.5

Ð¾Ñ€Ñ‘Ð»-Ð¾Ñ€Ñ‘Ð»|0.25
Ð¾Ñ€Ñ‘Ð»-Ñ€ÐµÑˆÐºÐ°|0.25
Ñ€ÐµÑˆÐºÐ°-Ð¾Ñ€Ñ‘Ð»|0.25
Ñ€ÐµÑˆÐºÐ°-Ñ€ÐµÑˆÐºÐ°|0.25

cartCombine :: (a -> b -> c) -> [a] -> [b] -> [c]
cartCombine func l1 l2 = zipWith func newL1 cycledL2
  where
    nToAdd = length l2
    repeatedL1 = map (take nToAdd . repeat) l1
    newL1 = mconcat repeatedL1
    cycledL2 = cycle l2

combineEvents :: Events -> Events -> Events
combineEvents e1 e2 = cartCombine combiner e1 e2
  where
   combiner = (\x y -> mconcat [x, "-", y])

combineProbs :: Probs -> Probs -> Probs
combineProbs p1 p2 = cartCombine (*) p1 p2

instance Semigroup PTable where
  (<>) ptable1 (PTable [] []) = ptable1
  (<>) (PTable [] []) ptable2 = ptable2
  (<>) (PTable e1 p1) (PTable e2 p2) =
                       createPTable newEvents newProbs
  where newEvents = combineEvents e1 e2
        newProbs = combineProbs p1 p2

instance Monoid PTable where
  mempty = PTable [] []
  mappend = (<>)

coin :: PTable
coin = createPTable ["Ð¾Ñ€Ñ‘Ð»", "Ñ€ÐµÑˆÐºÐ°"] [0.5, 0.5]

spinner :: PTable
spinner = createPTable ["ÐºÑ€Ð°ÑÐ½Ñ‹Ð¹", "ÑÐ¸Ð½Ð¸Ð¹", "Ð·Ñ‘Ð»Ñ‘Ð½Ñ‹Ð¹"]
                       [0.1, 0.2, 0.7]

GHCi> coin <> spinner
Ð¾Ñ€Ñ‘Ð»-ÐºÑ€Ð°ÑÐ½Ñ‹Ð¹|5.0e-2
Ð¾Ñ€Ñ‘Ð»-ÑÐ¸Ð½Ð¸Ð¹|0.1
Ð¾Ñ€Ñ‘Ð»-Ð·Ñ‘Ð»Ñ‘Ð½Ñ‹Ð¹|0.35
Ñ€ÐµÑˆÐºÐ°-ÐºÑ€Ð°ÑÐ½Ñ‹Ð¹|5.0e-2
Ñ€ÐµÑˆÐºÐ°-ÑÐ¸Ð½Ð¸Ð¹|0.1
Ñ€ÐµÑˆÐºÐ°-Ð·Ñ‘Ð»Ñ‘Ð½Ñ‹Ð¹|0.35

GHCi> mconcat [coin, coin, coin]
Ð¾Ñ€Ñ‘Ð»-Ð¾Ñ€Ñ‘Ð»-Ð¾Ñ€Ñ‘Ð»|0.125
Ð¾Ñ€Ñ‘Ð»-Ð¾Ñ€Ñ‘Ð»-Ñ€ÐµÑˆÐºÐ°|0.125
Ð¾Ñ€Ñ‘Ð»-Ñ€ÐµÑˆÐºÐ°-Ð¾Ñ€Ñ‘Ð»|0.125
Ð¾Ñ€Ñ‘Ð»-Ñ€ÐµÑˆÐºÐ°-Ñ€ÐµÑˆÐºÐ°|0.125
Ñ€ÐµÑˆÐºÐ°-Ð¾Ñ€Ñ‘Ð»-Ð¾Ñ€Ñ‘Ð»|0.125
Ñ€ÐµÑˆÐºÐ°-Ð¾Ñ€Ñ‘Ð»-Ñ€ÐµÑˆÐºÐ°|0.125
Ñ€ÐµÑˆÐºÐ°-Ñ€ÐµÑˆÐºÐ°-Ð¾Ñ€Ñ‘Ð»|0.125
Ñ€ÐµÑˆÐºÐ°-Ñ€ÐµÑˆÐºÐ°-Ñ€ÐµÑˆÐºÐ°|0.125

Ð¢Ð¸Ð¿Ñ‹, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ðµ Ð¿Ñ€Ð¸Ð½Ð¸Ð¼Ð°ÑŽÑ‚ Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹
data Box a = Box a deriving Show

GHCi> n = 6 :: Int
GHCi> :t Box n
Box n :: Box Int
GHCi> word = "ÑÑ‚Ñ€Ð¾ÐºÐ°"
GHCi> :t Box word
Box word :: Box [Char]
GHCi> f x = x
GHCi> :t Box f
Box f :: Box (t -> t)
GHCi> otherBox = Box n
GHCi> :t Box otherBox
Box otherBox :: Box (Box Int)

ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ñ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹ wrap Ð¸ unwrap
wrap :: a -> Box a
wrap x = Box x

unwrap :: Box a -> a
unwrap (Box x) = x

wrap (Box â€™aâ€™)?
Box (Box Char)

data Triple a = Triple a a a deriving Show
type Point3D = Triple Double
aPoint :: Point3D
aPoint = Triple 0.1 53.2 12.3

type FullName = Triple String
aPerson :: FullName
aPerson = Triple "Ð“Ð¾Ð²Ð°Ñ€Ð´" "Ð¤Ð¸Ð»Ð»Ð¸Ð¿Ñ" "Ð›Ð°Ð²ÐºÑ€Ð°Ñ„Ñ‚"

type Initials = Triple Char
initials :: Initials
initials = Triple â€™Hâ€™ â€™Pâ€™ â€™Lâ€™

first :: Triple a -> a
first (Triple x _ _) = x

second :: Triple a -> a
second (Triple _ x _ ) = x

third :: Triple a -> a
third (Triple _ _ x) = x

toList :: Triple a -> [a]
toList (Triple x y z) = [x,y,z]

transform :: (a -> a) -> Triple a -> Triple a
transform f (Triple x y z) = Triple (f x) (f y) (f z)

GHCi> transform (* 3) aPoint
Triple 0.3 159.6 36.9

GHCi> transform reverse aPerson
Triple "Ð´Ñ€Ð°Ð²Ð¾Ð“" "ÑÐ¿Ð¸Ð»Ð»Ð¸Ð¤" "Ñ‚Ñ„Ð°Ñ€ÐºÐ²Ð°Ð›"

GHCi> transform toLower initials
Triple â€™hâ€™ â€™pâ€™ â€™lâ€™

GHCi> toList (transform toLower initials)
"hpl"

data [] a = [] | a:[a]
data List a = Empty | Cons a (List a) deriving Show
CÐ¿Ð¸ÑÐ¾Ðº Ñ‚Ð¸Ð¿Ð° a Ð»Ð¸Ð±Ð¾ Ð¿ÑƒÑÑ‚, Ð»Ð¸Ð±Ð¾ ÐºÐ¾Ð½ÑÑ‚Ñ€ÑƒÐ¸Ñ€ÑƒÐµÑ‚ÑÑ Ð¸Ð· Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ð¹ Ñ‚Ð¸Ð¿Ð° a Ñ Ð´Ñ€ÑƒÐ³Ð¸Ð¼ ÑÐ¿Ð¸ÑÐºÐ¾Ð¼ Ñ‚Ð¸Ð¿Ð° a

builtinEx1 :: [Int]
builtinEx1 = 1:2:3:[]
ourListEx1 :: List Int
ourListEx1 = Cons 1 (Cons 2 (Cons 3 Empty))
builtinEx2 :: [Char]
builtinEx2 = â€™Ðºâ€™:â€™Ð¾â€™:â€™Ñ‚â€™:[]
ourListEx2 :: List Char
ourListEx2 = Cons â€™Ðºâ€™ (Cons â€™Ð¾â€™ (Cons â€™Ñ‚â€™ Empty))

ourMap :: (a -> b) -> List a -> List b
ourMap _ Empty = Empty
ourMap func (Cons a rest) = Cons (func a) (ourMap func rest)
GHCi> ourMap (*2) ourListEx1
Cons 2 (Cons 4 (Cons 6 Empty))

data (,) a b = (,) a b

itemCount1, itemCount2, itemCount3 :: (String,Int)
itemCount1 = ("Ð¡Ñ‚Ñ‘Ñ€ÐºÐ¸",25)
itemCount2 = ("ÐšÐ°Ñ€Ð°Ð½Ð´Ð°ÑˆÐ¸",25)
itemCount3 = ("Ð ÑƒÑ‡ÐºÐ¸",13)

itemInventory :: [(String,Int)]
itemInventory = [itemCount1, itemCount2, itemCount3]

Ð’Ð¸Ð´Ñ‹: Ñ‚Ð¸Ð¿Ñ‹ Ñ‚Ð¸Ð¿Ð¾Ð² (kind)
GHCi> :kind Int
Int :: *
GHCi> :kind Triple
Triple :: * -> *
GHCi> :kind []
[] :: * -> *
GHCi> :kind (,)
(,) :: * -> * -> *
GHCi> :kind Map.Map
Map.Map :: * -> * -> *

GHCi> :kind [Int]
[Int] :: *
GHCi> :kind Triple Char
Triple Char :: *

(,,) :: * -> * -> * -> *

import qualified Data.Map as Map
data Organ = Heart | Brain | Kidney | Spleen
   deriving (Show, Eq)

organs :: [Organ]
organs = [Heart,Heart,Brain,Spleen,Spleen,Kidney]

ids :: [Int]
ids = [2,7,13,14,21,24]

fromList :: Ord k => [(k,a)] -> Map k a

pairs = [(2,Heart),(7,Heart),(13,Brain) ...

organPairs :: [(Int,Organ)]
organPairs = zip ids organs

organCatalog :: Map.Map Int Organ
organCatalog = Map.fromList organPairs

GHCi> Map.lookup 7 organCatalog
Just Heart

Map.lookup :: Ord k => k -> Map.Map k a -> Maybe a

groceries :: Map.Map String Int
groceries = Map.fromList [("ÐœÐ¾Ð»Ð¾ÐºÐ¾", 1), ("ÐšÐ¾Ð½Ñ„ÐµÑ‚Ñ‹", 10),
("Ð¡Ñ‹Ñ€", 2)]

import qualified Data.Map as Map
data Organ = Heart | Brain | Kidney | Spleen deriving (Eq)
instance Show Organ where
show Heart = "Ð¡ÐµÑ€Ð´Ñ†Ðµ"
show Brain = "ÐœÐ¾Ð·Ð³Ð¸"
show Kidney = "ÐŸÐ¾Ñ‡ÐºÐ¸"
show Spleen = "Ð¡ÐµÐ»ÐµÐ·Ñ‘Ð½ÐºÐ°"
organs :: [Organ]
organs = [Heart, Heart, Brain, Spleen, Spleen, Kidney]
ids :: [Int]
ids = [2, 7, 13, 14, 21, 24]
organPairs :: [(Int, Organ)]
organPairs = zip ids organs
organCatalog :: Map.Map Int Organ
organCatalog = Map.fromList organPairs

data Maybe a = Nothing | Just a

GHCi> Map.lookup 13 organCatalog
Just ÐœÐ¾Ð·Ð³Ð¸

Map.lookup 13 organCatalog :: Maybe Organ

GHCi> Map.lookup 6 organCatalog
Nothing

possibleDrawers :: [Int]
possibleDrawers = [1..50]

getDrawerContents :: [Int] -> Map.Map Int Organ -> [Maybe Organ]
                                                   
getDrawerContents ids catalog = map getContents ids
  where getContents = \id -> Map.lookup id catalog

availableOrgans :: [Maybe Organ]
availableOrgans = getDrawerContents possibleDrawers
                                    organCatalog

countOrgan :: Organ -> [Maybe Organ] -> Int
countOrgan organ available = length (filter
                                       (\x -> x == Just organ)
                                       available)

GHCi> countOrgan Brain availableOrgans
1
GHCi> countOrgan Heart availableOrgans
2

GHCi> show availableOrgans [Nothing, Just Ð¡ÐµÑ€Ð´Ñ†Ðµ, Nothing,
Ã‡ Nothing, Nothing, Nothing, Just Ð¡ÐµÑ€Ð´Ñ†Ðµ, Nothing, Nothing, ...

isSomething :: Maybe Organ -> Bool
isSomething Nothing = False
isSomething (Just _) = True

justTheOrgans :: [Maybe Organ]
justTheOrgans = filter isSomething availableOrgans

GHCi> justTheOrgans
[Just Ð¡ÐµÑ€Ð´Ñ†Ðµ,Just Ð¡ÐµÑ€Ð´Ñ†Ðµ,Just ÐœÐ¾Ð·Ð³Ð¸,Just Ð¡ÐµÐ»ÐµÐ·Ñ‘Ð½ÐºÐ°,
 Just Ð¡ÐµÐ»ÐµÐ·Ñ‘Ð½ÐºÐ°,Just ÐŸÐ¾Ñ‡ÐºÐ°]

Data.Maybe
justTheOrgans = filter isJust availableOrgans

showOrgan :: Maybe Organ -> String
showOrgan (Just organ) = show organ
showOrgan Nothing = ""

GHCi> showOrgan (Just Heart)
"Ð¡ÐµÑ€Ð´Ñ†Ðµ"
GHCi> showOrgan Nothing
""

organList :: [String]
organList = map showOrgan justTheOrgans

cleanList :: String
cleanList = intercalate ", " organList
GHCi> cleanList
"Ð¡ÐµÑ€Ð´Ñ†Ðµ, Ð¡ÐµÑ€Ð´Ñ†Ðµ, ÐœÐ¾Ð·Ð³Ð¸, Ð¡ÐµÐ»ÐµÐ·Ñ‘Ð½ÐºÐ°, Ð¡ÐµÐ»ÐµÐ·Ñ‘Ð½ÐºÐ°, ÐŸÐ¾Ñ‡ÐºÐ°"

numOrZero :: Maybe Int -> Int
numOrZero Nothing = 0
numOrZero (Just n) = n

data Container = Vat Organ | Cooler Organ | Bag Organ
instance Show Container where
  show (Vat organ) = show organ ++ " Ð² Ð²Ð°Ð½Ð½Ð¾Ñ‡ÐºÐµ"
  show (Cooler organ) = show organ ++ " Ð² Ñ…Ð¾Ð»Ð¾Ð´Ð¸Ð»ÑŒÐ½Ð¸ÐºÐµ"
  show (Bag organ) = show organ ++ " Ð² ÑÑƒÐ¼ÐºÐµ"

data Location = Lab | Kitchen | Bathroom

instance Show Location where
 show Lab = "Ð»Ð°Ð±Ð¾Ñ€Ð°Ñ‚Ð¾Ñ€Ð¸Ñ"
 show Kitchen = "ÐºÑƒÑ…Ð½Ñ"
 show Bathroom = "Ð´ÑƒÑˆÐµÐ²Ð°Ñ"

organToContainer :: Organ -> Container
organToContainer Brain = Vat Brain
organToContainer Heart = Cooler Heart
organToContainer organ = Bag organ

placeInLocation :: Container -> (Location, Container)
placeInLocation (Vat a) = (Lab, Vat a)
placeInLocation (Cooler a) = (Lab, Cooler a)
placeInLocation (Bag a) = (Kitchen, Bag a)

process :: Organ -> (Location, Container)
process organ = placeInLocation (organToContainer organ)
report :: (Location, Container) -> String
report (location, container) =
   show container ++
   " (Ð¼ÐµÑÑ‚Ð¾: " ++
   show location ++ ")"

GHCi> process Brain
(Ã«Ã Ã¡Ã®Ã°Ã Ã²Ã®Ã°Ã¨Ã¿,ÃŒÃ®Ã§Ã£Ã¨ Ã¢ Ã¢Ã Ã­Ã­Ã®Ã·ÃªÃ¥)
GHCi> process Heart
(Ã«Ã Ã¡Ã®Ã°Ã Ã²Ã®Ã°Ã¨Ã¿,Ã‘Ã¥Ã°Ã¤Ã¶Ã¥ Ã¢ ÃµÃ®Ã«Ã®Ã¤Ã¨Ã«Ã¼Ã­Ã¨ÃªÃ¥)
GHCi> process Spleen
(ÃªÃ³ÃµÃ­Ã¿,Ã‘Ã¥Ã«Ã¥Ã§Â¼Ã­ÃªÃ  Ã¢ Ã±Ã³Ã¬ÃªÃ¥)
GHCi> process Kidney
(ÃªÃ³ÃµÃ­Ã¿,ÃÃ®Ã·ÃªÃ  Ã¢ Ã±Ã³Ã¬ÃªÃ¥)
GHCi> report (process Brain)
"ÃŒÃ®Ã§Ã£Ã¨ Ã¢ Ã¢Ã Ã­Ã­Ã®Ã·ÃªÃ¥ (Ã¬Ã¥Ã±Ã²Ã®: Ã«Ã Ã¡Ã®Ã°Ã Ã²Ã®Ã°Ã¨Ã¿)"
GHCi> report (process Spleen)
"Ã‘Ã¥Ã«Ã¥Ã§Â¼Ã­ÃªÃ  Ã¢ Ã±Ã³Ã¬ÃªÃ¥ (Ã¬Ã¥Ã±Ã²Ã®: ÃªÃ³ÃµÃ­Ã¿)"

processRequest :: Int -> Map.Map Int Organ -> String
processRequest id catalog = report (process organ)
where organ = Map.lookup id catalog

processAndReport :: (Maybe Organ) -> String
processAndReport (Just organ) = report (process organ)
processAndReport Nothing = "Ð¾ÑˆÐ¸Ð±ÐºÐ°, Ð¸Ð´ÐµÐ½Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ‚Ð¾Ñ€ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½"

processRequest :: Int -> Map.Map Int Organ -> String
processRequest id catalog = processAndReport organ
where organ = Map.lookup id catalog

GHCi> processRequest 13 organCatalog
"ÃŒÃ®Ã§Ã£Ã¨ Ã¢ Ã¢Ã Ã­Ã­Ã®Ã·ÃªÃ¥ (Ã¬Ã¥Ã±Ã²Ã®: Ã«Ã Ã¡Ã®Ã°Ã Ã²Ã®Ã°Ã¨Ã¿)"
GHCi> processRequest 12 organCatalog
"Ã®Ã¸Ã¨Ã¡ÃªÃ , Ã¨Ã¤Ã¥Ã­Ã²Ã¨Ã´Ã¨ÃªÃ Ã²Ã®Ã° Ã­Ã¥ Ã­Ã Ã©Ã¤Ã¥Ã­"

report :: Maybe (Location, Container) -> String
report Nothing = "ÐºÐ¾Ð½Ñ‚ÐµÐ¹Ð½ÐµÑ€ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½"
report (Just (location, container)) = show container ++
" (Ð¼ÐµÑÑ‚Ð¾: " ++ show location ++ ")"

import Data.List
import qualified Data.Map as Map
import Data.Semigroup
import Data.Maybe

file1 :: [(Int,Double)]
file1 = [ (1, 200.1), (2, 199.5), (3, 199.4), (4, 198.9)
          , (5, 199.0), (6, 200.2), (9, 200.3), (10, 201.2)
          , (12, 202.9)]

file2 :: [(Int,Double)]
file2 = [ (11, 201.6), (12, 201.5), (13, 201.5), (14, 203.5)
          , (15, 204.9), (16, 207.1), (18, 210.5), (20, 208.8)]

file3 :: [(Int,Double)]
file3 = [ (10, 201.2), (11, 201.6), (12, 201.5), (13, 201.5)
          , (14, 203.5), (17, 210.5), (24, 215.1), (25, 218.7)]

file4 :: [(Int,Double)]
file4 = [ (26, 219.8), (27, 220.5), (28, 223.8), (29, 222.8)
          , (30, 223.8), (31, 221.7), (32, 222.3), (33, 220.8)
          , (34, 219.4), (35, 220.1), (36, 220.6)]

data TS a = TS [Int] [Maybe a]

createTS :: [Int] -> [a] -> TS a
createTS times values = TS completeTimes extendedValues
   where
     completeTimes = [minimum times .. maximum times]
   timeValueMap = Map.fromList (zip times values)
     extendedValues = map (\v -> Map.lookup v timeValueMap)
                        completeTimes

fileToTS :: [(Int,a)] -> TS a
fileToTS tvPairs = createTS times values
   where (times, values) = unzip tvPairs

showTVPair :: Show a => Int -> Maybe a -> String
showTVPair time (Just value) = mconcat [ show time, "|"
                                         , show value, "\n" ]
showTVPair time Nothing = mconcat [show time,"|NA\n"]

instance Show a => Show (TS a) where
    show (TS times values) = mconcat rows
       where rows = zipWith showTVPair times values

GHCi> fileToTS file1
1|200.1
2|199.5
3|199.4
4|198.9
5|199.0
6|200.2
7|NA
8|NA
9|200.3
10|201.2
11|NA
12|202.9

ts1 :: TS Double
ts1 = fileToTS file1
ts2 :: TS Double
ts2 = fileToTS file2
ts3 :: TS Double
ts3 = fileToTS file3
ts4 :: TS Double
ts4 = fileToTS file4

TS a -> TS a -> TS a
(<>) :: Semigroup a => a -> a -> a

insertMaybePair :: Ord k => Map.Map k v -> (k, Maybe v)
                                        -> Map.Map k v
insertMaybePair myMap (_, Nothing) = myMap
insertMaybePair myMap (key, Just value) =
                                Map.insert key value myMap

combineTS :: TS a -> TS a -> TS a
combineTS (TS [] []) ts2 = ts2
combineTS ts1 (TS [] []) = ts1
combineTS (TS t1 v1) (TS t2 v2) =
           TS completeTimes combinedValues
   where
      bothTimes = mconcat [t1,t2]
      completeTimes = [minimum bothTimes .. maximum bothTimes]
      tvMap = foldl insertMaybePair Map.empty (zip t1 v1)
      updatedMap = foldl insertMaybePair tvMap (zip t2 v2)
      combinedValues = map (\v -> Map.lookup v updatedMap)
                           completeTimes

instance Semigroup (TS a) where
   (<>) = combineTS

GHCi> ts1 <> ts2
1|200.1
2|199.5
3|199.4
4|198.9
5|199.0
6|200.2
7|NA
8|NA
9|200.3
10|201.2
11|201.6
12|201.5
13|201.5
14|203.5
15|204.9
16|207.1
17|NA
18|210.5
19|NA
20|208.8

instance Monoid (TS a) where
  mempty = TS [] []
  mappend = (<>)

GHCi> mconcat [ts1, ts2]
1|200.1
2|199.5
3|199.4
4|198.9
5|199.0
6|200.2
7|NA
8|NA
9|200.3
10|201.2
11|201.6
12|201.5
13|201.5
14|203.5
15|204.9
16|207.1
17|NA
18|210.5
19|NA
20|208.8

tsAll :: TS Double
tsAll = mconcat [ts1,ts2,ts3,ts4]

mean :: (Real a) => [a] -> Double
mean xs = total/count
  where total = (realToFrac . sum) xs
        count = (realToFrac . length) xs

meanTS :: (Real a) => TS a -> Maybe Double
meanTS (TS _ []) = Nothing
meanTS (TS times values) =
   if all (== Nothing) values
   then Nothing
   else Just avg
 where justVals = filter isJust values
       cleanVals = map fromJust justVals
       avg = mean cleanVals

GHCi> meanTS tsAll
Just 210.5966666666667

GHCi> makeTSCompare max (3,Just 200) (4,Just 10)
(3,Just 200)

type CompareFunc a = a -> a -> a
type TSCompareFunc a = (Int, Maybe a) -> (Int, Maybe a)
                                      -> (Int, Maybe a)

makeTSCompare :: Eq a => CompareFunc a -> TSCompareFunc a
makeTSCompare func = newFunc
  where
    newFunc (i1, Nothing) (i2, Nothing) = (i1, Nothing)
    newFunc (_, Nothing) (i, val) = (i,val)
    newFunc (i, val) (_, Nothing) = i,val)
    newFunc (i1,Just val1) (i2,Just val2) =
                     if func val1 val2 == val1
                     then (i1, Just val1)
                     else (i2, Just val2)


compareTS :: Eq a => (a -> a -> a) -> TS a
                                   -> Maybe (Int, Maybe a)
compareTS func (TS [] []) = Nothing
compareTS func (TS times values) =
   if all (== Nothing) values
   then Nothing
   else Just best
 where
   pairs = zip times values
   best = foldl (makeTSCompare func) (0, Nothing) pairs

minTS :: Ord a => TS a -> Maybe (Int, Maybe a)
minTS = compareTS min

maxTS :: Ord a => TS a -> Maybe (Int, Maybe a)
maxTS = compareTS max

GHCi> minTS tsAll
Just (4,Just 198.9)
GHCi> maxTS ts1
Just (12,Just 202.9)

diffPair :: Num a => Maybe a -> Maybe a -> Maybe a

diffPair Nothing _ = Nothing
diffPair _ Nothing = Nothing
diffPair (Just x) (Just y) = Just (x - y)

diffTS :: Num a => TS a -> TS a
diffTS (TS [] []) = TS [] []
diffTS (TS times values) = TS times (Nothing:diffValues)
where shiftValues = tail values
diffValues = zipWith diffPair shiftValues values

GHCi> meanTS (diffTS tsAll)
Just 0.6076923076923071

mean :: (Real a) => [a] -> Double
movingAverageTS :: (Real a) => TS a -> Int -> TS Double
meanMaybe :: (Real a) => [Maybe a] -> Maybe Double
meanMaybe vals = if any (== Nothing) vals
                 then Nothing
                 else (Just avg)
   where avg = mean (map fromJust vals)

movingAvg :: (Real a) => [Maybe a] -> Int -> [Maybe Double]
movingAvg [] n = []
movingAvg vals n =
     if length nextVals == n
     then meanMaybe nextVals : movingAvg restVals n
     else []
where nextVals = take n vals
     restVals = tail vals

movingAverageTS :: (Real a) => TS a -> Int -> TS Double
movingAverageTS (TS [] []) n= TS [] []
movingAverageTS (TS times values) n = TS times smoothedValues
    where
      ma = movingAvg values n
      nothings = replicate (n â€˜divâ€˜ 2) Nothing
      smoothedValues = mconcat [nothings,ma,nothings]

public class Example {
public static int mystery1(int val1, int val2) {
int val3 = 3;
return Math.pow(val1 + val2 + val3, 2);
}
public static int mystery2(int val1, int val2) {
int val3 = 3;
System.out.print("Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ñ‡Ð¸ÑÐ»Ð¾:");
try {
Scanner in = new Scanner(System.in);
val3 = in.nextInt();
} catch (IOException e) {
e.printStackTrace();
}
return Math.pow(val1 + val2 + val3,2);
}
}

Ð¤ÑƒÐ½ÐºÑ†Ð¸Ð¸ mystery1 Ð¸ mystery2, Ð¿ÐµÑ€ÐµÐ¿Ð¸ÑÐ°Ð½Ð½Ñ‹Ðµ Ð½Ð° Haskell
mystery1 :: Int -> Int -> Int
mystery1 val1 val2 = (val1 + val2 + val3) ^ 2
  where val3 = 3

mystery2 :: Int -> Int -> IO Int
mystery2 val1 val2 = do
   putStrLn "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ñ‡Ð¸ÑÐ»Ð¾:"
   val3Input <- getLine
   let val3 = read val3Input
   return ((val1 + val2 + val3)^2)

safeValue = (mystery1 2 4) + (mystery1 5 6)

unsafeValue = (mystery2 2 4) + (mystery2 2 4)
"No instance for (Num (IO Int)) arising from a use of â€™+â€™"

helloPerson :: String -> String
helloPerson name = "ÐŸÑ€Ð¸Ð²ÐµÑ‚, " ++ name ++ "!"
main :: IO ()
main = do
  putStrLn "ÐŸÑ€Ð¸Ð²ÐµÑ‚! ÐšÐ°Ðº Ñ‚ÐµÐ±Ñ Ð·Ð¾Ð²ÑƒÑ‚?"
  name <- getLine
  let statement = helloPerson name
  putStrLn statement

GHCi> :kind Maybe
Maybe :: * -> *
GHCi> :kind IO
IO :: * -> *

main :: IO ()

GHCi> :type Just (1, 2)
Just (1, 2) :: (Num t, Num t1) => Maybe (t, t1)

GHCi> :type Just (1)
Just (1) :: Num a => Maybe (a)

GHCi> :type Just ()
Just () :: Maybe ()

getLine :: IO String

import System.Random

minDie :: Int
minDie = 1

maxDie :: Int
maxDie = 6

main :: IO ()
main = do
  dieRoll <- randomRIO (minDie, maxDie)
  putStrLn (show dieRoll)

$ ghc roll.hs
$ ./roll
2


putStrLn :: String -> IO ()

ÐœÐ¾Ð¶ÐµÑ‚ Ð»Ð¸ Ð¿Ð¾ÑÐ»ÐµÐ´Ð½ÐµÐ¹ ÑÑ‚Ñ€Ð¾ÐºÐ¾Ð¹ ÐºÐ¾Ð´Ð° Ð² Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ main
Ð±Ñ‹Ñ‚ÑŒ getLine?

ÐÐµÑ‚, Ð¿Ð¾ÑÐºÐ¾Ð»ÑŒÐºÑƒ main Ð¸Ð¼ÐµÐµÑ‚ Ñ‚Ð¸Ð¿ IO (), Ñ‚Ð¾Ð³Ð´Ð° ÐºÐ°Ðº getLine
Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ IO String.

name <- getLine
let statement = helloPerson name

helloPerson :: String -> String

helloPerson :: String -> String
helloPerson name = "ÐŸÑ€Ð¸Ð²ÐµÑ‚, " ++ name ++ "!"

main :: IO ()
main = do
  putStrLn "ÐŸÑ€Ð¸Ð²ÐµÑ‚! ÐšÐ°Ðº Ñ‚ÐµÐ±Ñ Ð·Ð¾Ð²ÑƒÑ‚?"
  name <- getLine
  let statement = helloPerson name
  putStrLn statement

let statement = helloPerson getLine

$ ghc pizza.hs
$ ./pizza
Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ñ€Ð°Ð·Ð¼ÐµÑ€ Ð¿ÐµÑ€Ð²Ð¾Ð¹ Ð¿Ð¸Ñ†Ñ†Ñ‹
30
Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÑÑ‚Ð¾Ð¸Ð¼Ð¾ÑÑ‚ÑŒ Ð¿ÐµÑ€Ð²Ð¾Ð¹ Ð¿Ð¸Ñ†Ñ†Ñ‹
150
Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ñ€Ð°Ð·Ð¼ÐµÑ€ Ð²Ñ‚Ð¾Ñ€Ð¾Ð¹ Ð¿Ð¸Ñ†Ñ†Ñ‹
50
Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÑÑ‚Ð¾Ð¸Ð¼Ð¾ÑÑ‚ÑŒ Ð²Ñ‚Ð¾Ñ€Ð¾Ð¹ Ð¿Ð¸Ñ†Ñ†Ñ‹
220
ÐŸÐ¸Ñ†Ñ†Ð° Ñ€Ð°Ð·Ð¼ÐµÑ€Ð° 50.0 Ð´ÐµÑˆÐµÐ²Ð»Ðµ Ð¿Ð¾ Ñ†ÐµÐ½Ðµ 0.11204507993669431 Ð·Ð°
Ã‡ ÐºÐ²Ð°Ð´Ñ€Ð°Ñ‚Ð½Ñ‹Ð¹ ÑÐ°Ð½Ñ‚Ð¸Ð¼ÐµÑ‚Ñ€

Ð’Ñ‹Ñ‡Ð¸ÑÐ»ÐµÐ½Ð¸Ðµ Ð¿Ð»Ð¾Ñ‰Ð°Ð´Ð¸ Ð¿Ð¸Ñ†Ñ†Ñ‹ Ð¿Ð¾ Ð·Ð°Ð´Ð°Ð½Ð½Ð¾Ð¼Ñƒ Ð´Ð¸Ð°Ð¼ÐµÑ‚Ñ€Ñƒ
areaGivenDiameter :: Double -> Double
areaGivenDiameter size = pi * (size / 2)^2

type Pizza = (Double, Double)
costPerCm :: Pizza -> Double
costPerCm (size, cost) = cost / areaGivenDiameter size


comparePizzas :: Pizza -> Pizza -> Pizza
comparePizzas p1 p2 = if costP1 < costP2
then p1
else p2
where costP1 = costPerCm p1
costP2 = costPerCm p2

describePizza :: Pizza -> String
describePizza (size, cost) = "ÐŸÐ¸Ñ†Ñ†Ð° Ñ€Ð°Ð·Ð¼ÐµÑ€Ð° " ++ show size ++
                             " Ð´ÐµÑˆÐµÐ²Ð»Ðµ Ð¿Ð¾ Ñ†ÐµÐ½Ðµ " ++
                             show costSqCm ++
                             " Ð·Ð° ÐºÐ²Ð°Ð´Ñ€Ð°Ñ‚Ð½Ñ‹Ð¹ ÑÐ°Ð½Ñ‚Ð¸Ð¼ÐµÑ‚Ñ€"
  where costSqCm = costPerCm (size, cost)

main :: IO ()
main = do
  putStrLn "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ñ€Ð°Ð·Ð¼ÐµÑ€ Ð¿ÐµÑ€Ð²Ð¾Ð¹ Ð¿Ð¸Ñ†Ñ†Ñ‹"
  size1 <- getLine
  putStrLn "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÑÑ‚Ð¾Ð¸Ð¼Ð¾ÑÑ‚ÑŒ Ð¿ÐµÑ€Ð²Ð¾Ð¹ Ð¿Ð¸Ñ†Ñ†Ñ‹"
  cost1 <- getLine
  putStrLn "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ñ€Ð°Ð·Ð¼ÐµÑ€ Ð²Ñ‚Ð¾Ñ€Ð¾Ð¹ Ð¿Ð¸Ñ†Ñ†Ñ‹"
  size2 <- getLine
  putStrLn "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÑÑ‚Ð¾Ð¸Ð¼Ð¾ÑÑ‚ÑŒ Ð²Ñ‚Ð¾Ñ€Ð¾Ð¹ Ð¿Ð¸Ñ†Ñ†Ñ‹"
  cost2 <- getLine
  let pizza1 = (read size1, read cost1)
  let pizza2 = (read size2, read cost2)
  let betterPizza = comparePizzas pizza1 pizza2
  putStrLn (describePizza betterPizza)

costData :: Map.Map Int Double
costData = Map.fromList [(1, 150), (2, 220)]

sizeData :: Map.Map Int Double
sizeData = Map.fromList [(1, 30), (2, 50)]

maybeMain :: Maybe String
maybeMain = do
  size1 <- Map.lookup 1 sizeData
  cost1 <- Map.lookup 1 costData
  size2 <- Map.lookup 2 sizeData
  cost2 <- Map.lookup 2 costData
  let pizza1 = (size1, cost1)
  let pizza2 = (size2, cost2)
  let betterPizza = comparePizzas pizza1 pizza2
  return (describePizza betterPizza)

GHCi> maybeMain
Just "ÐŸÐ¸Ñ†Ñ†Ð° Ñ€Ð°Ð·Ð¼ÐµÑ€Ð° 50.0 Ð´ÐµÑˆÐµÐ²Ð»Ðµ Ð¿Ð¾ Ñ†ÐµÐ½Ðµ 0.11204507993669431
Ã‡ Ð·Ð° ÐºÐ²Ð°Ð´Ñ€Ð°Ñ‚Ð½Ñ‹Ð¹ ÑÐ°Ð½Ñ‚Ð¸Ð¼ÐµÑ‚Ñ€"

getArgs :: IO [String]

import System.Environment

main :: IO ()
main = do
args <- getArgs
...

main putStrLn args

main :: IO ()
main = do
  args <- getArgs
  mapM putStrLn args
Couldnâ€™t match type â€™[()]â€™ with â€™()â€™

main :: IO ()
main = do
  args <- getArgs
  mapM_ putStrLn args

$ ./sum
$ ./sum 2
2
$ ./sum 2 3 4 5
2
3
4
5

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 22.1. ÐÐ°Ð¿Ð¸ÑˆÐ¸Ñ‚Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ main, Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÑŽÑ‰ÑƒÑŽ mapM, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ñ‚Ñ€Ð¸Ð¶Ð´Ñ‹ Ð²Ñ‹Ð·Ð²Ð°Ñ‚ÑŒ getLine, Ð° Ð·Ð°Ñ‚ÐµÐ¼ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ mapM_, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð½Ð°Ð¿ÐµÑ‡Ð°Ñ‚Ð°Ñ‚ÑŒ Ð²Ð²ÐµÐ´Ñ‘Ð½Ð½Ñ‹Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ (Ð¿Ð¾Ð´ÑÐºÐ°Ð·ÐºÐ°: Ð²Ð°Ð¼ Ð½ÑƒÐ¶Ð½Ð¾ Ð¾Ñ‚Ð±Ñ€Ð¾ÑÐ¸Ñ‚ÑŒ Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚ Ð¿Ñ€Ð¸ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ð¸ mapM Ñ getLine, Ð´Ð»Ñ Ð´Ð¾ÑÑ‚Ð¸Ð¶ÐµÐ½Ð¸Ñ ÑÑ‚Ð¾Ð³Ð¾ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ (\_ -> ...)).

exampleMain :: IO ()
exampleMain = do
  vals <- mapM (\_ -> getLine) [1..3]
  mapM_ putStrLn vals


ÐšÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ ÑÑ‚Ñ€Ð¾Ðº ÐºÐ°Ðº Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð½Ð¾Ð¹ ÑÑ‚Ñ€Ð¾ÐºÐ¸
main :: IO ()
main = do
  args <- getArgs
  let linesToRead = if length args > 0
                    then read (head args)
                    else 0 :: Int
  print linesToRead

import Control.Monad
main :: IO ()
main = do
  args <- getArgs
  let linesToRead = if length args > 0
                    then read (head args)
                    else 0 :: Int
  numbers <- replicateM linesToRead getLine
  print "Ð·Ð´ÐµÑÑŒ Ð±ÑƒÐ´ÐµÑ‚ ÑÑƒÐ¼Ð¼Ð°"

import System.Environment
import Control.Monad

main :: IO ()
main = do
  args <- getArgs
  let linesToRead = if length args > 0
                    then read (head args)
                    else 0 :: Int
  numbers <- replicateM linesToRead getLine
  let ints = map read numbers :: [Int]
  print (sum ints)

$ ./sum 2
4
59
63
$ ./sum 4
1
2
3
410
416

mapM ÐŸÑ€Ð¸Ð½Ð¸Ð¼Ð°ÐµÑ‚ Ð½Ð° Ð²Ñ…Ð¾Ð´ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ Ð²Ð²Ð¾Ð´Ð°-Ð²Ñ‹Ð²Ð¾Ð´Ð° Ð¸ Ð¾Ð±Ñ‹Ñ‡Ð½Ñ‹Ð¹ ÑÐ¿Ð¸ÑÐ¾Ðº, Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÑÐµÑ‚ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ Ð½Ð° ÐºÐ°Ð¶Ð´Ð¾Ð¼ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ðµ ÑÐ¿Ð¸ÑÐºÐ° Ð¸ Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ ÑÐ¿Ð¸ÑÐ¾Ðº Ð² ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ðµ IO
mapM_ Ð Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ ÐºÐ°Ðº mapM, Ð½Ð¾ Ð¾Ñ‚Ð±Ñ€Ð°ÑÑ‹Ð²Ð°ÐµÑ‚ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚ (Ð¾Ð±Ñ€Ð°Ñ‚Ð¸Ñ‚Ðµ Ð²Ð½Ð¸Ð¼Ð°Ð½Ð¸Ðµ Ð½Ð° _)
replicateM ÐŸÑ€Ð¸Ð½Ð¸Ð¼Ð°ÐµÑ‚ Ð½Ð° Ð²Ñ…Ð¾Ð´ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ Ð²Ð²Ð¾Ð´Ð°-Ð²Ñ‹Ð²Ð¾Ð´Ð° Ð¸ Ñ†ÐµÐ»Ð¾Ðµ Ñ‡Ð¸ÑÐ»Ð¾ n,
Ð¿Ð¾Ð²Ñ‚Ð¾Ñ€ÑÐµÑ‚ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ n Ñ€Ð°Ð· Ð¸ Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ñ‹ Ð² Ð²Ð¸Ð´Ðµ
ÑÐ¿Ð¸ÑÐºÐ° Ð² ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ðµ IO
replicateM_ Ð Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ ÐºÐ°Ðº replicateM, Ð½Ð¾ Ð¾Ñ‚Ð±Ñ€Ð°ÑÑ‹Ð²Ð°ÐµÑ‚ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚

myReplicateM :: Monad m => Int -> m a -> m [a]
myReplicateM n func = mapM (\_ -> func) [1 .. n]

Ð˜Ð·ÑƒÑ‡ÐµÐ½Ð¸Ðµ Ð¾ÑÐ¾Ð±ÐµÐ½Ð½Ð¾ÑÑ‚ÐµÐ¹ Ð»ÐµÐ½Ð¸Ð²Ð¾Ð³Ð¾ Ð²Ð²Ð¾Ð´Ð°-Ð²Ñ‹Ð²Ð¾Ð´Ð°
main :: IO ()
main = do
userInput <- getContents
mapM_ print userInput

$ ./sum_lazy
hi
â€™hâ€™
â€™iâ€™
â€™\nâ€™
what?
â€™wâ€™
â€™hâ€™
â€™aâ€™
â€™tâ€™
â€™?â€™
â€™\nâ€™

Ð¢ÐµÑÑ‚Ð¾Ð²Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ ÐºÐ°Ðº ÑÑ‚Ñ€Ð¾ÐºÐ° Ð²Ñ…Ð¾Ð´Ð½Ñ‹Ñ… ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð²
sampleData = [â€™6â€™, â€™2â€™, â€™\nâ€™, â€™2â€™, â€™1â€™, â€™\nâ€™]

GHCi> lines sampleData
["62", "21"]

ÐžÑ‚Ð²ÐµÑ‚ 22.3
reverser :: IO ()
reverser = do
  input <- getContents
  let reversed = reverse input
  putStrLn reversed

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 22.9 ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ myLines Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ splitOn
myLines = splitOn "\n"

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 22.10 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ toInts Ð´Ð»Ñ Ð¿Ñ€ÐµÐ¾Ð±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¸Ñ Char Ð² Int
toInts :: String -> [Int]
toInts = map read . lines

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 22.11 Ð›ÐµÐ½Ð¸Ð²Ð¾Ðµ Ñ€ÐµÑˆÐµÐ½Ð¸Ðµ Ð·Ð°Ð´Ð°Ñ‡Ð¸ ÑÑƒÐ¼Ð¼Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ Ñ‡Ð¸ÑÐµÐ»
main :: IO ()
main = do
  userInput <- getContents
  let numbers = toInts userInput
  print (sum numbers)

$ ./sum_lazy
4
234
23
1
3
<ctrl-d>
265

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 22.4. ÐÐ°Ð¿Ð¸ÑˆÐ¸Ñ‚Ðµ Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ñƒ, Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÑŽÑ‰ÑƒÑŽ ÑÑƒÐ¼Ð¼Ñƒ ÐºÐ²Ð°Ð´Ñ€Ð°Ñ‚Ð¾Ð² Ð²Ð²ÐµÐ´Ñ‘Ð½Ð½Ñ‹Ñ… Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¼ Ñ‡Ð¸ÑÐµÐ».
ÐžÑ‚Ð²ÐµÑ‚ 22.4
mainSumSquares :: IO ()
mainSumSquares = do
  userInput <- getContents
  let numbers = toInts userInput
  let squares = map (^2) numbers
  print (sum squares)

import qualified Data.Text as T

T.pack :: String -> T.Text
T.unpack :: T.Text -> String

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 23.1 ÐŸÑ€ÐµÐ¾Ð±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð¼ÐµÐ¶Ð´Ñƒ Ñ‚Ð¸Ð¿Ð°Ð¼Ð¸ String Ð¸ Text
firstWord :: String
firstWord = "Ð¿ÐµÑÑÐ¸Ð¼Ð¸Ð·Ð¼"

secondWord :: T.Text
secondWord = T.pack firstWord

thirdWord :: String
thirdWord = T.unpack secondWord

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 23.1. ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»Ð¸Ñ‚Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ fourthWord, Ð¿Ñ€ÐµÐ¾Ð±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð²
thirdWord Ð² T.Text.

ÐžÑ‚Ð²ÐµÑ‚ 23.1
fourthWord :: T.Text
fourthWord = T.pack thirdWord

myWord :: T.Text
myWord = "ÑÐ¾Ð±Ð°ÐºÐ°"
Couldnâ€™t match expected type â€™T.Textâ€™ with actual type â€™[Char]â€™

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 23.3 Ð§Ð¸ÑÐ»Ð¾Ð²Ñ‹Ðµ Ð»Ð¸Ñ‚ÐµÑ€Ð°Ð»Ñ‹ Ñ€Ð°Ð·Ð½Ñ‹Ñ… Ñ‚Ð¸Ð¿Ð¾Ð²
myNum1 :: Int
myNum1 = 3

myNum2 :: Integer
myNum2 = 3

myNum3 :: Double
myNum3 = 3

$ ghc text.hs -XOverloadedStrings

{-# LANGUAGE <Extension Name> #-}

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 23.4 Ð Ð°ÑÑˆÐ¸Ñ€ÐµÐ½Ð¸Ðµ OverloadedStrings Ð¸ Ð»Ð¸Ñ‚ÐµÑ€Ð°Ð»Ñ‹ Ñ‚Ð¸Ð¿Ð° Text
{-# LANGUAGE OverloadedStrings #-}
import qualified Data.Text as T

aWord :: T.Text
aWord = "Ð¡Ñ‹Ñ€"

main :: IO ()
main = do
   print aWord

ÐžÑ‚Ð²ÐµÑ‚ 23.2. Ð—Ð°Ð¿ÑƒÑÐº ÐºÐ¾Ð¼Ð¿Ð¸Ð»ÑÑ‚Ð¾Ñ€Ð° GHC Ð¸Ð· ÐºÐ¾Ð¼Ð°Ð½Ð´Ð½Ð¾Ð¹ ÑÑ‚Ñ€Ð¾ÐºÐ¸:
$ ghc templates.hs -XTemplateHaskell

ÐŸÐµÑ€Ð²Ð°Ñ ÑÑ‚Ñ€Ð¾ÐºÐ° Ñ„Ð°Ð¹Ð»Ð° templates.hs:
{-# LANGUAGE TemplateHaskell -#}

ViewPatterns â€” Ð±Ð¾Ð»ÐµÐµ Ð¿Ñ€Ð¾Ð´Ð²Ð¸Ð½ÑƒÑ‚Ð¾Ðµ ÑÐ¾Ð¿Ð¾ÑÑ‚Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ñ Ð¾Ð±Ñ€Ð°Ð·Ñ†Ð¾Ð¼;
â€š TemplateHaskell â€” Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹ Ð´Ð»Ñ Ð¼ÐµÑ‚Ð°Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ;
â€š DuplicateRecordFields â€” Ñ€ÐµÑˆÐµÐ½Ð¸Ðµ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ñ‹ Ð¸Ð· ÑƒÑ€Ð¾ÐºÐ° 16, ÐºÐ¾Ð³Ð´Ð°
Ð¾Ð´Ð¸Ð½Ð°ÐºÐ¾Ð²Ñ‹Ðµ Ð¸Ð¼ÐµÐ½Ð° Ð¿Ð¾Ð»ÐµÐ¹ Ð² Ñ€Ð°Ð·Ð½Ñ‹Ñ… Ñ‚Ð¸Ð¿Ð°Ñ…, Ð¾Ð±ÑŠÑÐ²Ð»ÑÐµÐ¼Ñ‹Ñ… Ð² ÑÐ¸Ð½Ñ‚Ð°ÐºÑÐ¸ÑÐµ Ð·Ð°Ð¿Ð¸ÑÐµÐ¹, Ð²Ñ‹Ð·Ñ‹Ð²Ð°ÑŽÑ‚ ÐºÐ¾Ð½Ñ„Ð»Ð¸ÐºÑ‚;
â€š NoImplicitPrelude â€” Ð¾Ñ‚ÐºÐ»ÑŽÑ‡Ð°ÐµÑ‚ ÑÑ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ñ‹Ð¹ Prelude (Ð¼Ñ‹ ÑƒÐ¶Ðµ
Ð¾Ñ‚Ð¼ÐµÑ‡Ð°Ð»Ð¸, Ñ‡Ñ‚Ð¾ Ð¼Ð½Ð¾Ð³Ð¸Ðµ Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ð¸ÑÑ‚Ñ‹ ÐµÐ³Ð¾ Ð½Ðµ Ð»ÑŽÐ±ÑÑ‚).

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 23.5 ÐÐµÐºÐ¸Ð¹ Ñ‚ÐµÐºÑÑ‚ Ñ‚Ð¸Ð¿Ð° Text
sampleInput :: T.Text
sampleInput = "ÑÑ‚Ð¾\nÐ½ÐµÐºÐ¸Ð¹\nÑ‚ÐµÐºÑÑ‚"

GHCi> T.lines sampleInput
["ÑÑ‚Ð¾","Ð½ÐµÐºÐ¸Ð¹","Ñ‚ÐµÐºÑÑ‚"]


Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 23.6 ÐšÐ°ÐºÐ¾Ð¹-Ñ‚Ð¾ Ð´Ñ€ÑƒÐ³Ð¾Ð¹ Ñ‚ÐµÐºÑÑ‚ ÐºÐ°Ðº Ð¿Ñ€Ð¸Ð¼ÐµÑ€ Ð²Ð²Ð¾Ð´Ð° Ð´Ð»Ñ words
someText :: T.Text
someText = "ÐšÐ°ÐºÐ¾Ð¹-Ñ‚Ð¾\nÑÐ¾Ð²ÑÐµÐ¼ Ð´Ñ€ÑƒÐ³Ð¾Ð¹\t Ñ‚ÐµÐºÑÑ‚"

   Ð’Ñ‹ Ð»ÐµÐ³ÐºÐ¾ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ ÑƒÐ²Ð¸Ð´ÐµÑ‚ÑŒ, ÐºÐ°Ðº ÑÑ‚Ð¾ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚, Ð² GHCi:

GHCi> T.words someText
["ÐšÐ°ÐºÐ¾Ð¹-Ñ‚Ð¾","ÑÐ¾Ð²ÑÐµÐ¼","Ð´Ñ€ÑƒÐ³Ð¾Ð¹","Ñ‚ÐµÐºÑÑ‚"]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 23.7 ÐŸÑ€Ð¸Ð¼ÐµÑ€ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ñ splitOn
breakText :: T.Text
breakText = "Ð¿Ñ€Ð¾ÑÑ‚Ð¾"

newText :: T.Text
newText = "Ð­Ñ‚Ð¾ Ð¿Ñ€Ð¾ÑÑ‚Ð¾ ÑÐ´ÐµÐ»Ð°Ñ‚ÑŒ"

Ð˜ Ð² GHCi:
GHCi> T.splitOn breakText newText
["Ð­Ñ‚Ð¾ "," ÑÐ´ÐµÐ»Ð°Ñ‚ÑŒ"]

GHCi> T.unlines (T.lines sampleInput)
"ÑÑ‚Ð¾\nÐ½ÐµÐºÐ¸Ð¹\nÑ‚ÐµÐºÑÑ‚"
GHCi> T.unwords (T.words someText)
"ÐšÐ°ÐºÐ¾Ð¹-Ñ‚Ð¾ ÑÐ¾Ð²ÑÐµÐ¼ Ð´Ñ€ÑƒÐ³Ð¾Ð¹ Ñ‚ÐµÐºÑÑ‚"

GHCi> T.intercalate breakText (T.splitOn breakText newText)
"Ð­Ñ‚Ð¾ Ð¿Ñ€Ð¾ÑÑ‚Ð¾ ÑÐ´ÐµÐ»Ð°Ñ‚ÑŒ"

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 23.3. ÐÐ°Ð¿Ð¸ÑˆÐ¸Ñ‚Ðµ ÑÐ¾Ð±ÑÑ‚Ð²ÐµÐ½Ð½Ñ‹Ðµ Ñ€ÐµÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ð¸ Ð´Ð²ÑƒÑ… Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹
T.lines Ð¸ T.unlines, Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÑ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ splitOn Ð¸ T.intercalate.

ÐžÑ‚Ð²ÐµÑ‚ 23.3
myLines :: T.Text -> [T.Text]
myLines text = T.splitOn "\n" text

myUnlines :: [T.Text] -> T.Text
myUnlines textLines = T.intercalate "\n" textLines

combined :: String
combined = "some" ++ " " ++ "strings"

{-# LANGUAGE OverloadedStrings #-}
import qualified Data.Text as T
import Data.Semigroup

combinedTextMonoid :: T.Text
combinedTextMonoid = mconcat ["Ð½ÐµÐºÐ¸Ð¹"," ","Ñ‚ÐµÐºÑÑ‚"]

combinedTextSemigroup :: T.Text
combinedTextSemigroup = "Ð½ÐµÐºÐ¸Ð¹" <> " " <> "Ñ‚ÐµÐºÑÑ‚"

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 23.8 Ð¡Ð»Ð¾Ð²Ð¾ Â«Ð´Ñ…Ð°Ñ€Ð¼Ð°Â» ÐºÐ°Ðº Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Ñ‚Ð¸Ð¿Ð° Text (Ð´ÐµÐ²Ð°Ð½Ð°Ð³Ð°Ñ€Ð¸)
dharma :: T.Text
dharma = "Dm
"

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 23.10 ÐŸÐ¾Ð´ÑÐ²ÐµÑ‡Ð¸Ð²Ð°Ð½Ð¸Ðµ ÑÐµÐ³Ð¼ÐµÐ½Ñ‚Ð¾Ð² Ñ‚ÐµÐºÑÑ‚Ð° Ñ„ÑƒÐ½ÐºÑ†Ð¸ÐµÐ¹ highlight
highlight :: T.Text -> T.Text -> T.Text
highlight query fullText = T.intercalate highlighted pieces
   where pieces = T.splitOn query fullText
         highlighted = mconcat ["{",query,"}

import qualified Data.Text.IO as TIO
Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 23.11 ÐŸÑ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ð° Ð´Ð»Ñ Ð¿Ð¾Ð´ÑÐ²ÐµÑ‡Ð¸Ð²Ð°Ð½Ð¸Ñ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð¾Ð² Ð¿Ð¾Ð¸ÑÐºÐ°
{-# LANGUAGE OverloadedStrings #-}
import qualified Data.Text as T
import qualified Data.Text.IO as TIO
dharma :: T.Text
dharma = "Dm
"
bgText :: T.Text
bgText =
"Â™yA-vDm
ao EvgZ, prDm
aA(-vnEÂ¤tAt^ -vDm
e EnDn\ Â™y, prDm
ao ByAvh,"
highlight :: T.Text -> T.Text -> T.Text
highlight query fullText = T.intercalate highlighted pieces
   where pieces = T.splitOn query fullText
         highlighted = mconcat ["{",query,"}"]
main = do
   TIO.putStrLn (highlight dharma bgTex
$./bg_highlight
Â™yA-v{Dm
}ao EvgZ, pr{Dm
}aA(-vnEÂ¤tAt^ -v{Dm
}e EnDn\ Â™y, pr{Dm
}ao ByAv


Ð—Ð°Ð´Ð°Ñ‡Ð° 23.1. ÐŸÐµÑ€ÐµÐ¿Ð¸ÑˆÐ¸Ñ‚Ðµ Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ñƒ hello_world.hs Ð¸Ð· ÑƒÑ€Ð¾ÐºÐ° 21 (Ð²Ð¾ÑÐ¿Ñ€Ð¾Ð¸Ð·Ð²ÐµÐ´ÐµÐ½Ð° Ð·Ð´ÐµÑÑŒ), Ð·Ð°Ð¼ÐµÐ½Ð¸Ð² String Ð½Ð° Text.
helloPerson :: String -> String
helloPerson name = "ÐŸÑ€Ð¸Ð²ÐµÑ‚, " ++ name ++ "!"

main :: IO ()
main = do
   putStrLn "ÐŸÑ€Ð¸Ð²ÐµÑ‚! ÐšÐ°Ðº Ñ‚ÐµÐ±Ñ Ð·Ð¾Ð²ÑƒÑ‚?"
   name <- getLine
   let statement = helloPerson name
   putStrLn statement

Ð—Ð°Ð´Ð°Ñ‡Ð° 23.2. ÐŸÐ¾Ð»ÑŒÐ·ÑƒÑÑÑŒ Ñ‚Ð¸Ð¿Ð¾Ð¼ Text Ð¸ Ð¸Ð¼Ð¿Ð¾Ñ€Ñ‚Ð¸Ñ€ÑƒÑ Ð¼Ð¾Ð´ÑƒÐ»Ð¸ Data.Text.Lazy
Ð¸ Data.Text.Lazy.IO, Ð¿ÐµÑ€ÐµÐ¿Ð¸ÑˆÐ¸Ñ‚Ðµ Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ñƒ ÑÑƒÐ¼Ð¼Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ Ð²Ð²Ð¾Ð´Ð¸Ð¼Ñ‹Ñ…
Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¼ Ñ‡Ð¸ÑÐµÐ» Ð¸Ð· ÑƒÑ€Ð¾ÐºÐ° 22 (Ñ€Ð°Ð·Ð´ÐµÐ» Ð¿Ð¾ Ð»ÐµÐ½Ð¸Ð²Ð¾Ð¼Ñƒ Ð²Ð²Ð¾Ð´Ñƒ-Ð²Ñ‹Ð²Ð¾Ð´Ñƒ).
toInts :: String -> [Int]
toInts = map read . lines

main :: IO ()
main = do
  userInput <- getContents
  let numbers = toInts userInput
  print (sum numbers

import System.IO
openFile :: FilePath -> IOMode -> IO Handle
type FilePath = String

data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 24.2 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ main, Ð¾Ñ‚ÐºÑ€Ñ‹Ð²Ð°ÑŽÑ‰Ð°Ñ Ð¸ Ð·Ð°ÐºÑ€Ñ‹Ð²Ð°ÑŽÑ‰Ð°Ñ Ñ„Ð°Ð¹Ð»
main :: IO ()
main = do
  myFile <- openFile "hello.txt" ReadMode
  hClose myFile
  putStrLn "Ð³Ð¾Ñ‚Ð¾Ð²Ð¾!"

ÐžÑ‚Ð²ÐµÑ‚ 24.1
openFile "stuff.txt" ReadMode

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 24.3 Ð§Ñ‚ÐµÐ½Ð¸Ðµ Ð¸Ð· Ñ„Ð°Ð¹Ð»Ð° Ð¸ Ð·Ð°Ð¿Ð¸ÑÑŒ Ð² stdout Ð¸ Ð´Ñ€ÑƒÐ³Ð¾Ð¹ Ñ„Ð°Ð¹Ð»
main :: IO ()
main = do
  helloFile <- openFile "hello.txt" ReadMode
  firstLine <- hGetLine helloFile
  putStrLn firstLine
  secondLine <- hGetLine helloFile
  goodbyeFile <- openFile "goodbye.txt" WriteMode
  hPutStrLn goodbyeFile secondLine
  hClose goodbyeFile
  putStrLn "Ð³Ð¾Ñ‚Ð¾Ð²Ð¾!"

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 24.4 ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° Ñ„Ð°Ð¹Ð»Ð° Ð½Ð° Ð½ÐµÐ¿ÑƒÑÑ‚Ð¾Ñ‚Ñƒ Ð¿ÐµÑ€ÐµÐ´ Ñ‡Ñ‚ÐµÐ½Ð¸ÐµÐ¼ Ð¸Ð· Ð½ÐµÐ³Ð¾
main :: IO ()
main = do
  helloFile <- openFile "hello.txt" ReadMode
  hasLine <- hIsEOF helloFile
  firstLine <- if not hasLine
  then hGetLine helloFile
  else return "Ð¿ÑƒÑÑ‚Ð¾Ð¹ Ñ„Ð°Ð¹Ð»"
  putStrLn "Ð³Ð¾Ñ‚Ð¾Ð²Ð¾!"

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 24.2. ÐŸÑ€Ð¾Ð²ÐµÑ€ÑŒÑ‚Ðµ Ð½Ð°Ð»Ð¸Ñ‡Ð¸Ðµ Ð² Ñ„Ð°Ð¹Ð»Ðµ Ð²Ñ‚Ð¾Ñ€Ð¾Ð¹ ÑÑ‚Ñ€Ð¾ÐºÐ¸.

ÐžÑ‚Ð²ÐµÑ‚ 24.2. Ð•ÑÐ»Ð¸ Ð²Ñ‚Ð¾Ñ€Ð¾Ð¹ ÑÑ‚Ñ€Ð¾ÐºÐ¸ Ð½ÐµÑ‚, Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÐ¼ Ð¿ÑƒÑÑ‚ÑƒÑŽ ÑÑ‚Ñ€Ð¾ÐºÑƒ:
hasSecondLine <- hIsEOF helloFile
secondLine <- if not hasSecondLine
              then hGetLine helloFile
              else return ""

readFile :: FilePath -> IO String
writeFile :: FilePath -> String -> IO ()
appendFile :: FilePath -> String -> IO ()

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 24.5 ÐŸÑ€Ð¸Ð¼ÐµÑ€ ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ð¼Ð¾Ð³Ð¾ Ñ„Ð°Ð¹Ð»Ð° stats.dat
hello.txt ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð²: 29 ÑÐ»Ð¾Ð²: 5 ÑÑ‚Ñ€Ð¾Ðº: 2
what.txt ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð²: 30000 ÑÐ»Ð¾Ð²: 2404 ÑÑ‚Ñ€Ð¾Ðº: 1

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 24.6 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ getCounts ÑÐ¾Ð±Ð¸Ñ€Ð°ÐµÑ‚ ÑÑ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÑƒ Ð² ÐºÐ¾Ñ€Ñ‚ÐµÐ¶
getCounts :: String -> (Int, Int, Int)
getCounts input = (charCount, wordCount, lineCount)
  where charCount = length input
        wordCount = (length . words) input
        lineCount = (length . lines) input

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 24.7 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ countsText Ð¸ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð² Ñ‡Ð¸Ñ‚Ð°ÐµÐ¼Ð¾Ð¼ Ð²Ð¸Ð´Ðµ
countsText :: (Int, Int, Int) -> String
countsText (cc, wc, lc) = unwords ["ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð²: "
                                   , show cc
                                   , " ÑÐ»Ð¾Ð²: "
                                   , show wc
                                   , " ÑÑ‚Ñ€Ð¾Ðº: "
                                   , show lc]

GHCi> (countsText . getCounts) "ÑÑ‚Ð¾ ÐºÐ°ÐºÐ¾Ð¹-Ñ‚Ð¾\n Ñ‚ÐµÐºÑÑ‚"
"ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð²: 20 ÑÐ»Ð¾Ð²: 3 ÑÑ‚Ñ€Ð¾Ðº: 2"

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 24.8 Ð¡Ð¾Ð²Ð¼ÐµÑ‰Ð°ÐµÐ¼ ÐºÐ¾Ð´ Ð² Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ main
main :: IO ()
main = do
  args <- getArgs
  let fileName = head args
  input <- readFile fileName
  let summary = (countsText . getCounts) input
  appendFile "stats.dat"
  (mconcat [fileName, " ", summary, "\n"])
   putStrLn summary

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 24.3. ÐŸÐ¾Ñ‡ÐµÐ¼Ñƒ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ unwords Ð¿Ñ€ÐµÐ´Ð¿Ð¾Ñ‡Ñ‚Ð¸Ñ‚ÐµÐ»ÑŒÐ½ÐµÐµ
ÐºÐ¾Ð¼Ð±Ð¸Ð½Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ ÑÑ‚Ñ€Ð¾Ðº Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ ++?
ÐžÑ‚Ð²ÐµÑ‚ 24.3. ÐžÐ¿ÐµÑ€Ð°Ñ†Ð¸Ñ ++ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ ÑÐ¾ ÑÐ¿Ð¸ÑÐºÐ°Ð¼Ð¸. Ð’ ÑƒÑ€Ð¾ÐºÐµ 23
Ð¼Ñ‹ Ð¿Ð¾Ð´Ñ€Ð¾Ð±Ð½Ð¾ Ñ€Ð°Ð·Ð±Ð¸Ñ€Ð°Ð»Ð¸ Ð´Ñ€ÑƒÐ³Ð¸Ðµ Ñ‚ÐµÐºÑÑ‚Ð¾Ð²Ñ‹Ðµ Ñ‚Ð¸Ð¿Ñ‹, Ð¿Ð¾Ð¼Ð¸Ð¼Ð¾ String. 
Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ unwords Ð¸Ð¼ÐµÐµÑ‚ Ð²ÐµÑ€ÑÐ¸ÑŽ Ð¸ Ð´Ð»Ñ Text, Ð¸ Ð´Ð»Ñ String, Ð² Ñ‚Ð¾ Ð²Ñ€ÐµÐ¼Ñ ÐºÐ°Ðº ++
Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð´Ð»Ñ Ñ‚Ð¸Ð¿Ð° String. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ unwords Ð·Ð½Ð°Ñ‡Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ Ð¾Ð±Ð»ÐµÐ³Ñ‡Ð°ÐµÑ‚ 
Ð¼Ð¾Ð´Ð¸Ñ„Ð¸ÐºÐ°Ñ†Ð¸ÑŽ ÐºÐ¾Ð´Ð° Ð² ÑÐ»ÑƒÑ‡Ð°Ðµ Ð¿Ñ€Ð¸Ð½ÑÑ‚Ð¸Ñ Ñ€ÐµÑˆÐµÐ½Ð¸Ñ Ð¾ Ð·Ð°Ð¼ÐµÐ½Ðµ String Ð½Ð° Text.

$ ./fileCounts hello.txt
ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð²: 29 ÑÐ»Ð¾Ð²: 5 ÑÑ‚Ñ€Ð¾Ðº: 2

$ cat stats.dat
hello.txt ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð²: 29 ÑÐ»Ð¾Ð²: 5 ÑÑ‚Ñ€Ð¾Ðº: 2

$ ./fileCounts stats.dat
fileCounts: stats.dat: openFile: resource busy (file is locked)

readFile :: FilePath -> IO String
readFile name = do
inputFile <- openFile name ReadMode
hGetContents inputFile


Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 24.9 Ð Ð°ÑÐºÑ€Ñ‹Ñ‚Ð¸Ðµ Ñ‚ÐµÐ»Ð° Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ readFile Ð² Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ main
main :: IO ()
main = do
  args <- getArgs
  let fileName = head args
  file <- openFile fileName ReadMode
  input <- hGetContents file
  hClose file
  let summary = (countsText . getCounts) input
  appendFile "stats.dat"
             (mconcat [fileName. " ", summary, "\n"])
  putStrLn summary

$ ./fileCounts stats.dat
fileCounts: stats.dat: hGetContents: illegal operation
Ã‡ (delayed read on closed handle)

$ ./fileCounts hello.txt
fileCounts: stats.dat: hGetContents: illegal operation
Ã‡ (delayed read on closed handle)

main :: IO ()
main = do
  args <- getArgs
  let fileName = head args
  file <- openFile fileName ReadMode
  input <- hGetContents file
  hClose file
  let summary = (countsText . getCounts) input
  appendFile "stats.dat" (mconcat [fileName, " ", summary, "\n"])
  putStrLn summary

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 24.10 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ main Ñ Ð¸ÑÐ¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸ÑÐ¼Ð¸
main :: IO ()
main = do
   args <- getArgs
   let fileName = head args
   file <- openFile fileName ReadMode
   input <- hGetContents file
   let summary = (countsText . getCounts) input
   putStrLn summary
   hClose file
   appendFile "stats.dat"
               (mconcat [fileName,
               " ", summary, "\n"])

{-# LANGUAGE OverloadedStrings #-}
import System.IO
import System.Environment
import qualified Data.Text as T

import qualified Data.Text.IO as TI
getCounts :: T.Text -> (Int, Int, Int)
getCounts input = (charCount, wordCount, lineCount)
  where charCount = T.length input
        wordCount = (length . T.words) input
        lineCount = (length . T.lines) input

countsText :: (Int, Int, Int) -> T.Text
countsText (cc, wc, lc) = T.pack (unwords ["chars: "
                                    , show cc
                                    , " words: "
                                    , show wc
                                    , " lines: "
                                    , show lc])
main :: IO ()
main = do
  args <- getArgs
  let fileName = head args
  input <- TI.readFile fileName
  let summary = (countsText . getCounts) input
  TI.appendFile "stats.dat"
                (mconcat [(T.pack fileName),
                " ", summary, "\n"])
  TI.putStrLn summary

tatsuhikoTakimoto :: T.Text
tatsuhikoTakimoto = "æ»æœ¬ ç«œå½¦"

import qualified Data.ByteString as B

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 25.1 Ð—Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ ByteString, Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»Ñ‘Ð½Ð½Ð¾Ðµ Ñ OverloadedStrings
sampleBytes :: B.ByteString
sampleBytes = "ÐŸÑ€Ð¸Ð²ÐµÑ‚!"


Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 25.2 Ð Ð°ÑÐ¿Ð°ÐºÐ¾Ð²Ñ‹Ð²Ð°ÐµÐ¼ ByteString Ð² String â€” Ð¾ÑˆÐ¸Ð±ÐºÐ°!
sampleString :: String
sampleString = B.unpack sampleBytes

B.unpack :: B.ByteString -> [GHC.Word.Word8]

import qualified Data.ByteString.Char8 as BC

B.unpack :: BC.ByteString -> [GHC.Word.Word8]
BC.unpack :: BC.ByteString -> [Char]

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 25.1. ÐÐ°Ð¿Ð¸ÑˆÐ¸Ñ‚Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ, ÐºÐ¾Ñ‚Ð¾Ñ€Ð°Ñ Ð¿Ñ€Ð¸Ð½Ð¸Ð¼Ð°ÐµÑ‚ Ñ‡Ð¸ÑÐ»Ð¾ Ð² Ð²Ð¸Ð´Ðµ
ÑÑ‚Ñ€Ð¾ÐºÐ¸ Ð¸Ð· ASCII-ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð² Ð¸ Ð¿ÐµÑ€ÐµÐ²Ð¾Ð´Ð¸Ñ‚ ÐµÐ³Ð¾ Ð² Int. Ð”Ð»Ñ Ð¿Ñ€Ð¸Ð¼ÐµÑ€Ð° Ð¿Ñ€ÐµÐ¾Ð±Ñ€Ð°Ð·ÑƒÐ¹Ñ‚Ðµ ÑÐ»ÐµÐ´ÑƒÑŽÑ‰ÐµÐµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Ð² Int:
bcInt :: BC.ByteString
bcInt = "6"

ÐžÑ‚Ð²ÐµÑ‚ 25.1
bcInt :: BC.ByteString
bcInt = "6"
bcToInt :: BC.ByteString -> Int
bcToInt = read . BC.unpack

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 25.3 ÐÐ°Ð±Ñ€Ð¾ÑÐºÐ¸ glitcher.hs

import System.Environment
import qualified Data.ByteString as B
import qualified Data.ByteString.Char8 as BC

main :: IO ()
main = do
  args <- getArgs
  let fileName = head args
  imageFile <- BC.readFile fileName
  glitched <- return imageFile
  let glitchedFileName = mconcat ["glitched_",fileName]
  BC.writeFile glitchedFileName glitched
  putStrLn "Ð“Ð¾Ñ‚Ð¾Ð²Ð¾!"

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 25.4 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ intToChar Ð¿Ñ€ÐµÐ¾Ð±Ñ€Ð°Ð·ÑƒÐµÑ‚ Ð±Ð°Ð¹Ñ‚ Ð² Int
intToChar :: Int -> Char
intToChar int = toEnum safeInt
   where safeInt = int â€˜modâ€˜ 255

ÐžÑ‚Ð²ÐµÑ‚ 25.2
let glitched = imageFile

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 25.5 intToBC Ð¿Ñ€ÐµÐ¾Ð±Ñ€Ð°Ð·ÑƒÐµÑ‚ Int Ð² Ð¾Ð´Ð½Ð¾ÑÐ¸Ð¼Ð²Ð¾Ð»ÑŒÐ½ÑƒÑŽ ByteString
intToBC :: Int -> BC.ByteString
intToBC int = BC.pack [intToChar int]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 25.6 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ replaceByte Ð·Ð°Ð¼ÐµÐ½ÑÐµÑ‚ Ð±Ð°Ð¹Ñ‚ Ð½Ð° Ð½Ð¾Ð²Ñ‹Ð¹
replaceByte :: Int -> Int -> BC.ByteString -> BC.ByteString
replaceByte loc chV bytes = mconcat [before,newChar,after]
  where (before,rest) = BC.splitAt loc bytes
      after = BC.drop 1 rest
      newChar = intToBC chV

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 25.7 ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ ÑÐ»ÑƒÑ‡Ð°Ð¹Ð½Ñ‹Ñ… Ñ‡Ð¸ÑÐµÐ» Ð² randomReplaceByte
randomReplaceByte :: BC.ByteString -> IO BC.ByteString
randomReplaceByte bytes = do
   let bytesLength = BC.length bytes
   location <- randomRIO (1,bytesLength)
   chV <- randomRIO (0,255)
   return (replaceByte location chV bytes)

main :: IO ()
main = do
  args <- getArgs
  let fileName = head args
  imageFile <- BC.readFile fileName
  glitched <- randomReplaceByte imageFile
  let glitchedFileName = mconcat ["glitched_",fileName]
  BC.writeFile glitchedFileName glitched
  putStrLn "Ð“Ð¾Ñ‚Ð¾Ð²Ð¾!"

$ ghc glitcher.hs
$ ./glitcher lovecraft.jpg
Ð“Ð¾Ñ‚Ð¾Ð²Ð¾!


Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 25.8 Ð¡Ð¾Ñ€Ñ‚Ð¸Ñ€Ð¾Ð²ÐºÐ° Ñ„Ñ€Ð°Ð³Ð¼ÐµÐ½Ñ‚Ð° Ð´Ð°Ð½Ð½Ñ‹Ñ…
sortSection :: Int -> Int -> BC.ByteString -> BC.ByteString
sortSection start size bytes =
mconcat [before,changed,after]
   where (before,rest) = BC.splitAt start bytes
         (target,after) = BC.splitAt size rest
         changed = BC.reverse (BC.sort target)

ÐžÑ‚Ð²ÐµÑ‚ 25.3
randomChar :: IO Char
randomChar = do
   randomInt <- randomRIO (0,255)
   return (toEnum randomInt)

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 25.9 Ð­Ð»ÐµÐ¼ÐµÐ½Ñ‚ ÑÐ»ÑƒÑ‡Ð°Ð¹Ð½Ð¾ÑÑ‚Ð¸ Ð² sortSection
randomSortSection :: BC.ByteString -> IO BC.ByteString
randomSortSection bytes = do
    let sectionSize = 25
    let bytesLength = BC.length bytes
    start <- randomRIO (0,bytesLength - sectionSize)
    return (sortSection start sectionSize bytes)

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 25.10 ÐÐ¾Ð²Ð°Ñ Ð²ÐµÑ€ÑÐ¸Ñ main Ñ randomSortSection
main :: IO ()
main = do
  args <- getArgs
  let fileName = head args
  imageFile <- BC.readFile fileName
  glitched <- randomSortSection imageFile
  let glitchedFileName = mconcat ["glitched_",fileName]
  BC.writeFile glitchedFileName glitched
  print "all done"

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 25.11 Ð’Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ðµ Ð½Ð°Ð±Ð¾Ñ€Ð° Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ð¹: Ð³Ñ€Ð¾Ð¼Ð¾Ð·Ð´ÐºÐ¸Ð¹ Ð¿Ð¾Ð´Ñ…Ð¾Ð´
main :: IO ()
main = do
  args <- getArgs
  let fileName = head args
  imageFile <- BC.readFile fileName
  glitched1 <- randomReplaceByte imageFile
  glitched2 <- randomSortSection glitched1
  glitched3 <- randomReplaceByte glitched2
  glitched4 <- randomSortSection glitched3
  glitched5 <- randomReplaceByte glitched4
  let glitchedFileName = mconcat ["glitched_",fileName]
  BC.writeFile glitchedFileName glitched5
  putStrLn "Ð“Ð¾Ñ‚Ð¾Ð²Ð¾!"

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 25.12 Ð£Ð»ÑƒÑ‡ÑˆÐµÐ½Ð½Ð°Ñ Ð²ÐµÑ€ÑÐ¸Ñ Ñ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸ÐµÐ¼ foldM
main :: IO ()
main = do
  args <- getArgs
  let fileName = head args
  imageFile <- BC.readFile fileName
  glitched <- foldM (\bytes func -> func bytes) imageFile
                    [ randomReplaceByte , randomSortSection
                    , randomReplaceByte , randomSortSection
                    , randomReplaceByte]
  let glitchedFileName = mconcat ["glitched_",fileName]
  BC.writeFile glitchedFileName glitched
  putStrLn "Ð“Ð¾Ñ‚Ð¾Ð²Ð¾!"

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 25.4. Ð¡Ð¾Ð·Ð´Ð°Ð¹Ñ‚Ðµ Ð·Ð° Ð¿Ñ€ÐµÐ´ÐµÐ»Ð°Ð¼Ð¸ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ main Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½ÑƒÑŽ
glitchActions, ÑÐ¾Ð´ÐµÑ€Ð¶Ð°Ñ‰ÑƒÑŽ ÑÐ¿Ð¸ÑÐ¾Ðº Ð²ÑÐµÑ… Ñ‚Ñ€ÐµÐ±ÑƒÐµÐ¼Ñ‹Ñ… Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ð¹. ÐÐµ Ð·Ð°Ð±ÑƒÐ´ÑŒÑ‚Ðµ ÑƒÐºÐ°Ð·Ð°Ñ‚ÑŒ Ð´Ð»Ñ Ð½ÐµÑ‘ ÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ñ‹Ð¹ Ñ‚Ð¸Ð¿.

ÐžÑ‚Ð²ÐµÑ‚ 25.4
glitchActions :: [BC.ByteString -> IO BC.ByteString]
glitchActions = [randomReplaceByte ,randomSortSection
                 ,randomReplaceByte ,randomSortSection
                 ,randomReplaceByte]


Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 25.15 ÐŸÐ¾Ð¿Ñ‹Ñ‚ÐºÐ° Ð¿Ñ€ÐµÐ¾Ð±Ñ€Ð°Ð·Ð¾Ð²Ð°Ñ‚ÑŒ Text Ð² ByteString
nagarjunaB :: B.ByteString
nagarjunaB = (BC.pack . T.unpack) nagarjunaTe

GHCi> TIO.putStrLn ((T.pack . BC.unpack) nagarjunaB)
"(>\ETB0M\FSA("

import qualified Data.Text.Encoding as E

E.encodeUtf8 :: T.Text -> BC.ByteString
E.decodeUtf8 :: BC.ByteString -> T.Text

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 25.16 ÐŸÑ€ÐµÐ¾Ð±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¸Ñ Ð¼ÐµÐ¶Ð´Ñƒ Text Ð¸ ByteString
nagarjunaSafe :: B.ByteString
nagarjunaSafe = E.encodeUtf8 nagarjunaText

GHCi> TIO.putStrLn (E.decodeUtf8 nagarjunaSafe)
nAgAj

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.1 ÐÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ñ‹Ðµ Ð¼Ð¾Ð´ÑƒÐ»Ð¸ Ð´Ð»Ñ Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ñ‹ marc_to_html.hs

{-# LANGUAGE OverloadedStrings #-}
import qualified Data.ByteString as B
import qualified Data.Text as T
import qualified Data.Text.IO as TIO
import qualified Data.Text.Encoding as E
import Data.Maybe

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.2 Ð¡Ð¸Ð½Ð¾Ð½Ð¸Ð¼Ñ‹ Ñ‚Ð¸Ð¿Ð¾Ð² Author Ð¸ Title
type Author = T.Text
type Title = T.Text

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.3 Ð¢Ð¸Ð¿ Book
data Book = Book {
author :: Author
, title :: Title} deriving Show

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.4 Ð¡Ð¸Ð½Ð¾Ð½Ð¸Ð¼ Ñ‚Ð¸Ð¿Ð° Html
type Html = T.Text

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.5 Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ñ„Ñ€Ð°Ð³Ð¼ÐµÐ½Ñ‚Ð° HTML-ÐºÐ¾Ð´Ð° Ð´Ð»Ñ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ñ ÐºÐ½Ð¸Ð³Ð¸
bookToHtml :: Book -> Html
bookToHtml book = mconcat ["<p>\n"
                     , titleInTags
                     , authorInTags
                     , "</p>\n"]
  where titleInTags = mconcat [ "<strong>", title book
                              , "</strong>\n"]
        authorInTags = mconcat [ "<em>", author book
                               , "</em>\n"]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.6 ÐÐµÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ð¿Ñ€Ð¸Ð¼ÐµÑ€Ð¾Ð² ÐºÐ½Ð¸Ð³
book1 :: Book
book1 = Book {
   title = "Ð—Ð°Ð³Ð¾Ð²Ð¾Ñ€ Ð¿Ñ€Ð¾Ñ‚Ð¸Ð² Ñ‡ÐµÐ»Ð¾Ð²ÐµÐºÐ°"
   , author = "Ð›Ð¸Ð³Ð¾Ñ‚Ñ‚Ð¸, Ð¢Ð¾Ð¼Ð°Ñ"
}
book2 :: Book
book2 = Book {
   title = "Ð¢Ñ€Ð°ÐºÑ‚Ð°Ñ‚ Ð¾ Ñ€Ð°Ð·Ð»Ð¾Ð¶ÐµÐ½Ð¸Ð¸"
   , author = "Ð§Ð¾Ñ€Ð°Ð½, Ð­Ð¼Ð¸Ð»ÑŒ"
}
book3 :: Book
book3 = Book {
  title = "Ð¡Ð»Ñ‘Ð·Ñ‹ Ð­Ñ€Ð¾ÑÐ°"
  , author = "Ð‘Ð°Ñ‚Ð°Ð¹, Ð–Ð¾Ñ€Ð¶"
}
GHCi> bookToHtml book1
"<p>\n<strong>Ð—Ð°Ð³Ð¾Ð²Ð¾Ñ€ Ð¿Ñ€Ð¾Ñ‚Ð¸Ð² Ñ‡ÐµÐ»Ð¾Ð²ÐµÐºÐ°</strong>\n<em>Ð›Ð¸Ð³Ð¾Ñ‚Ñ‚Ð¸,
Ã‡ Ð¢Ð¾Ð¼Ð°Ñ</em>\n</p>\n"

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.7 ÐŸÑ€ÐµÐ¾Ð±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¸Ðµ ÑÐ¿Ð¸ÑÐºÐ° ÐºÐ½Ð¸Ð³ Ð² HTML-Ð´Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚
booksToHtml :: [Book] -> Html
booksToHtml books =
  mconcat [ "<html>\n"
          , "<head><title>ÐºÐ½Ð¸Ð³Ð¸</title>"
          , "<meta charset=â€™utf-8â€™/>"
          , "</head>\n"]
          , "<body>\n"
          , booksHtml
          , "\n</body>\n"
          , "</html>"]
  where booksHtml = (mconcat . (map bookToHtml)) books

myBooks :: [Book]
myBooks = [book1, book2, book3]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.8 Ð’ÐµÑ€ÑÐ¸Ñ main c Ð·Ð°Ð¿Ð¸ÑÑŒÑŽ ÑÐ¿Ð¸ÑÐºÐ° ÐºÐ½Ð¸Ð³ Ð² HTML
main :: IO ()
main = TIO.writeFile "books.html" (booksToHtml myBooks)

Ð—Ð°Ð³Ð¾Ð²Ð¾Ñ€ Ð¿Ñ€Ð¾Ñ‚Ð¸Ð² Ñ‡ÐµÐ»Ð¾Ð²ÐµÐºÐ° Ð›Ð¸Ð³Ð¾Ñ‚Ñ‚Ð¸, Ð¢Ð¾Ð¼Ð°Ñ
Ð¢Ñ€Ð°ÐºÑ‚Ð°Ñ‚ Ð¾ Ñ€Ð°Ð·Ð»Ð¾Ð¶ÐµÐ½Ð¸Ð¸ Ð§Ð¾Ñ€Ð°Ð½, Ð­Ð¼Ð¸Ð»ÑŒ
Ð¡Ð»Ñ‘Ð·Ñ‹ Ð­Ñ€Ð¾ÑÐ° Ð‘Ð°Ñ‚Ð°Ð¹, Ð–Ð¾Ñ€Ð¶

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.9 Ð¡Ð¸Ð½Ð¾Ð½Ð¸Ð¼Ñ‹ Ñ‚Ð¸Ð¿Ð¾Ð² MarcRecordRaw Ð¸ MarcLeaderRaw
type MarcRecordRaw = B.ByteString
type MarcLeaderRaw = B.ByteString

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.10 Ð”Ð»Ð¸Ð½Ð° Ð½Ð°Ñ‡Ð°Ð»ÑŒÐ½Ð¾Ð¹ Ñ‡Ð°ÑÑ‚Ð¸
leaderLength :: Int
leaderLength = 24

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.11 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ getLeader Ð¿Ð¾Ð»ÑƒÑ‡Ð°ÐµÑ‚ Ð¿ÐµÑ€Ð²Ñ‹Ðµ 24 Ð±Ð°Ð¹Ñ‚Ð° Ð·Ð°Ð¿Ð¸ÑÐ¸
getLeader :: MarcRecordRaw -> MarcLeaderRaw
getLeader record = B.take leaderLength record

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.12 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ð¸ rawToInt Ð¸ getRecordLength
rawToInt :: B.ByteString -> Int
rawtoInt = (read . T.unpack . E.decodeUtf8)

getRecordLength :: MarcLeaderRaw -> Int
getRecordLength leader = rawToInt (B.take 5 leader)

nextAndRest :: B.ByteString -> (MarcRecordRaw, B.ByteString)

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.13 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ nextAndRest Ð¾Ñ‚Ð´ÐµÐ»ÑÐµÑ‚ Ð¿ÐµÑ€Ð²ÑƒÑŽ Ð·Ð°Ð¿Ð¸ÑÑŒ Ð¿Ð¾Ñ‚Ð¾ÐºÐ°
nextAndRest :: B.ByteString -> (MarcRecordRaw, B.ByteString)
nextAndRest marcStream = B.splitAt recordLength marcStream
   where recordLength = getRecordLength marcStream

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.14 ÐŸÑ€ÐµÐ¾Ð±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð¿Ð¾Ñ‚Ð¾ÐºÐ° Ð² ÑÐ¿Ð¸ÑÐ¾Ðº Ð·Ð°Ð¿Ð¸ÑÐµÐ¹
allRecords :: B.ByteString -> [MarcRecordRaw]
allRecords marcStream = if marcStream == B.empty
                        then []
                        else next : allRecords rest
  where (next, rest) = nextAndRest marcStream

main :: IO ()
main = do
  marcData <- B.readFile "sample.mrc"
  let marcRecords = allRecords marcData
  print (length marcRecords)

GHCi> main
140328

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.15 Ð¡Ð¸Ð½Ð¾Ð½Ð¸Ð¼ Ñ‚Ð¸Ð¿Ð° MarcDirectoryRaw
type MarcDirectoryRaw = B.ByteString

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.16 ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ Ð±Ð°Ð·Ð¾Ð²Ð¾Ð³Ð¾ Ð°Ð´Ñ€ÐµÑÐ°
getBaseAddress :: MarcLeaderRaw -> Int
getBaseAddress leader = rawToInt (B.take 5 remainder)
  where remainder = B.drop 12 leader

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.17 Ð’Ñ‹Ñ‡Ð¸ÑÐ»ÐµÐ½Ð¸Ðµ Ð´Ð»Ð¸Ð½Ñ‹ ÐºÐ°Ñ‚Ð°Ð»Ð¾Ð³Ð°
getDirectoryLength :: MarcLeaderRaw -> Int
getDirectoryLength leader =
   getBaseAddress leader - (leaderLength + 1)

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.18 Ð¡Ð¾Ð²Ð¼ÐµÑ‰Ð°ÐµÐ¼ Ð²ÑÑ‘ Ð² Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ getDirectory
getDirectory :: MarcRecordRaw -> MarcDirectoryRaw
getDirectory record = B.take directoryLength afterLeader
   where directoryLength = getDirectoryLength record
         afterLeader = B.drop leaderLength record

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.19 Ð¢Ð¸Ð¿ Ð´Ð»Ñ ÐºÐ°Ñ‚Ð°Ð»Ð¾Ð³Ð¾Ð²Ð¾Ð¹ Ð·Ð°Ð¿Ð¸ÑÐ¸ Ð¸ ÐµÑ‘ Ð´Ð»Ð¸Ð½Ð°
type MarcDirectoryEntryRaw = B.ByteString

dirEntryLength :: Int
dirEntryLength = 12

splitDirectory :: MarcDirectoryRaw -> [MarcDirectoryEntryRaw]
Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.20 splitDirectory Ñ€Ð°Ð·Ð±Ð¸Ð²Ð°ÐµÑ‚ ÐºÐ°Ñ‚Ð°Ð»Ð¾Ð³ Ð½Ð° ÑÐ¿Ð¸ÑÐ¾Ðº Ð·Ð°Ð¿Ð¸ÑÐµÐ¹
splitDirectory directory =
   if directory == B.empty
   then []
   else nextEntry : splitDirectory restEntries
 where (nextEntry, restEntries) = B.splitAt dirEntryLength
                                            directory

ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¸Ð· ÐºÐ°Ñ‚Ð°Ð»Ð¾Ð³Ð° Ð¸ Ð¿Ð¾Ð¸ÑÐº Ð¿Ð¾Ð»ÐµÐ¹ MARC-Ð·Ð°Ð¿Ð¸ÑÐµÐ¹
Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.21 Ð¢Ð¸Ð¿ FieldMetadata
data FieldMetadata =
FieldMetadata { tag :: T.Text
              , fieldLength :: Int
              , fieldStart :: Int } deriving Show

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.22 ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ ÐºÐ°Ñ‚Ð°Ð»Ð¾Ð³Ð¾Ð²Ð¾Ð¹ Ð·Ð°Ð¿Ð¸ÑÐ¸ Ñ‚Ð¸Ð¿Ð° FieldMetadata
makeFieldMetadata :: MarcDirectoryEntryRaw -> FieldMetadata
makeFieldMetadata entry =
    FieldMetadata textTag theLength theStart
  where (theTag, rest) = B.splitAt 3 entry
        textTag = E.decodeUtf8 theTag
        (rawLength, rawStart) = B.splitAt 4 rest
        theLength = rawToInt rawLength
        theStart = rawToInt rawStart

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.23 ÐŸÐ¾ÑÑ‚Ñ€Ð¾ÐµÐ½Ð¸Ðµ ÑÐ¿Ð¸ÑÐºÐ° ÐºÐ°Ñ‚Ð°Ð»Ð¾Ð³Ð¾Ð²Ñ‹Ñ… Ð·Ð°Ð¿Ð¸ÑÐµÐ¹
getFieldMetadata :: [MarcDirectoryEntryRaw] -> [FieldMetadata]
getFieldMetadata rawEntries = map makeFieldMetadata rawEntries

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.24 Ð¡Ð¸Ð½Ð¾Ð½Ð¸Ð¼ Ñ‚Ð¸Ð¿Ð° FieldText
type FieldText = T.Text

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.25 ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ FieldText
getTextField :: MarcRecordRaw -> FieldMetadata -> FieldText
getTextField record fieldMetadata =
     E.decodeUtf8 byteStringValue
  where recordLength = getRecordLength record
        baseAddress = getBaseAddress record
        baseRecord = B.drop baseAddress record
        baseAtEntry = B.drop (fieldStart fieldMetadata)
        baseRecord
  byteStringValue = B.take (fieldLength fieldMetadata)
                            baseAtEntry

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.26 ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ Ñ€Ð°Ð·Ð´ÐµÐ»Ð¸Ñ‚ÐµÐ»Ñ Ð¿Ð¾Ð´Ð¿Ð¾Ð»ÐµÐ¹
fieldDelimeter :: Char
fieldDelimeter = toEnum 31

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.27 Ð¢ÐµÐ³Ð¸ Ð¸ ÐºÐ¾Ð´Ñ‹ Ð¿Ð¾Ð´Ð¿Ð¾Ð»ÐµÐ¹ Ð´Ð»Ñ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ñ Ð¸ Ð°Ð²Ñ‚Ð¾Ñ€Ð°
titleTag :: T.Text
titleTag = "245"

titleSubfield :: Char
titleSubfield = â€™aâ€™

authorTag :: T.Text
authorTag = "100"

authorSubfield :: Char
authorSubfield = â€™aâ€™

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.28 Ð‘ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ñ‹Ð¹ Ð¿Ð¾Ð¸ÑÐº FieldMetadata Ð² ÐºÐ°Ñ‚Ð°Ð»Ð¾Ð³Ðµ
lookupFieldMetadata aTag record = if length results < 1
                                  then Nothing
                                  else Just (head results)
   where metadata =
         (getFieldMetadata . splitDirectory . getDirectory)
         record
     results = filter ((== aTag) . tag) metadata

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.29 ÐŸÐ¾Ð¸ÑÐº Ð¿Ð¾Ñ‚ÐµÐ½Ñ†Ð¸Ð°Ð»ÑŒÐ½Ð¾ Ð¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ð²ÑƒÑŽÑ‰ÐµÐ³Ð¾ Ð¿Ð¾Ð´Ð¿Ð¾Ð»Ñ
lookupSubfield :: Maybe FieldMetadata -> Char ->
                  MarcRecordRaw -> Maybe T.Text
lookupSubfield Nothing subfield record = Nothing
lookupSubfield (Just fieldMetadata) subfield record =
     if results == []
     then Nothing
     else Just ((T.drop 1 . head) results)
 where rawField = getTextField record fieldMetadata
       subFields = T.split (== fieldDelimeter) rawField
       results = filter ((== subfield) . T.head) subFields

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.30 ÐŸÐ¾Ð¸ÑÐº Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ð¹ Ð¿Ð¾ Ñ‚ÐµÐ³Ñƒ Ð¸ ÐºÐ¾Ð´Ñƒ Ð¿Ð¾Ð´Ð¿Ð¾Ð»Ñ
lookupValue :: T.Text -> Char -> MarcRecordRaw -> Maybe T.Text
lookupValue aTag subfield record =
     lookupSubfield entryMetadata subfield record
  where entryMetadata = lookupFieldMetadata aTag record

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.31 Ð¡Ð¿ÐµÑ†Ð¸Ð°Ð»ÑŒÐ½Ñ‹Ðµ ÑÐ»ÑƒÑ‡Ð°Ð¸ Ð´Ð»Ñ Title Ð¸ Author
lookupTitle :: MarcRecordRaw -> Maybe Title
lookupTitle = lookupValue titleTag titleSubfield

lookupAuthor :: MarcRecordRaw -> Maybe Author
lookupAuthor = lookupValue authorTag authorSubfield

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.32 ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ð¹ Ð¸ Ð°Ð²Ñ‚Ð¾Ñ€Ð¾Ð² Ð¸Ð· MARC-Ð·Ð°Ð¿Ð¸ÑÐµÐ¹
marcToPairs :: B.ByteString -> [(Maybe Title, Maybe Author)]
marcToPairs marcStream = zip titles authors
  where records = allRecords marcStream
        titles = map lookupTitle records
        authors = map lookupAuthor records

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.33 ÐŸÑ€ÐµÐ¾Ð±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ð¹ Maybe Ð² Book
pairsToBooks :: [(Maybe Title, Maybe Author)] -> [Book]
pairsToBooks pairs =
     map (\(title, author) -> Book {
                               title = fromJust title
                              , author = fromJust author
                             })
         justPairs
  where
     justPairs =
        filter (\(title, author) -> isJust title
                                    & isJust author)
               pairs

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 26.34 Ð¡Ð¾Ð²Ð¼ÐµÑ‰Ð°ÐµÐ¼ Ð²ÑÑ‘ Ð² Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ processRecords
processRecords :: Int -> B.ByteString -> Html
processRecords n = booksToHtml
                  . pairsToBooks
                  . take n
                  . marcToPairs

main :: IO ()
main = do
   marcData <- B.readFile "sample.mrc"
   let processed = processRecords 500 marcData
   TIO.writeFile "books.html" processed

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 1 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ halve Ñ‚Ð¸Ð¿Ð° Int -> Double
halve :: Int -> Double
halve n = fromIntegral n / 2.0

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 2 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ halveMaybe â€” Ð¾Ð±Ñ‘Ñ€Ñ‚ÐºÐ° halve Ð´Ð»Ñ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹ Ñ Maybe
halveMaybe :: Maybe Int -> Maybe Double
halveMaybe (Just n) = Just (halve n)
halveMaybe Nothing = Nothing

ÐšÐ»Ð°ÑÑ Ñ‚Ð¸Ð¿Ð¾Ð² Functor
â€š [Int];
â€š Map String Int;
â€š Maybe Int;
â€š IO Int.
printInt :: Maybe String -> IO ()
printInt Nothing = putStrLn "Ð—Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Ð¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ð²ÑƒÐµÑ‚"
printInt (Just val) = putStrLn val
ÐšÐ°Ðº Ð²Ñ‹ Ð¼Ð¾Ð³Ð»Ð¸ Ð±Ñ‹ Ð¿ÐµÑ€ÐµÐ²ÐµÑÑ‚Ð¸ Ð²Ð°Ñˆ Ñ‚Ð¸Ð¿ Maybe Int Ð² Maybe String, Ñ‡Ñ‚Ð¾Ð±Ñ‹
Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ printInt?

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 27.1 ÐŸÑ€Ð¸Ð¼ÐµÑ€Ñ‹ Ð¿Ð¾Ñ‚ÐµÐ½Ñ†Ð¸Ð°Ð»ÑŒÐ½Ð¾ Ð¿ÑƒÑÑ‚Ñ‹Ñ… Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ð¹
successfulRequest :: Maybe Int
successfulRequest = Just 6

failedRequest :: Maybe Int
failedRequest = Nothing

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 27.2 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ, Ð¸Ð½ÐºÑ€ÐµÐ¼ÐµÐ½Ñ‚Ð¸Ñ€ÑƒÑŽÑ‰Ð°Ñ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Maybe Int
incMaybe :: Maybe Int -> Maybe Int
incMaybe (Just n) = Just (n + 1)
incMaybe Nothing = Nothing

Ð’ GHCi ÑÑ‚Ð¾ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ Ð¾Ñ‚Ð»Ð¸Ñ‡Ð½Ð¾:
GHCi> incMaybe successfulRequest
Just 7
GHCi> incMaybe failedRequest
Nothing

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 27.1. ÐÐ°Ð¿Ð¸ÑˆÐ¸Ñ‚Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ reverseMaybe, ÐºÐ¾Ñ‚Ð¾Ñ€Ð°Ñ Ð¸Ð½Ð²ÐµÑ€Ñ‚Ð¸Ñ€ÑƒÐµÑ‚ ÑÑ‚Ñ€Ð¾ÐºÑƒ Ð² Ð·Ð°Ð´Ð°Ð½Ð½Ð¾Ð¼ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ð¸ Maybe String 
Ð¸ Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚ ÐºÐ°Ðº Maybe String, Ð²Ð¾Ñ‚ ÐµÑ‘ Ñ‚Ð¸Ð¿Ð¾Ð²Ð°Ñ Ð°Ð½Ð½Ð¾Ñ‚Ð°Ñ†Ð¸Ñ:
reverseMaybe :: Maybe String -> Maybe String

ÐžÑ‚Ð²ÐµÑ‚ 27.1
reverseMaybe :: Maybe String -> Maybe String
reverseMaybe Nothing = Nothing
reverseMaybe (Just string) = Just (reverse string)

ÐšÐ»Ð°ÑÑ Ñ‚Ð¸Ð¿Ð¾Ð² Functor Ð¸ Ð²Ñ‹Ð·Ð¾Ð² Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹ Ð² ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ðµ
fmap :: Functor f => (a -> b) -> f a -> f b

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 27.3 Ð”ÐµÐ»Ð°ÐµÐ¼ Maybe ÑÐºÐ·ÐµÐ¼Ð¿Ð»ÑÑ€Ð¾Ð¼ Functor
instance Functor Maybe where
fmap func (Just n) = Just (func n)
fmap func Nothing = Nothing

GHCi> fmap (+ 1) successfulRequest
Just 7
GHCi> fmap (+ 1) failedRequest
Nothing

GHCi> (+ 1) <$> successfulRequest
Just 7
GHCi> (+ 1) <$> failedRequest
Nothing

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 27.4 ÐŸÑ€Ð¸Ð¼ÐµÑ€ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ñ fmap Ñ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸ÐµÐ¼ Ñ‚Ð¸Ð¿Ð°
successStr :: Maybe String
successStr = show <$> successfulRequest

failStr :: Maybe String
failStr = show <$> failedRequest

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 27.2. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ fmap Ð¸Ð»Ð¸ <$>, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¸Ð½Ð²ÐµÑ€Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Maybe String.
ÐžÑ‚Ð²ÐµÑ‚ 27.2
GHCi> reverse <$> Just "ÐºÐ¾Ñ‚"
Just "Ñ‚Ð¾Ðº"

Semigroup, Monoid, Ð° Ñ‚ÐµÐ¿ÐµÑ€ÑŒ Functor!
Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 27.5 Ð¢Ð¸Ð¿ Ð´Ð°Ð½Ð½Ñ‹Ñ… RobotPart
data RobotPart = RobotPart
    { name :: String
      , description :: String
      , cost :: Double
      , count :: Int
    } deriving Show

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 27.6 ÐŸÑ€Ð¸Ð¼ÐµÑ€Ñ‹ ÐºÐ¾Ð¼Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ð¾Ð² Ñ€Ð¾Ð±Ð¾Ñ‚Ð¾Ð²
leftArm :: RobotPart
leftArm = RobotPart
  { name = "left arm"
    , description = "Ð»ÐµÐ²Ð°Ñ Ñ€ÑƒÐºÐ° Ð´Ð»Ñ Ñ‚Ð¾Ð³Ð¾, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð±Ð¸Ñ‚ÑŒ Ð² Ð»Ð¸Ñ†Ð¾!"
    , cost = 1000.00
    , count = 3
  }

rightArm :: RobotPart
rightArm = RobotPart
  { name = "right arm"
    , description = "Ð¿Ñ€Ð°Ð²Ð°Ñ Ñ€ÑƒÐºÐ° Ð´Ð»Ñ Ð´Ð¾Ð±Ñ€Ñ‹Ñ… Ð¶ÐµÑÑ‚Ð¾Ð²"
    , cost = 1025.00
    , count = 5
  }
robotHead :: RobotPart
robotHead = RobotPart
  { name = "robot head"
   , description = "ÑÑ‚Ð° Ð³Ð¾Ð»Ð¾Ð²Ð° Ð²Ñ‹Ð³Ð»ÑÐ´Ð¸Ñ‚ Ð±ÐµÐ·ÑƒÐ¼Ð½Ð¾Ð¹"
   , cost = 5092.25
   , count = 2
  }

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 27.7 ÐŸÐµÑ€ÐµÐ²Ð¾Ð´ RobotPart Ð² HTML
type Html = String
renderHtml :: RobotPart -> Html
renderHtml part = mconcat [ "<h2>",partName, "</h2>"
                            , "<p><h3>desc</h3>", partDesc
                            , "</p><p><h3>cost</h3>"
                            , partCost
                            , "</p><p><h3>count</h3>"
                            , partCount, "</p>"]
   where partName = name part
         partDesc = description part
         partCost = show (cost part)
         partCount = show (count part)

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 27.8 Ð‘Ð°Ð·Ð° Ð´Ð°Ð½Ð½Ñ‹Ñ… ÐºÐ¾Ð¼Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ð¾Ð² Ñ€Ð¾Ð±Ð¾Ñ‚Ð¾Ð²
import qualified Data.Map as Map
partsDB :: Map.Map Int RobotPart
partsDB = Map.fromList keyVals
  where keys = [1,2,3]
        vals = [leftArm,rightArm,robotHead]
        keyVals = zip keys vals

insertSnippet :: Maybe Html -> IO ()
Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 27.9 partVal: Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Maybe RobotPart
partVal :: Maybe RobotPart
partVal = Map.lookup 1 partsDB

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 27.10 ÐŸÑ€ÐµÐ¾Ð±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¸Ðµ RobotPart Ð² HTML Ð² Ñ€Ð°Ð¼ÐºÐ°Ñ… Maybe
partHtml :: Maybe Html
partHtml = renderHtml <$> partVal

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 27.11 Ð¡Ð¿Ð¸ÑÐ¾Ðº ÐºÐ¾Ð¼Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ð¾Ð² Ñ€Ð¾Ð±Ð¾Ñ‚Ð¾Ð²
allParts :: [RobotPart]
allParts = map snd (Map.toList partsDB)

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 27.12 ÐŸÑ€ÐµÐ¾Ð±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¸Ðµ ÑÐ¿Ð¸ÑÐºÐ° ÐºÐ¾Ð¼Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ð¾Ð² Ð² HTML
allPartsHtml :: [Html]
allPartsHtml = renderHtml <$> allParts

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 27.13 ÐŸÑ€Ð¸Ð²Ñ‹Ñ‡Ð½Ñ‹Ð¹ ÑÐ¿Ð¾ÑÐ¾Ð± Ð¿Ñ€ÐµÐ¾Ð±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¸Ñ Ñ Ð²Ñ‹Ð·Ð¾Ð²Ð¾Ð¼ map
allPartsHtml :: [Html]
allPartsHtml = map renderHtml allParts


ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 27.3. ÐŸÐµÑ€ÐµÐ¿Ð¸ÑˆÐ¸Ñ‚Ðµ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ allParts, Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÑ <$> Ð²Ð¼ÐµÑÑ‚Ð¾ map.
ÐžÑ‚Ð²ÐµÑ‚ 27.3
allParts :: [RobotPart]
allParts = snd <$> Map.toList partsDB

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 27.14 ÐŸÑ€ÐµÐ¾Ð±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¸Ðµ partsDB Ð² Map, ÑÐ¾Ð´ÐµÑ€Ð¶Ð°Ñ‰Ð¸Ð¹ HTML
htmlPartsDB :: Map.Map Int Html
htmlPartsDB = renderHtml <$> partsDB

GHCi> Map.lookup 1 htmlPartsDB
Just "<h2>left arm</h2><p><h3>desc</h3>left ...

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 27.15 ÐœÐ¾Ð´ÐµÐ»Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ RobotPart Ð² ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ðµ IO
leftArmIO :: IO RobotPart
leftArmIO = return leftArm

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 27.16 ÐŸÑ€ÐµÐ¾Ð±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¸Ðµ IO RobotPart Ðº IO HTML
htmlSnippet :: IO Html
htmlSnippet = renderHtml <$> leftArmIO

partHtml :: Maybe Html
partHtml = renderHtml <$> partVal

allPartsHtml :: [Html]
allPartsHtml = renderHtml <$> allParts

htmlPartsDB :: Map.Map Int Html
htmlPartsDB = renderHtml <$> partsDB

htmlSnippet :: IO Html
htmlSnippet = renderHtml <$> leftArmIO

data Box a = Box a deriving Show
myBox :: Box Int
myBox = Box 1
GHCi> wrapped = fmap ? myBox
GHCi> wrapped
Box (Box 1)
GHCi> fmap unwrap wrapped
Box 1

ÐŸÑ€Ð¸ÑÑ‚ÑƒÐ¿Ð°ÐµÐ¼ Ðº Ð°Ð¿Ð¿Ð»Ð¸ÐºÐ°Ñ‚Ð¸Ð²Ð½Ñ‹Ð¼ Ñ„ÑƒÐ½ÐºÑ‚Ð¾Ñ€Ð°Ð¼:
Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ Ð² ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ðµ
Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 28.1 Map Ð² ÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ðµ Ð±Ð°Ð·Ñ‹ Ð´Ð°Ð½Ð½Ñ‹Ñ… ÐºÐ¾Ð¾Ñ€Ð´Ð¸Ð½Ð°Ñ‚ Ð³Ð¾Ñ€Ð¾Ð´Ð¾Ð²
type LatLong = (Double,Double)
locationDB :: Map.Map String LatLong
locationDB = Map.fromList [("ÐÑ€ÐºÑ…ÐµÐ¼",(42.6054,-70.7829))
                           ,("Ð˜Ð½Ð½ÑÐ¼ÑƒÑ‚",(42.8250,-70.8150))
                           ,("ÐšÐ°Ñ€ÐºÐ¾Ð·Ð°",(29.9714,-90.7694))
                           ,("ÐÑŒÑŽ-Ð™Ð¾Ñ€Ðº",(40.7776,-73.9691))]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 28.2 Ð’Ñ‹Ñ‡Ð¸ÑÐ»ÐµÐ½Ð¸Ðµ Ñ€Ð°ÑÑÑ‚Ð¾ÑÐ½Ð¸Ñ Ð¼ÐµÐ¶Ð´Ñƒ Ð´Ð²ÑƒÐ¼Ñ Ñ‚Ð¾Ñ‡ÐºÐ°Ð¼Ð¸
toRadians :: Double -> Double
toRadians degrees = degrees * pi / 180

latLongToRads :: LatLong -> (Double,Double)
latLongToRads (lat,long) = (rlat,rlong)
   where rlat = toRadians lat
         rlong = toRadians long

haversine :: LatLong -> LatLong -> Double
haversine coords1 coords2 = earthRadius * c
    where (rlat1,rlong1) = latLongToRads coords1
          (rlat2,rlong2) = latLongToRads coords2
          dlat = rlat2 - rlat1
          dlong = rlong2 - rlong1
          a = (sin (dlat/2))^2 + cos rlat1 * cos rlat2
                                           * (sin (dlong/2))^2
          c = 2 * atan2 (sqrt a) (sqrt (1-a))
          earthRadius = 6378.1

GHCi> haversine (40.7776,-73.9691) (42.6054,-70.7829)
333.134208

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 28.3 Ð’Ñ‹Ð²Ð¾Ð´ Ð¿Ð¾Ñ‚ÐµÐ½Ñ†Ð¸Ð°Ð»ÑŒÐ½Ð¾ Ð¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ð²ÑƒÑŽÑ‰ÐµÐ³Ð¾ Ñ€Ð°ÑÑÑ‚Ð¾ÑÐ½Ð¸Ñ
printDistance :: Maybe Double -> IO ()
printDistance Nothing =
       putStrLn "ÐžÑˆÐ¸Ð±ÐºÐ°, Ð²Ð²ÐµÐ´Ñ‘Ð½ Ð¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ð²ÑƒÑŽÑ‰Ð¸Ð¹ Ð² Ð±Ð°Ð·Ðµ Ð³Ð¾Ñ€Ð¾Ð´"
printDistance (Just dist) = putStrLn (show dist ++ " ÐºÐ¼")

haversine :: LatLong -> LatLong -> Double
Maybe LatLong -> Maybe LatLong -> Maybe Double

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 28.4 ÐžÐ´Ð½Ð¾ Ð¸Ð· Ñ€ÐµÑˆÐµÐ½Ð¸Ð¹ â€” Ð½Ð°Ð¿Ð¸ÑÐ°Ñ‚ÑŒ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ-Ð¾Ð±Ñ‘Ñ€Ñ‚ÐºÑƒ
haversineMaybe :: Maybe LatLong -> Maybe LatLong
                                -> Maybe Double
haversineMaybe Nothing _ = Nothing
haversineMaybe _ Nothing = Nothing
haversineMaybe (Just val1) (Just val2) =
                Just (haversine val1 val2)

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 28.1. ÐÐ°Ð¿Ð¸ÑˆÐ¸Ñ‚Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ addMaybe, Ð²Ñ‹Ñ‡Ð¸ÑÐ»ÑÑŽÑ‰ÑƒÑŽ ÑÑƒÐ¼Ð¼Ñƒ
Ð´Ð²ÑƒÑ… Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ð¹ Ñ‚Ð¸Ð¿Ð° Maybe Int.
ÐžÑ‚Ð²ÐµÑ‚ 28.1
addMaybe :: Maybe Int -> Maybe Int -> Maybe Int
addMaybe (Just x) (Just y) = Just (x + y)
addMaybe _ _ = Nothing

fmap :: Fuctor f => (a -> b) -> f a -> f b
(LatLong -> LatLong -> Double) ->
(Maybe LatLong -> Maybe LatLong -> Maybe Double)
Functor f => (a -> b -> c) -> f a -> f b -> f c

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 28.5 ÐžÐ¿ÐµÑ€Ð°Ñ†Ð¸Ñ <$> Ð¸ Ñ‡Ð°ÑÑ‚Ð¸Ñ‡Ð½Ð¾Ðµ Ð¿Ñ€Ð¸Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ Ð² ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ðµ
maybeInc = (+) <$> Just 1

Ð•ÑÐ»Ð¸ Ð²Ñ‹ Ð¿Ð¾ÑÐ¼Ð¾Ñ‚Ñ€Ð¸Ñ‚Ðµ Ð½Ð° Ñ‚Ð¸Ð¿ ÑÑ‚Ð¾Ð¹ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸, Ñ‚Ð¾ ÑƒÐ²Ð¸Ð´Ð¸Ñ‚Ðµ ÑÐ»ÐµÐ´ÑƒÑŽÑ‰ÐµÐµ:
maybeInc :: Maybe (Integer -> Integer)

Ð—Ð½Ð°ÐºÐ¾Ð¼ÑŒÑ‚ÐµÑÑŒ, Ð¾Ð¿ÐµÑ€Ð°Ñ†Ð¸Ñ <*>
ÐšÐ»Ð°ÑÑ Ñ‚Ð¸Ð¿Ð¾Ð² Applicative ÑƒÐ²ÐµÐ»Ð¸Ñ‡Ð¸Ð²Ð°ÐµÑ‚ Ð²Ñ‹Ñ€Ð°Ð·Ð¸Ñ‚ÐµÐ»ÑŒÐ½ÑƒÑŽ Ð¼Ð¾Ñ‰ÑŒ Functor
Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ Ð¾Ð¿ÐµÑ€Ð°Ñ†Ð¸Ð¸ <*>.

(<*>) :: Applicative f => f (a -> b) -> f a -> f b

GHCi> maybeInc <*> Just 5
Just 6
GHCi> maybeInc <*> Nothing
Nothing
GHCi> maybeInc <*> Just 100
Just 101

GHCi> (++) <$> Just "ÐºÐ¾ÑˆÐºÐ¸" <*> Just " Ð¸ ÑÐ¾Ð±Ð°ÐºÐ¸"
Just "ÐºÐ¾ÑˆÐºÐ¸ Ð¸ ÑÐ¾Ð±Ð°ÐºÐ¸"
GHCi> (++) <$> Nothing <*> Just " Ð¸ ÑÐ¾Ð±Ð°ÐºÐ¸"
Nothing
GHCi> (++) <$> Just "ÐºÐ¾ÑˆÐºÐ¸" <*> Nothing
Nothing

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 28.3. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÑ ÑˆÐ°Ð±Ð»Ð¾Ð½ Ð¸Ð· Ð¿Ñ€Ð¸Ð¼ÐµÑ€Ð° Ð´Ð»Ñ Ð´Ð²ÑƒÑ…Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ð½Ñ‹Ñ…
Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹, Ð¿ÐµÑ€ÐµÐ´Ð°Ð¹Ñ‚Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑÐ¼ (*), div Ð¸ mod ÑÑ‚Ð¸ Ð´Ð²Ð° Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ:
val1 = Just 10
val2 = Just 5

ÐžÑ‚Ð²ÐµÑ‚ 28.3
val1 = Just 10
val2 = Just 5
result1 = (+) <$> val1 <*> val2
result2 = div <$> val1 <*> val2
result3 = mod <$> val1 <*> val2


GHCi> startingCity = Map.lookup "ÐšÐ°Ñ€ÐºÐ¾Ð·Ð°" locationDB
GHCi> destCity = Map.lookup "Ð˜Ð½Ð½ÑÐ¼ÑƒÑ‚" locationDB
GHCi> haversine <$> startingCity <*> destCity
Just 2277.2217600000004

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 28.6 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ main Ð¸Ð· dist.hs
main :: IO ()
main = do
  putStrLn "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð¿ÐµÑ€Ð²Ð¾Ð³Ð¾ Ð³Ð¾Ñ€Ð¾Ð´Ð°:"
  startingInput <- getLine
  let startingCity = Map.lookup startingInput locationDB
  putStrLn "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð²Ñ‚Ð¾Ñ€Ð¾Ð³Ð¾ Ð³Ð¾Ñ€Ð¾Ð´Ð°:"
  destInput <- getLine
  let destCity = Map.lookup destInput locationDB
  let distance = haversine <$> startingCity <*> destCity
  printDistance distance

$ ./dist
Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð¿ÐµÑ€Ð²Ð¾Ð³Ð¾ Ð³Ð¾Ñ€Ð¾Ð´Ð°:
ÐšÐ°Ñ€ÐºÐ¾Ð·Ð°
Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð²Ñ‚Ð¾Ñ€Ð¾Ð³Ð¾ Ð³Ð¾Ñ€Ð¾Ð´Ð°:
Ð˜Ð½Ð½ÑÐ¼ÑƒÑ‚
2277.2217600000003 ÐºÐ¼
$ ./dist
Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð¿ÐµÑ€Ð²Ð¾Ð³Ð¾ Ð³Ð¾Ñ€Ð¾Ð´Ð°:
ÐšÐ°Ñ€ÐºÐ¾Ð·Ð°
Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð²Ñ‚Ð¾Ñ€Ð¾Ð³Ð¾ Ð³Ð¾Ñ€Ð¾Ð´Ð°:
Ð§Ð¸ÐºÐ°Ð³Ð¾
ÐžÑˆÐ¸Ð±ÐºÐ°, Ð²Ð²ÐµÐ´Ñ‘Ð½ Ð¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ð²ÑƒÑŽÑ‰Ð¸Ð¹ Ð² Ð±Ð°Ð·Ðµ Ð³Ð¾Ñ€Ð¾Ð´

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 28.7 Ð’Ñ‹Ñ‡Ð¸ÑÐ»ÐµÐ½Ð¸Ðµ Ð½Ð°Ð¸Ð¼ÐµÐ½ÑŒÑˆÐµÐ³Ð¾ Ð¸Ð· Ñ‚Ñ€Ñ‘Ñ… Ñ‡Ð¸ÑÐµÐ»
minOfThree :: (Ord a) => a -> a -> a -> a
minOfThree val1 val2 val3 = min val1 (min val2 val3)

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 28.8 ÐŸÑ€Ð¾ÑÑ‚Ð¾Ðµ IO-Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ, Ð½Ð°Ð¿Ð¸ÑÐ°Ð½Ð½Ð¾Ðµ Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ <$>
readInt :: IO Int
readInt = read <$> getLine

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 28.9 ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð½ÐµÑÐºÐ¾Ð»ÑŒÐºÐ¸Ñ… Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð² Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ <*>
minOfInts :: IO Int
minOfInts = minOfThree <$> readInt <*> readInt <*> readInt

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 28.10 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ main Ð´Ð»Ñ min3.hs
main :: IO ()
main = do
  putStrLn "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ñ‚Ñ€Ð¸ Ñ‡Ð¸ÑÐ»Ð°"
  minInt <- minOfInts
  putStrLn (show minInt ++ " ÑÐ²Ð»ÑÐµÑ‚ÑÑ Ð½Ð°Ð¸Ð¼ÐµÐ½ÑŒÑˆÐ¸Ð¼")

$ ghc min3.hs
$ ./min3
Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ñ‚Ñ€Ð¸ Ñ‡Ð¸ÑÐ»Ð°
1
2
3
1 ÑÐ²Ð»ÑÐµÑ‚ÑÑ Ð½Ð°Ð¸Ð¼ÐµÐ½ÑŒÑˆÐ¸Ð¼

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 28.4. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÑ minOfThree, Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Maybe Int
Ð¸Ð· ÑÑ‚Ð¸Ñ… Ñ‚Ñ€Ñ‘Ñ… Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ð¹ Ð² ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ðµ Maybe:
Just 10
Just 3
Just 6

ÐžÑ‚Ð²ÐµÑ‚ 28.4
GHCi> minOfThree <$> Just 10 <*> Just 3 <*> Just 6
Just 3


Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 28.11 Ð¢Ð¸Ð¿ Ð´Ð»Ñ Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ñ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ð¸ Ð¾Ð± Ð¸Ð³Ñ€Ð¾ÐºÐµ
data User = User
{ name :: String
, gamerId :: Int
, score :: Int
} deriving Show

GHCi> User {name = "Ð¡ÑŒÑŽ", gamerId = 1337, score = 9001}
User {name = "Ð¡ÑŒÑŽ", gamerId = 1337, score = 9001}
GHCi> User "Ð¡ÑŒÑŽ" 1337 9001
User {name = "Ð¡ÑŒÑŽ", gamerId = 1337, score = 9001}

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 28.12 Ð˜Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ñ Ð´Ð»Ñ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ñ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ð¹ Ñ‚Ð¸Ð¿Ð° User
serverUsername :: Maybe String
serverUsername = Just "Ð¡ÑŒÑŽ"

serverGamerId :: Maybe Int
serverGamerId = Just 1337

serverScore :: Maybe Int
serverScore = Just 9001

GHCi> User <$> serverUsername <*> serverGamerId <*> serverScore
Just (User {name = "Ð¡ÑŒÑŽ", gamerId = 1337, score = 9001})

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 28.13 Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ Ñ‚Ð¸Ð¿Ð° User Ð¸Ð· IO-Ñ‚Ð¸Ð¿Ð¾Ð²
readInt :: IO Int
readInt = read <$> getLine
main :: IO ()
main = do
  putStrLn "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð½Ð¸Ðº, ID Ð¸Ð³Ñ€Ð¾ÐºÐ° Ð¸ ÐµÐ³Ð¾ Ð¾Ñ‡ÐºÐ¸"
  user <- User <$> getLine <*> readInt <*> readInt
  print user

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 28.5. ÐŸÑ€Ð¾Ð²ÐµÑ€ÑŒÑ‚Ðµ, Ñ‡Ñ‚Ð¾ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑÑ, ÐµÑÐ»Ð¸ ÑÐ¾Ð·Ð´Ð°Ñ‚ÑŒ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
Ñ Ð¿Ñ€Ð¾Ð¿ÑƒÑ‰ÐµÐ½Ð½Ñ‹Ð¼ Ð½Ð¸ÐºÐ¾Ð¼ (Nothing).

ÐžÑ‚Ð²ÐµÑ‚ 28.5
GHCi> User <$> Nothing <*> serverGamerId <*> serverScore
Nothing

haversineIO :: IO LatLong -> IO LatLong -> IO Double
data RobotPart = RobotPart
{ name :: String
, description :: String
, cost :: Double
, count :: Int
} deriving Show

fmap :: Functor f :: (a -> b) -> f a -> f b
(<$>) :: Functor f :: (a -> b) -> f a -> f b

fmap :: Functor f :: (a -> b) -> f a -> f b
(<$>) :: Functor f :: (a -> b) -> f a -> f b
(<*>) :: Applicative f => f (a -> b) -> f a -> f b
pure :: Applicative f => a -> f a

GHCi> (*) <$> Just 6 <*> Just 7
Just 42
GHCi> div <$> Just 6 <*> Just 7
Just 0

class Functor f => Applicative f where
(<*>) :: f (a -> b) -> f a -> f b
pure :: a -> f a

GHCi> mod <$> Just 6 <*> Just 7
Just 6

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 29.1. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÑ <$> Ð¸ <*>, ÑÐºÐ¾Ð¼Ð±Ð¸Ð½Ð¸Ñ€ÑƒÐ¹Ñ‚Ðµ Ð´Ð²Ð° Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ
Ñ‚Ð¸Ð¿Ð° Maybe String Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ Ð¾Ð¿ÐµÑ€Ð°Ñ†Ð¸Ð¸ ++.

ÐžÑ‚Ð²ÐµÑ‚ 29.1
GHCi> (++) <$> Just "ÐŸÑ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ð¸Ñ€ÑƒÐ¹" <*> Just " Ð½Ð° Haskell"
Just "ÐŸÑ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ð¸Ñ€ÑƒÐ¹ Ð½Ð° Haskell"

GHCi> pure 6 :: Maybe Int
Just 6

GHCi> (6+) <$> Just 5
Just 11
GHCi> pure (6+) <*> Just 5
Just 11
ÐœÐµÑ‚Ð¾Ð´ pure Ð¿Ð¾Ð¼ÐµÑ‰Ð°ÐµÑ‚ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Ð¿Ñ€Ð¾Ð¸Ð·Ð²Ð¾Ð»ÑŒÐ½Ð¾Ð³Ð¾ Ñ‚Ð¸Ð¿Ð° Ð² ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 29.2. ÐŸÑ€Ð¸Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÑÑ‚Ñ€Ð¾ÐºÑƒ "ÐŸÑ€Ð¸Ð²ÐµÑ‚, ÐœÐ¸Ñ€!" Ðº Ñ‚Ð¸Ð¿Ñƒ IO String
ÐžÑ‚Ð²ÐµÑ‚ 29.2
hello :: IO String
hello = pure "ÐŸÑ€Ð¸Ð²ÐµÑ‚, Ð¼Ð¸Ñ€!

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 29.1 Ð”Ð²ÑƒÑ…ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð½Ñ‹Ð¹ ÐºÐ¾Ñ€Ñ‚ÐµÐ¶ Ñ Ð½ÐµÑƒÐ´Ð°Ñ‡Ð½Ñ‹Ð¼ Ð¸Ð¼ÐµÐ½ÐµÐ¼
data Blah a b = Blah a b

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 29.2 ÐŸÑ€Ð¾ÑÑ‚Ð¾Ð¹ Ñ‚Ð¸Ð¿ Box Ð½Ðµ ÑÐ¸Ð»ÑŒÐ½Ð¾ Ð¾Ñ‚Ð»Ð¸Ñ‡Ð°ÐµÑ‚ÑÑ Ð¾Ñ‚ IO
data Box a = Box a

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 29.3 Ð¢Ð¸Ð¿ Ð´Ð»Ñ Ð¿Ñ€ÐµÐ´ÑÑ‚Ð°Ð²Ð»ÐµÐ½Ð¸Ñ Ñ€ÐµÑÑƒÑ€ÑÐ½Ñ‹Ñ… Ð¾Ð³Ñ€Ð°Ð½Ð¸Ñ‡ÐµÐ½Ð¸Ð¹
data ResourceConstrained a = NoResources | Okay a

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 29.3. Ð”Ð¾Ð¿ÑƒÑÑ‚Ð¸Ð¼, Ð²Ñ‹ Ñ…Ð¾Ñ‚Ð¸Ñ‚Ðµ, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÑÐ»Ð¾ÑÑŒ Ñ€Ð°Ð²ÐµÐ½ÑÑ‚Ð²Ð¾
pure (+) <*> (1,2) <*> (3,4) = (1 + 2, 1 + 4, 2 + 3, 2 + 4)
= (3, 5, 5, 6). ÐŸÐ¾Ñ‡ÐµÐ¼Ñƒ ÑÑ‚Ð¾ Ð½Ðµ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚?
ÐžÑ‚Ð²ÐµÑ‚ 29.3. Ð­Ñ‚Ð¾ Ð½Ðµ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚, Ð¿Ð¾Ñ‚Ð¾Ð¼Ñƒ Ñ‡Ñ‚Ð¾ Ñ‚Ð¸Ð¿ (3, 5, 5, 6) Ð¾Ñ‚Ð»Ð¸Ñ‡Ð°ÐµÑ‚ÑÑ Ð¾Ñ‚ Ñ‚Ð¸Ð¿Ð¾Ð² (1, 2) Ð¸ (3, 4). 
Ð¢Ð¸Ð¿ Ð¿ÐµÑ€Ð²Ð¾Ð³Ð¾ Ð²Ñ‹Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ: (a, b, c, d),
Ñ‚Ð¾Ð³Ð´Ð° ÐºÐ°Ðº Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ñ… Ð´Ð²ÑƒÑ… â€” (a, b).

[1000, 2000, 3000]
+ [500, 20000]
= [1000, 2000, 3000, 500, 20000]

pure (+) <*> [1000, 2000, 3000] <*> [500, 20000]
GHCi> pure (+) <*> [1000, 2000, 3000] <*> [500, 20000]
[1500,21000,2500,22000,3500,23000]

Ð Ð°Ð·Ð»Ð¸Ñ‡Ð¸Ñ ÐºÐ¾Ð½Ñ‚ÐµÐ¹Ð½ÐµÑ€Ð° Ð¸ ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ð° Ð² ÑÐ»ÑƒÑ‡Ð°Ðµ ÑÐ¿Ð¸ÑÐºÐ°
ÑÐ¿Ð¸ÑÐ¾Ðº ÐºÐ°Ðº ÐºÐ¾Ð½Ñ‚ÐµÐ¹Ð½ÐµÑ€ â€” ÑÑ‚Ð¾ Ð¿Ð¾ÑÐ»ÐµÐ´Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚ÑŒ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ð¹;
ÑÐ¿Ð¸ÑÐ¾Ðº ÐºÐ°Ðº ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚ â€” ÑÑ‚Ð¾ Ð½Ð°Ð±Ð¾Ñ€ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ÑÑ‚ÐµÐ¹, Ð¾Ð½ ÑÐ¾Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²ÑƒÐµÑ‚ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ð¾Ð¹, Ð¿Ñ€Ð¸Ð½Ð¸Ð¼Ð°ÑŽÑ‰ÐµÐ¹ Ð¼Ð½Ð¾Ð¶ÐµÑÑ‚Ð²Ð¾ Ñ€Ð°Ð·Ð»Ð¸Ñ‡Ð½Ñ‹Ñ… Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ð¹.

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 29.4 ÐÐµÐ´ÐµÑ‚ÐµÑ€Ð¼Ð¸Ð½Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ðµ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ñ‹ Ð²Ñ‹Ð±Ð¾Ñ€Ð° Ð´Ð²ÐµÑ€Ð¸
doorPrize :: [Int]
doorPrize = [1000, 2000, 3000]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 29.5 ÐÐµÐ´ÐµÑ‚ÐµÑ€Ð¼Ð¸Ð½Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ðµ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ñ‹ Ð²Ñ‹Ð±Ð¾Ñ€Ð° ÐºÐ¾Ñ€Ð¾Ð±Ð¾Ñ‡ÐºÐ¸
boxPrize :: [Int]
boxPrize = [500, 20000]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 29.6 Ð•Ð´Ð¸Ð½ÑÑ‚Ð²ÐµÐ½Ð½Ð¾ÑÑ‚ÑŒ Ð´ÐµÑ‚ÐµÑ€Ð¼Ð¸Ð½Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ð¾Ð³Ð¾ Ð¿Ñ€Ð¸Ð·Ð°
totalPrize :: Int
totalPrize = (+) doorPrize boxPrize

totalPrize :: [Int]
totalPrize = (pure +) <*> doorPrize <*> boxPrize

GHCi> totalPrize
[1500, 21000, 2500, 22000, 3500, 23000]

GHCi> pure (*) <*> [2..4] <*> [2..4]
[4, 6, 8, 6, 9, 12, 8, 12, 16]

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 29.4. Ð ÐµÑˆÐ¸Ñ‚ÑŒ ÑÑ‚Ñƒ Ð·Ð°Ð´Ð°Ñ‡Ñƒ, ÑÑ‡Ð¸Ñ‚Ð°Ñ, Ñ‡Ñ‚Ð¾ ÐºÐ¾Ñ€Ð¾Ð±Ð¾Ñ‡ÐºÐ¸ Ð¿Ñ€ÐµÐ´ÑÑ‚Ð°Ð²Ð»ÑÑŽÑ‚ ÑÐ¾Ð±Ð¾Ð¹ Ð¼ÑƒÐ»ÑŒÑ‚Ð¸Ð¿Ð»Ð¸ÐºÐ°Ñ‚Ð¾Ñ€ Ð¿Ñ€Ð¸Ð·Ð¾Ð²Ñ‹Ñ…: Ð¿Ñ€Ð¸ Ð¾Ñ‚ÐºÑ€Ñ‹Ñ‚Ð¸Ð¸ Ð¿ÐµÑ€Ð²Ð¾Ð¹ ÐºÐ¾Ñ€Ð¾Ð±Ð¾Ñ‡ÐºÐ¸
Ð¿Ñ€Ð¸Ð·Ð¾Ð²Ñ‹Ðµ ÑƒÐ²ÐµÐ»Ð¸Ñ‡Ð¸Ð²Ð°ÑŽÑ‚ÑÑ Ð² 10 Ñ€Ð°Ð·, Ð° Ð¿Ñ€Ð¸ Ð¾Ñ‚ÐºÑ€Ñ‹Ñ‚Ð¸Ð¸ Ð²Ñ‚Ð¾Ñ€Ð¾Ð¹ â€” Ð² 50.

ÐžÑ‚Ð²ÐµÑ‚ 29.4
boxMultiplier = [10, 50]
newOutcomes = pure (*) <*> doorPrize <*> boxMultiplier
GHCi> newOutcomes
[10000, 50000, 20000, 100000, 30000, 150000]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 29.7 ÐŸÑ€Ð¾ÑÑ‚Ð¾Ðµ Ð½ÐµÑÑ„Ñ„ÐµÐºÑ‚Ð¸Ð²Ð½Ð¾Ðµ Ð¿ÐµÑ€ÐµÑ‡Ð¸ÑÐ»ÐµÐ½Ð¸Ðµ Ð¿Ñ€Ð¾ÑÑ‚Ñ‹Ñ… Ñ‡Ð¸ÑÐµÐ»
primesToN :: Integer -> [Integer]
primesToN n = filter isNotComposite twoThroughN
  where twoThroughN = [2..n]
        composite = pure (*) <*> twoThroughN <*> twoThroughN
        isNotComposite = not . (â€˜elemâ€˜ composite)

GHCi> primesToN 32
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]

data User = User {
name :: String
, gamerId :: Int
, score :: Int
} deriving Show

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 29.8 Ð¡Ð¿Ð¸ÑÐ¾Ðº Ð¸Ð¼Ñ‘Ð½ testNames
testNames :: [String]
testNames = ["Ð”Ð¶Ð¾Ð½ Ð¡Ð¼Ð¸Ñ‚"
            , "Ð Ð¾Ð±ÐµÑ€Ñ‚â€™); DROP TABLE Students;--"
            , "ÐšÑ€Ð¸ÑÑ‚Ð¸Ð½Ð° NULL"
            , "Ð ÑÐ½Ð´Ð°Ð»Ð» ÐœÐ¾Ð½Ñ€Ð¾"]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 29.9 Ð¡Ð¿Ð¸ÑÐ¾Ðº ID testIds
testIds :: [Int]
testIds = [1337
           , 0123
           , 999999]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 29.10 Ð—Ð°Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½Ð½Ñ‹Ðµ Ð¸Ð³Ñ€Ð¾ÐºÐ°Ð¼Ð¸ Ð¾Ñ‡ÐºÐ¸ testScores
testScores :: [Int]
testScores = [0
              , 100000
              , -99999]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 29.11 Ð“ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ñ Ñ‚ÐµÑÑ‚Ð¾Ð²Ñ‹Ñ… Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¹
testData :: [User]
testData = pure User <*> testNames
                     <*> testIds
                     <*> testScores

GHCi> length testData
36
GHCi> take 3 testData
[User {name = "Ð”Ð¶Ð¾Ð½ Ð¡Ð¼Ð¸Ñ‚", gamerId = 1337, score = 0}
Ã‡,User {name = "Ð”Ð¶Ð¾Ð½ Ð¡Ð¼Ð¸Ñ‚", gamerId = 1337, score = 100000}
Ã‡,User {name = "Ð”Ð¶Ð¾Ð½ Ð¡Ð¼Ð¸Ñ‚", gamerId = 1337, score = -99999}]

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 29.5. Ð”Ð¾Ð±Ð°Ð²ÑŒÑ‚Ðµ ÑÐ¾Ð±ÑÑ‚Ð²ÐµÐ½Ð½Ð¾Ðµ Ð¸Ð¼Ñ Ðº testNames Ð¸ ÑÐ½Ð¾Ð²Ð° ÑÐ³ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐ¹Ñ‚Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ. 
Ð¡ÐºÐ¾Ð»ÑŒÐºÐ¾ Ð¿Ñ€Ð¸Ð¼ÐµÑ€Ð¾Ð² Ð±ÑƒÐ´ÐµÑ‚ ÑÐ¾Ð´ÐµÑ€Ð¶Ð°Ñ‚ÑŒ Ð¸Ñ‚Ð¾Ð³Ð¾Ð²Ñ‹Ð¹ ÑÐ¿Ð¸ÑÐ¾Ðº
Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¹?

ÐžÑ‚Ð²ÐµÑ‚ 29.5
testNames = ["Ð£Ð¸Ð»Ð» ÐšÑƒÑ€Ñ‚", "Ð”Ð¶Ð¾Ð½ Ð¡Ð¼Ð¸Ñ‚"
, "Ð Ð¾Ð±ÐµÑ€Ñ‚â€™); DROP TABLE Students;--"
, "ÐšÑ€Ð¸ÑÑ‚Ð¸Ð½Ð° NULL", "Ð ÑÐ½Ð´Ð°Ð»Ð» ÐœÐ¾Ð½Ñ€Ð¾"]
testData :: [User]
testData = pure User <*> testNames <*> testIds <*> testScores
GHCi> length testData
45

allFmap :: Applicative f => (a -> b) -> f a -> f b
GHCi> allFmap (+1) [1, 2, 3]
[2, 3, 4]
GHCi> allFmap (+1) (Just 5)
Just 6
GHCi> allFmap (+1) Nothing
Nothing

example :: Int
example = (*) ((+) 2 4) 6
exampleMaybe :: Maybe Int

Ð’Ð²ÐµÐ´ÐµÐ½Ð¸Ðµ Ð² ÐºÐ»Ð°ÑÑ Ñ‚Ð¸Ð¿Ð¾Ð² Monad
GHCi> (+ 2) <$> Just 3
Just 5
GHCi> pure (+) <*> Just 3 <*> Just 2
Just 5

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 30.1 ÐÐ°Ð¿Ð¾Ð¼Ð¸Ð½Ð°Ð½Ð¸Ðµ Ð¾ do-Ð½Ð¾Ñ‚Ð°Ñ†Ð¸Ð¸
main :: IO ()
main = do
  putStrLn "ÐŸÐ¾Ð¼Ð½Ð¸Ñ‚Ðµ Ð¾ do-Ð½Ð¾Ñ‚Ð°Ñ†Ð¸Ð¸!"
  putStrLn "ÐžÐ½Ð° Ð¼Ð½Ð¾Ð³Ð¾Ðµ ÑƒÐ¿Ñ€Ð¾Ñ‰Ð°ÐµÑ‚!"

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 30.2 Ð¢Ð¸Ð¿Ñ‹ Ð¸ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð´Ð»Ñ Ð·Ð°Ð´Ð°Ñ‡Ð¸ Ð¿Ð¾Ð¸ÑÐºÐ° Ð¿Ð¾ Ð´Ð²ÑƒÐ¼ Map
import qualified Data.Map as Map

type UserName = String
type GamerId = Int
type PlayerCredits = Int

userNameDB :: Map.Map GamerId UserName
userNameDB = Map.fromList [(1,"nYarlathoTep")
                            ,(2,"KINGinYELLOW")
                            ,(3,"dagon1997")
                            ,(4,"rcarter1919")
                            ,(5,"xCTHULHUx")
                            ,(6,"yogSOThoth")]

creditsDB :: Map.Map UserName PlayerCredits
creditsDB = Map.fromList [("nYarlathoTep",2000)
                          ,("KINGinYELLOW",15000)
                          ,("dagon1997",300)
                          ,("rcarter1919",12)
                          ,("xCTHULHUx",50000)
                          ,("yogSOThoth",150000)]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 30.3 Ð¢Ð¸Ð¿ Ñ†ÐµÐ»ÐµÐ²Ð¾Ð¹ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ creditsFromId
creditsFromId :: GamerId -> Maybe PlayerCredits

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 30.4 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ð¸ lookupUserName Ð¸ lookupCredits
lookupUserName :: GamerId -> Maybe UserName
lookupUserName id = Map.lookup id userNameDB

lookupCredits :: UserName -> Maybe PlayerCredits
lookupCredits username = Map.lookup username creditsDB

Maybe UserName -> (UserName -> Maybe PlayerCredits)
               -> Maybe PlayerCredits

Applicative f => f a -> (a -> f b) -> f b
(<$>) :: Functor f => (a -> b) -> f a -> f b
(<*>) :: Applicative f => f (a -> b) -> f a -> f b
pure :: Applicative f => a -> f a

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 30.5 Ð ÐµÑˆÐµÐ½Ð¸Ðµ Ð·Ð°Ð´Ð°Ñ‡Ð¸ Ð±ÐµÐ· Functor Ð¸Ð»Ð¸ Applicative
altLookupCredits :: Maybe UserName -> Maybe PlayerCredits
altLookupCredits Nothing = Nothing
altLookupCredits (Just username) = lookupCredits username

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 30.6 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ Ñ‚Ð¸Ð¿Ð° GamerId -> Maybe PlayerCredits
creditsFromId :: GamerId -> Maybe PlayerCredits
creditsFromId id = altLookupCredits (lookupUserName id)

GHCi> creditsFromId 1
Just 2000
GHCi> creditsFromId 100
Nothing

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 30.1. Ð˜Ð½Ñ‚ÐµÑ€ÐµÑÐ½Ð¾, Ñ‡Ñ‚Ð¾ ÑÐ»ÐµÐ´ÑƒÑŽÑ‰Ð°Ñ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ, Ð¿Ð¾Ñ…Ð¾Ð¶Ðµ, Ð´ÐµÐ»Ð°ÐµÑ‚
Ñ‚Ð¾, Ñ‡Ñ‚Ð¾ Ð²Ð°Ð¼ Ð½ÑƒÐ¶Ð½Ð¾, Ð¸ ÐºÐ¾Ð¼Ð¿Ð¸Ð»Ð¸Ñ€ÑƒÐµÑ‚ÑÑ ÐºÐ°Ðº Ð½Ð°Ð´Ð¾. Ð§Ñ‚Ð¾ Ñ Ð½ÐµÐ¹ Ð½Ðµ Ñ‚Ð°Ðº? (ÐŸÐ¾Ð´ÑÐºÐ°Ð·ÐºÐ°: Ð¿Ð¾ÑÐ¼Ð¾Ñ‚Ñ€Ð¸Ñ‚Ðµ Ð² GHCi ÐµÑ‘ Ñ‚Ð¸Ð¿.)
creditsFromIdStrange id = pure lookupCredits <*>
lookupUserName id

ÐžÑ‚Ð²ÐµÑ‚ 30.1. ÐŸÑ€Ð¾Ð±Ð»ÐµÐ¼Ð° ÑÑ‚Ð¾Ð¹ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ â€” Ð² Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰ÐµÐ½Ð¸Ð¸ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ Ñ‚Ð¸Ð¿Ð°
Maybe (Maybe PlayerCredits), Ñ‚Ð¾ ÐµÑÑ‚ÑŒ Ñ Ð²Ð»Ð¾Ð¶ÐµÐ½Ð½Ñ‹Ð¼Ð¸ Maybe!

ÐÐ°Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ Ð½Ðµ ÑÑ‚Ð¾Ð»ÑŒ Ñ‚Ñ€Ð¸Ð²Ð¸Ð°Ð»ÑŒÐ½Ð¾Ð³Ð¾ IO-Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ echo
getLine :: IO String
putStrLn :: String -> IO ()
IO String -> (String -> IO ()) -> IO ()
Applicative f => f a -> (a -> f b) -> f b

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 30.2. ÐŸÐ¾Ñ‡ÐµÐ¼Ñƒ Ð´Ð»Ñ Ñ€ÐµÑˆÐµÐ½Ð¸Ñ ÑÑ‚Ð¾Ð¹ Ð·Ð°Ð´Ð°Ñ‡Ð¸ Ð½ÐµÐ»ÑŒÐ·Ñ Ð½Ð°Ð¿Ð¸ÑÐ°Ñ‚ÑŒ
Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ Ð²Ñ€Ð¾Ð´Ðµ altLookupCredits Ð¸ creditsFromId Ð¸Ð· Ð¿Ñ€ÐµÐ´Ñ‹Ð´ÑƒÑ‰ÐµÐ³Ð¾
Ð¿ÑƒÐ½ÐºÑ‚Ð°?

ÐžÑ‚Ð²ÐµÑ‚ 30.2. Ð£ Ð²Ð°Ñ Ð½ÐµÑ‚ ÑÐ¿Ð¾ÑÐ¾Ð±Ð° Ð¿Ð¾Ð»ÑƒÑ‡Ð°Ñ‚ÑŒ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Ð±ÐµÐ· ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ð° IO,
ÐºÐ°Ðº Ð²Ñ‹ Ð´ÐµÐ»Ð°Ð»Ð¸ Ñ ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ð¾Ð¼ Maybe. Ð’Ð°Ð¼ Ð½ÑƒÐ¶Ð½Ñ‹ Ð±Ð¾Ð»ÐµÐµ Ð¼Ð¾Ñ‰Ð½Ñ‹Ðµ, Ñ‡ÐµÐ¼
Applicative Ð¸ Functor, Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹ Ð´Ð»Ñ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹ Ñ Ñ‚Ð¸Ð¿Ð°Ð¼Ð¸ IO.

(>>=) :: Monad m => m a -> (a -> m b) -> m b
Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 30.7 ÐÐ¾Ð²Ð°Ñ Ð²ÐµÑ€ÑÐ¸Ñ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ creditsFromId (Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ >>=)
creditsFromId :: GamerId -> Maybe PlayerCredits
creditsFromId id = lookupUserName id >>= lookupCredits
Ð’Ð¸Ð´Ð½Ð¾, Ñ‡Ñ‚Ð¾ >>= Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÐµÑ‚ ÑÐ¾ÐµÐ´Ð¸Ð½ÑÑ‚ÑŒ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ Ð²Ð¸Ð´Ð° (a -> m b).

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 30.8 Ð•Ñ‰Ñ‘ Ð¾Ð´Ð¸Ð½ Map Ð² Ð¿Ð¾Ð¸ÑÐºÐµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒÑÐºÐ¸Ñ… Ð´Ð°Ð½Ð½Ñ‹Ñ…
type WillCoId = Int

gamerIdDB :: Map.Map WillCoId GamerId
gamerIdDB = Map.fromList [(1001,1), (1002,2), (1003,3),
                          (1004,4), (1005,5), (1006,6)]

lookupGamerId :: WillCoId -> Maybe GamerId
lookupGamerId id = Map.lookup id gamerIdDB

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 30.9 Ð¡Ð²ÑÐ·Ñ‹Ð²Ð°Ð½Ð¸Ðµ Ñ‚Ñ€Ñ‘Ñ… Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹ Ð¿Ð¾Ð¸ÑÐºÐ° Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ >>=
creditsFromWCId :: WillCoId -> Maybe PlayerCredits
creditsFromWCId id = lookupGamerId id >>=
                     lookupUserName >>=
                     lookupCredits

GHCi> creditsFromWCId 1001
Just 2000
GHCi> creditsFromWCId 100
Nothing

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 30.10 Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ >>= Ð² Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ð¸ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ echo
echo :: IO ()
echo = getLine >>= putStrLn

main :: IO ()
main = echo

$ ghc echo.hs
$ ./echo
Hello World!
Hello World!

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 30.3. Ð¡Ð¾ÐµÐ´Ð¸Ð½Ð¸Ñ‚Ðµ ÑÑ‚Ð¸ Ð´Ð²Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ Ð² Ð¾Ð´Ð½Ð¾ IO-Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ:
readInt :: IO Int
readInt = read <$> getLine
printDouble :: Int -> IO ()
printDouble n = print (n*2)

ÐžÑ‚Ð²ÐµÑ‚ 30.3. Ð ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚ ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ñ: readInt >>= printDouble

Functor
fmap :: Functor f :: (a -> b) -> f a -> f b
(<$>) :: Functor f :: (a -> b) -> f a -> f b
Applicative
fmap :: Functor f :: (a -> b) -> f a -> f b
(<$>) :: Functor f :: (a -> b) -> f a -> f b
(<*>) :: Applicative f => f (a -> b) -> f a -> f b
pure :: Applicative f => a -> f a
Monad
fmap :: Functor f :: (a -> b) -> f a -> f b
(<$>) :: Functor f :: (a -> b) -> f a -> f b
(<*>) :: Applicative f => f (a -> b) -> f a -> f b
pure :: Applicative f => a -> f a
(>>=) :: Monad m => m a -> (a -> m b) -> m b
(>>) :: Monad m => m a -> m b -> m b
return :: Monad m => a -> m a
fail :: Monad m => String -> m a

Ð’Ð¾Ñ‚ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ ÐºÐ»Ð°ÑÑÐ° Ñ‚Ð¸Ð¿Ð¾Ð² Monad:
class Applicative m => Monad (m :: * -> *) where
  (>>=) :: m a -> (a -> m b) -> m b
  (>>) :: m a -> m b -> m b
  return :: a -> m a
  fail :: String -> m a

pure :: Applicative f => a -> f a
return :: Monad m => a -> m a

(>>) :: m a -> m b -> m b

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 30.11 ÐŸÑ€ÐµÐ¸Ð¼ÑƒÑ‰ÐµÑÑ‚Ð²Ð° >> Ð² Ñ€Ð°Ð·Ð³Ð¾Ð²Ð¾Ñ€Ñ‡Ð¸Ð²Ð¾Ð¹ Ð²ÐµÑ€ÑÐ¸Ð¸ echo
echoVerbose :: IO ()
echoVerbose = putStrLn "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÑÑ‚Ñ€Ð¾ÐºÑƒ, Ð° Ð¼Ñ‹ ÐµÑ‘ Ð¿Ð¾Ð²Ñ‚Ð¾Ñ€Ð¸Ð¼!" >>
              getLine >>= putStrLn
main :: IO ()
main = echoVerbose

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 30.12 IO-Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ askForName
askForName :: IO ()
askForName = putStrLn "ÐšÐ°Ðº Ð²Ð°Ñ Ð·Ð¾Ð²ÑƒÑ‚?"

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 30.13 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ Ð½Ð° ÑÑ‚Ñ€Ð¾ÐºÐ°Ñ… nameStatement
nameStatement :: String -> String
nameStatement name = "ÐŸÑ€Ð¸Ð²ÐµÑ‚, " ++ name ++ "!"

(askForName >> getLine)
(\name -> return (nameStatement name))

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 30.14 ÐŸÑ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ð°-Ð¿Ñ€Ð¸Ð²ÐµÑ‚ÑÑ‚Ð²Ð¸Ðµ Ñ Ð¼ÐµÑ‚Ð¾Ð´Ð°Ð¼Ð¸ ÐºÐ»Ð°ÑÑÐ° Monad
helloName :: IO ()
helloName = askForName >>
            getLine >>=
            (\name -> return (nameStatement name)) >>=
            putStrLn

GHCi> helloName
ÐšÐ°Ðº Ð²Ð°Ñ Ð·Ð¾Ð²ÑƒÑ‚?
Ð£Ð¸Ð»Ð»
ÐŸÑ€Ð¸Ð²ÐµÑ‚, Ð£Ð¸Ð»Ð»!

allFmapM :: Monad m => (a -> b) -> m a -> m b
allApp :: Monad m => m (a -> b) -> m a -> m b
bind :: Maybe a -> (a -> Maybe b) -> Maybe b

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 30.4. ÐŸÑ€ÐµÐ¾Ð±Ñ€Ð°Ð·ÑƒÐ¹Ñ‚Ðµ (+ 2) Ð¸Ð· Ñ‚Ð¸Ð¿Ð° Num a => a -> a Ð² Ñ‚Ð¸Ð¿
Num a => a -> IO a, Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÑ Ð»ÑÐ¼Ð±Ð´Ð°-Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ Ð¸ return. Ð’Ð¾ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚ÐµÑÑŒ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¾Ð¹ GHCi :t Ð¸ ÑƒÐ±ÐµÐ´Ð¸Ñ‚ÐµÑÑŒ, Ñ‡Ñ‚Ð¾ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ð»Ð¸ Ð²ÐµÑ€Ð½Ñ‹Ð¹ Ñ‚Ð¸Ð¿.
ÐžÑ‚Ð²ÐµÑ‚ 30.4. Ð›ÑÐ¼Ð±Ð´Ð°-Ð²Ñ‹Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ: (\n -> return ((+ 2) n)).

ÐžÐ±Ð»ÐµÐ³Ñ‡ÐµÐ½Ð¸Ðµ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹ Ñ Ð¼Ð¾Ð½Ð°Ð´Ð°Ð¼Ð¸ Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ
do-Ð½Ð¾Ñ‚Ð°Ñ†Ð¸Ð¸

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 31.1 ÐŸÑ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ð°-Ð¿Ñ€Ð¸Ð²ÐµÑ‚ÑÑ‚Ð²Ð¸Ðµ
askForName :: IO ()
askForName = putStrLn "ÐšÐ°Ðº Ñ‚ÐµÐ±Ñ Ð·Ð¾Ð²ÑƒÑ‚?"

nameStatement :: String -> String
nameStatement name = "ÐŸÑ€Ð¸Ð²ÐµÑ‚, " ++ name ++ " !"

helloName :: IO ()
helloName = askForName >>
            getLine >>=
            (\name ->
              return (nameStatement name)) >>=
            putStrLn

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 31.2 ÐŸÐµÑ€ÐµÐ¿Ð¸ÑÑ‹Ð²Ð°Ð½Ð¸Ðµ helloName Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ do-Ð½Ð¾Ñ‚Ð°Ñ†Ð¸Ð¸
helloNameDo :: IO ()
helloNameDo = do
   askForName
   name <- getLine
   putStrLn (nameStatement name)

helloName :: IO () askForName
helloName = askForName >> 
            getLine
            (\name ->
              return (nameStatement name)) >>=
            putStrLn


helloName :: IO ()
helloNameDo = do
   askForName
   name <- getLine
   putStrLn nameStatement

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 31.3 ÐŸÑ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ð°, Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÑŽÑ‰Ð°Ñ do-Ð½Ð¾Ñ‚Ð°Ñ†Ð¸ÑŽ
helloPerson :: String -> String
helloPerson name = "ÐŸÑ€Ð¸Ð²ÐµÑ‚," ++ " " ++ name ++ "!"

main :: IO ()
main = do
   name <- getLine
   let statement = helloPerson name
   putStrLn statement

main :: IO ()
main = do
       name <- getLine
       let statement = helloPerson name
       putStrLn statement

main :: IO ()
main = getLine >>=
  (\name ->
   (\statement ->
      putStrLn statement) (helloPerson name))

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 31.4 IO-Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ, Ð´Ð»Ñ ÐºÐ¾Ñ‚Ð¾Ñ€Ð¾Ð³Ð¾ >>= Ð¿Ñ€ÐµÐ´Ð¿Ð¾Ñ‡Ñ‚Ð¸Ñ‚ÐµÐ»ÑŒÐ½ÐµÐµ
echo :: IO ()
echo = getLine >>= putStrLn

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 31.1. ÐŸÐµÑ€ÐµÐ¿Ð¸ÑˆÐ¸Ñ‚Ðµ echo Ñ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸ÐµÐ¼ do-Ð½Ð¾Ñ‚Ð°Ñ†Ð¸Ð¸
ÐžÑ‚Ð²ÐµÑ‚ 31.1
echo :: IO ()
echo = do
  val <- getLine
  putStrLn val

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 31.5 Ð¢Ð¸Ð¿ Ð´Ð°Ð½Ð½Ñ‹Ñ… Grade Ð´Ð»Ñ Ð¾Ñ†ÐµÐ½ÐºÐ¸ ÑÑ‚Ð°Ð¿Ð¾Ð² ÑÐ¾Ð±ÐµÑÐµÐ´Ð¾Ð²Ð°Ð½Ð¸Ñ
data Grade = F | D | C | B | A
   deriving (Eq, Ord, Enum, Show, Read)

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 31.6 Ð¢Ð¸Ð¿ Ð´Ð°Ð½Ð½Ñ‹Ñ… Degree Ð´Ð»Ñ ÑƒÑ€Ð¾Ð²Ð½Ñ Ð¾Ð±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¸Ñ
data Degree = HS | BA | MS | PhD
  deriving (Eq, Ord, Enum, Show, Read)

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 31.7 ÐŸÑ€ÐµÐ´ÑÑ‚Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð¾Ð² ÑÐ¾Ð±ÐµÑÐµÐ´Ð¾Ð²Ð°Ð½Ð¸Ñ
data Candidate = Candidate
   { candidateId :: Int
     , codeReview :: Grade
     , cultureFit :: Grade
     , education :: Degree } deriving Show

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 31.8 ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð½Ð° ÑÐ¾Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²Ð¸Ðµ Ð¼Ð¸Ð½Ð¸Ð¼Ð°Ð»ÑŒÐ½Ñ‹Ð¼ Ñ‚Ñ€ÐµÐ±Ð¾Ð²Ð°Ð½Ð¸ÑÐ¼
viable :: Candidate -> Bool
viable candidate = all (== True) tests
   where passedCoding = codeReview candidate > B
         passedCultureFit = cultureFit candidate > C
         educationMin = education candidate >= MS
         tests = [passedCoding, passedCultureFit, educationMin]

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 31.2. Ð¡Ð¾Ð·Ð´Ð°Ð¹Ñ‚Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Ñ‚Ð¸Ð¿Ð° Candidate Ð¸ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑŒÑ‚Ðµ ÐµÐ³Ð¾
Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ viable.

ÐžÑ‚Ð²ÐµÑ‚ 31.2
testCandidate :: Candidate
testCandidate = Candidate
   { candidateId = 1
     , codeReview = A
     , cultureFit = A
     , education = PhD}

GHCi> viable testCandidate
True

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 31.9 Ð¡Ñ‡Ð¸Ñ‚Ñ‹Ð²Ð°Ð½Ð¸Ðµ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¾ ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ðµ
readInt :: IO Int
readInt = getLine >>= (return . read)

readGrade :: IO Grade
readGrade = getLine >>= (return . read)

readDegree :: IO Degree
readDegree = getLine >>= (return . read)

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 31.10 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ readCandidate
readCandidate :: IO Candidate
readCandidate = do
  putStrLn "Ð²Ð²ÐµÐ´Ð¸Ñ‚Ðµ id:"
  cId <- readInt
  putStrLn "Ð²Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¾Ñ†ÐµÐ½ÐºÑƒ ÐºÐ¾Ð´-Ñ€ÐµÐ²ÑŒÑŽ:"
  codeGrade <- readGrade
  putStrLn "Ð²Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¾Ñ†ÐµÐ½ÐºÑƒ ÑÐ¾Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²Ð¸Ñ ÐºÐ¾Ñ€Ð¿Ð¾Ñ€Ð°Ñ‚Ð¸Ð²Ð½Ð¾Ð¹ ÐºÑƒÐ»ÑŒÑ‚ÑƒÑ€Ðµ"
  cultureGrade <- readGrade
  putStrLn "Ð²Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÑƒÑ€Ð¾Ð²ÐµÐ½ÑŒ Ð¾Ð±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¸Ñ:"
  degree <- readDegree
  return (Candidate { candidateId = cId, codeReview = codeGrade
                      , cultureFit = cultureGrade
                      , education = degree })

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 31.11 Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ Ð²Ð²Ð¾Ð´Ð°-Ð²Ñ‹Ð²Ð¾Ð´Ð° Ð´Ð»Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸ ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ð°
assessCandidateIO :: IO String
assessCandidateIO = do
    candidate <- readCandidate
    let passed = viable candidate
    let statement = if passed
                    then "Ð¿Ñ€Ð¾ÑˆÑ‘Ð»"
                    else "Ð¿Ñ€Ð¾Ð²Ð°Ð»Ð¸Ð»ÑÑ"
    return statement

GHCi> assessCandidateIO
Ð²Ð²ÐµÐ´Ð¸Ñ‚Ðµ id:
1
Ð²Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¾Ñ†ÐµÐ½ÐºÑƒ ÐºÐ¾Ð´-Ñ€ÐµÐ²ÑŒÑŽ:
A
Ð²Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¾Ñ†ÐµÐ½ÐºÑƒ ÑÐ¾Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²Ð¸Ñ ÐºÐ¾Ñ€Ð¿Ð¾Ñ€Ð°Ñ‚Ð¸Ð²Ð½Ð¾Ð¹ ÐºÑƒÐ»ÑŒÑ‚ÑƒÑ€Ðµ:
B
Ð²Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÑƒÑ€Ð¾Ð²ÐµÐ½ÑŒ Ð¾Ð±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¸Ñ:
PhD
"Ð¿Ñ€Ð¾ÑˆÑ‘Ð»"

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 31.3. ÐŸÐµÑ€ÐµÐ¿Ð¸ÑˆÐ¸Ñ‚Ðµ readGrade Ñ Ð¿Ñ€Ð¸Ð¼ÐµÐ½ÐµÐ½Ð¸ÐµÐ¼ do-Ð½Ð¾Ñ‚Ð°Ñ†Ð¸Ð¸.
ÐžÑ‚Ð²ÐµÑ‚ 31.3
readGradeDo :: IO Grade
readGradeDo = do
  input <- getLine
  return (read input)

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 31.12 ÐÐµÑÐºÐ¾Ð»ÑŒÐºÐ¾ ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ð¾Ð²
candidate1 :: Candidate
candidate1 = Candidate { candidateId = 1, codeReview = A
                         , cultureFit = A, education = BA}
candidate2 :: Candidate
candidate2 = Candidate { candidateId = 2, codeReview = C
                         , cultureFit = A, education = PhD}
candidate3 :: Candidate
candidate3 = Candidate { candidateId = 3, codeReview = A
                        , cultureFit = B, education = MS}

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 31.13 Ð‘Ð°Ð·Ð° Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¾ ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ð°Ñ…
candidateDB :: Map.Map Int Candidate
candidateDB = Map.fromList [ (1, candidate1), (2, candidate2)
                             , (3, candidate3)]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 31.14 ÐžÑ†ÐµÐ½ÐºÐ° ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ð¾Ð² Ð² ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ðµ Maybe
assessCandidateMaybe :: Int -> Maybe String
assessCandidateMaybe cId = do
     candidate <- Map.lookup cId candidateDB
     let passed = viable candidate
     let statement = if passed
                     then "Ð¿Ñ€Ð¾ÑˆÑ‘Ð»"
                     else "Ð¿Ñ€Ð¾Ð²Ð°Ð»Ð¸Ð»ÑÑ"
     return statement


GHCi> assessCandidateMaybe 1
Just "Ð¿Ñ€Ð¾Ð²Ð°Ð»Ð¸Ð»ÑÑ"
GHCi> assessCandidateMaybe 3
Just "Ð¿Ñ€Ð¾ÑˆÑ‘Ð»"
GHCi> assessCandidateMaybe 4
Nothing

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 31.4. ÐÐ°Ð¿Ð¸ÑˆÐ¸Ñ‚Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ Ñ‚Ð¸Ð¿Ð° Maybe String -> String,
Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÑŽÑ‰ÑƒÑŽ "Ð¿Ñ€Ð¾ÑˆÑ‘Ð»" Ð¸Ð»Ð¸ "Ð¿Ñ€Ð¾Ð²Ð°Ð»Ð¸Ð»ÑÑ", ÐµÑÐ»Ð¸ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Ð¿Ñ€Ð¸ÑÑƒÑ‚ÑÑ‚Ð²ÑƒÐµÑ‚, Ð¸ "Ð¾ÑˆÐ¸Ð±ÐºÐ°: id Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½" â€” Ð² Ð¿Ñ€Ð¾Ñ‚Ð¸Ð²Ð½Ð¾Ð¼ ÑÐ»ÑƒÑ‡Ð°Ðµ.

ÐžÑ‚Ð²ÐµÑ‚ 31.4
failPassOrElse :: Maybe String -> String
failPassOrElse Nothing = "Ð¾ÑˆÐ¸Ð±ÐºÐ°: id Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½"
failPassOrElse (Just val) = val

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 31.15 Ð¡Ð¿Ð¸ÑÐ¾Ðº Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ñ‹Ñ… ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ð¾Ð²
candidates :: [Candidate]
candidates = [candidate1, candidate2, candidate3]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 31.16 ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ð¾Ð² Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ ÑÐ¿Ð¸ÑÐºÐ° ÐºÐ°Ðº Ð¼Ð¾Ð½Ð°Ð´Ñ‹
assessCandidatesList :: [Candidate] -> [String]
assessCandidateList candidates = do
   candidate <- candidates
   let passed = viable candidate
   let statement = if passed
                   then "Ð¿Ñ€Ð¾ÑˆÑ‘Ð»"
                   else "Ð¿Ñ€Ð¾Ð²Ð°Ð»Ð¸Ð»ÑÑ"
   return statement

GHCi> assessCandidateList candidates
["Ð¿Ñ€Ð¾Ð²Ð°Ð»Ð¸Ð»ÑÑ", "Ð¿Ñ€Ð¾Ð²Ð°Ð»Ð¸Ð»ÑÑ", "Ð¿Ñ€Ð¾ÑˆÑ‘Ð»"]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 31.17 Ð¡Ð¿ÐµÑ†Ð¸Ñ„Ð¸Ñ‡Ð½Ñ‹Ð¹ ÑÐ¿Ð¾ÑÐ¾Ð± Ð¾Ñ†ÐµÐ½ÐºÐ¸ ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ð¾Ð² Ð² ÑÐ¿Ð¸ÑÐºÐµ
assessCandidates :: [Candidate] -> [String]
assessCandidates candidates =
    map (\x -> if x
               then "Ð¿Ñ€Ð¾ÑˆÑ‘Ð»"
               else "Ð¿Ñ€Ð¾Ð²Ð°Ð»Ð¸Ð»ÑÑ") passed
  where passed = map viable candidates

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 31.5. Ð Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ Ð»Ð¸ assessCandidateList Ñ Ð¿ÑƒÑÑ‚Ñ‹Ð¼ ÑÐ¿Ð¸ÑÐºÐ¾Ð¼?
ÐžÑ‚Ð²ÐµÑ‚ 31.5. Ð Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚! Ð•ÑÐ»Ð¸ Ð²Ñ‹Ð·Ð²Ð°Ñ‚ÑŒ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ assessCandidateList
Ñ Ð¿ÑƒÑÑ‚Ñ‹Ð¼ ÑÐ¿Ð¸ÑÐºÐ¾Ð¼ Ð² ÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ðµ Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ð°, Ñ‚Ð¾ Ð¼Ñ‹ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ð¼ Ð¿ÑƒÑÑ‚Ð¾Ð¹ ÑÐ¿Ð¸ÑÐ¾Ðº

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 31.18 ÐœÐ¾Ð½Ð°Ð´Ð¸Ñ‡ÐµÑÐºÐ°Ñ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ Ð´Ð»Ñ IO, Maybe Ð¸ ÑÐ¿Ð¸ÑÐºÐ°
assessCandidate :: Monad m => m Candidate -> m String
assessCandidate candidates = do
   candidate <- candidates
   let passed = viable candidate
   let statement = if passed
                   then "Ð¿Ñ€Ð¾ÑˆÑ‘Ð»"
                   else "Ð¿Ñ€Ð¾Ð²Ð°Ð»Ð¸Ð»ÑÑ"
   return statement

GHCi> assessCandidate readCandidate
Ð²Ð²ÐµÐ´Ð¸Ñ‚Ðµ id:
1
Ð²Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¾Ñ†ÐµÐ½ÐºÑƒ ÐºÐ¾Ð´-Ñ€ÐµÐ²ÑŒÑŽ:
A
Ð²Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¾Ñ†ÐµÐ½ÐºÑƒ ÑÐ¾Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²Ð¸Ñ ÐºÐ¾Ñ€Ð¿Ð¾Ñ€Ð°Ñ‚Ð¸Ð²Ð½Ð¾Ð¹ ÐºÑƒÐ»ÑŒÑ‚ÑƒÑ€Ðµ:
B
Ð²Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¾Ð±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¸Ðµ:
PhD
"Ð¿Ñ€Ð¾ÑˆÑ‘Ð»"
GHCi> assessCandidate (Map.lookup 1 candidateDB)
Just "Ð¿Ñ€Ð¾Ð²Ð°Ð»Ð¸Ð»ÑÑ"
GHCi> assessCandidate (Map.lookup 2 candidateDB)
Just "Ð¿Ñ€Ð¾Ð²Ð°Ð»Ð¸Ð»ÑÑ"
GHCi> assessCandidate (Map.lookup 3 candidateDB)
Just "Ð¿Ñ€Ð¾ÑˆÑ‘Ð»"
GHCi> assessCandidate candidates
["Ð¿Ñ€Ð¾Ð²Ð°Ð»Ð¸Ð»ÑÑ", "Ð¿Ñ€Ð¾Ð²Ð°Ð»Ð¸Ð»ÑÑ", "Ð¿Ñ€Ð¾ÑˆÑ‘Ð»"]

main :: IO ()
main = do
  putStrLn "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ñ€Ð°Ð·Ð¼ÐµÑ€ Ð¿ÐµÑ€Ð²Ð¾Ð¹ Ð¿Ð¸Ñ†Ñ†Ñ‹"
  size1 <- getLine
  putStrLn "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÑÑ‚Ð¾Ð¸Ð¼Ð¾ÑÑ‚ÑŒ Ð¿ÐµÑ€Ð²Ð¾Ð¹ Ð¿Ð¸Ñ†Ñ†Ñ‹"
  cost1 <- getLine
  putStrLn "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ñ€Ð°Ð·Ð¼ÐµÑ€ Ð²Ñ‚Ð¾Ñ€Ð¾Ð¹ Ð¿Ð¸Ñ†Ñ†Ñ‹"
  size2 <- getLine
  putStrLn "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÑÑ‚Ð¾Ð¸Ð¼Ð¾ÑÑ‚ÑŒ Ð²Ñ‚Ð¾Ñ€Ð¾Ð¹ Ð¿Ð¸Ñ†Ñ†Ñ‹"
  cost2 <- getLine
  let pizza1 = (read size1, read cost1)
  let pizza2 = (read size2, read cost2)
  let betterPizza = comparePizzas pizza1 pizza2
  putStrLn (describePizza betterPizza)

maybeMain :: Maybe String
maybeMain = do
  size1 <- Map.lookup 1 sizeData
  cost1 <- Map.lookup 1 costData
  size2 <- Map.lookup 2 sizeData
  cost2 <- Map.lookup 2 costData
  let pizza1 = (size1, cost1)
  let pizza2 = (size2, cost2)
  let betterPizza = comparePizzas pizza1 pizza2
  return (describePizza betterPizza)

ÐœÐ¾Ð½Ð°Ð´Ð° ÑÐ¿Ð¸ÑÐºÐ° Ð¸ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ñ‹ ÑÐ¿Ð¸ÑÐºÐ¾Ð²
Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 32.1 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ assessCandidateList Ð¸Ð· Ð¿Ñ€ÐµÐ´Ñ‹Ð´ÑƒÑ‰ÐµÐ³Ð¾ ÑƒÑ€Ð¾ÐºÐ°

assessCandidateList :: [Candidate] -> [String]
assessCandidateList candidates = do
  candidate <- candidates
  let passed = viable candidate
  let statement = if passed
                  then "passed"
                  else "failed"
  return statement

GHCi> pure (*) <*> [1 .. 4] <*> [5,6,7]
[5,6,7,10,12,14,15,18,21,20,24,28]

GHCi> powersOfTwo 10
[2,4,8,16,32,64,128,256,512,1024]

powersOfTwoMap :: Int -> [Int]
powersOfTwoMap n = map (\x -> 2^x) [1 .. n]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 32.2 Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ ÑÐ¿Ð¸ÑÐºÐ° Ð¿Ð°Ñ€ Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ do-Ð½Ð¾Ñ‚Ð°Ñ†Ð¸Ð¸
powersOfTwoAndThree :: Int -> [(Int,Int)]
powersOfTwoAndThree n = do
  value <- [1 .. n]
  let powersOfTwo = 2^value
  let powersOfThree = 3^value
  return (powersOfTwo,powersOfThree)

GHCi> powersOfTwoAndThree 5
[(2,3),(4,9),(8,27),(16,81),(32,243)]

allEvenOdds :: Int -> [(Int,Int)]
allEvenOdds n = do
   evenValue <- [2,4 .. n]
   oddValue <- [1,3 .. n]
   return (evenValue,oddValue)

GHCi> allEvenOdds 5
[(2,1),(2,3),(2,5),(4,1),(4,3),(4,5)]
GHCi> allEvenOdds 6
[(2,1),(2,3),(2,5),(4,1),(4,3),(4,5),(6,1),(6,3),(6,5)]

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 32.1. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ do-Ð½Ð¾Ñ‚Ð°Ñ†Ð¸ÑŽ, Ñ‡Ñ‚Ð¾Ð±Ñ‹ ÑÐ³ÐµÐ½ÐµÑ€Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ ÑÐ¿Ð¸ÑÐ¾Ðº Ð¿Ð°Ñ€ Ñ‡Ð¸ÑÐµÐ» Ð¾Ñ‚ 1 Ð´Ð¾ 10 Ð¸ Ð¸Ñ… ÐºÐ²Ð°Ð´Ñ€Ð°Ñ‚Ð¾Ð².
ÐžÑ‚Ð²ÐµÑ‚ 32.1
valAndSquare :: [(Int,Int)]
valAndSquare = do
  val <- [1 .. 10]
  return (val, val^2)

Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ guard
evensGuard :: Int -> [Int]
evensGuard n = do
   value <- [1 .. n]
   guard (even value)
   return value

guard :: Alternative f => Bool -> f()
ÐšÐ»Ð°ÑÑ Ñ‚Ð¸Ð¿Ð¾Ð² Alternative â€” ÑÑ‚Ð¾ Ð¿Ð¾Ð´ÐºÐ»Ð°ÑÑ Applicative

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 32.2. Ð ÐµÐ°Ð»Ð¸Ð·ÑƒÐ¹Ñ‚Ðµ filter, Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÑ guard Ð¸ do-Ð½Ð¾Ñ‚Ð°Ñ†Ð¸ÑŽ.
ÐžÑ‚Ð²ÐµÑ‚ 32.2
guardFilter :: (a -> Bool) -> [a] -> [a]
guardFilter test vals = do
    val <- vals
    guard (test val)
    return val

Ð“ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ñ‹ ÑÐ¿Ð¸ÑÐºÐ¾Ð²
Python> [n**2 for n in range(10)]
[1, 2, 4, 8, 16, 32, 64, 128, 256, 512]

Python> [n**2 for n in range(10) if n**2 \% 2 == 0]
[0, 4, 16, 36, 64]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 32.3 Ð­Ð¼ÑƒÐ»ÑÑ†Ð¸Ñ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð¾Ð² ÑÐ¿Ð¸ÑÐºÐ¾Ð² Ð¸Ð· Python
evenSquares :: [Int]
evenSquares = do
   n <- [0 .. 9]
   let nSquared = n^2
   guard (even nSquared)
   return nSquared

powersOfTwo :: Int -> [Int]
powersOfTwo n = do
   value <- [1 .. n]
   return (2^value)

powersOfTwo :: Int -> [Int]
powersOfTwo n = [2^value | value <- [1 .. n]]

powersOfTwoAndThree :: Int -> [(Int,Int)]
powersOfTwoAndThree n =
   [(powersOfTwo,powersOfThree)
    | value <- [1 .. n]
    , let powersOfTwo = 2^value
    , let powersOfThree = 3^value]

allEvenOdds :: Int -> [(Int,Int)]
allEvenOdds n = [ (evenValue, oddValue)
                  | evenValue <- [2,4 .. n]
                  , oddValue <- [1,3 .. n]]

evensGuard :: Int -> [Int]
evensGuard n = [ value | value <- [1 .. n], even value]

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 32.3. ÐÐ°Ð¿Ð¸ÑˆÐ¸Ñ‚Ðµ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€ ÑÐ¿Ð¸ÑÐºÐ°, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¹ Ð±ÐµÑ€Ñ‘Ñ‚ ÑÐ»Ð¾Ð²Ð° Ð¸Ð·
ÑÐ»ÐµÐ´ÑƒÑŽÑ‰ÐµÐ³Ð¾ ÑÐ¿Ð¸ÑÐºÐ°, Ð´ÐµÐ»Ð°ÐµÑ‚ Ð¿ÐµÑ€Ð²ÑƒÑŽ Ð±ÑƒÐºÐ²Ñƒ Ð·Ð°Ð³Ð»Ð°Ð²Ð½Ð¾Ð¹ Ð¸ Ð´Ð¾Ð±Ð°Ð²Ð»ÑÐµÑ‚ Ð² Ð½Ð°Ñ‡Ð°Ð»Ð¾ ÑÑ‚Ñ€Ð¾ÐºÐ¸ "Ð“-Ð½ ":
["ÐºÐ¾Ñ€Ð¸Ñ‡Ð½ÐµÐ²Ñ‹Ð¹","ÑÐ¸Ð½Ð¸Ð¹","Ñ€Ð¾Ð·Ð¾Ð²Ñ‹Ð¹","Ð¾Ñ€Ð°Ð½Ð¶ÐµÐ²Ñ‹Ð¹"]
(ÐŸÐ¾Ð´ÑÐºÐ°Ð·ÐºÐ°: Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ toUpper Ð¸Ð· Data.Char.)

ÐžÑ‚Ð²ÐµÑ‚ 32.3
import Data.Char
answer :: [String]
answer = ["Ð“-Ð½ " ++ capVal |
          val <- ["ÐºÐ¾Ñ€Ð¸Ñ‡Ð½ÐµÐ²Ñ‹Ð¹","ÑÐ¸Ð½Ð¸Ð¹","Ñ€Ð¾Ð·Ð¾Ð²Ñ‹Ð¹","Ð¾Ñ€Ð°Ð½Ð¶ÐµÐ²Ñ‹Ð¹"]
          ,let capVal = (\(x:xs) -> toUpper x:xs) val]

Ð˜Ñ‚Ð¾Ð³Ð¾Ð²Ñ‹Ð¹ Ð¿Ñ€Ð¾ÐµÐºÑ‚: SQL-Ð¿Ð¾Ð´Ð¾Ð±Ð½Ñ‹Ðµ Ð·Ð°Ð¿Ñ€Ð¾ÑÑ‹ Ð² Haskell

select teacherName from
teacher inner join course
on teacher.id = course.teacherId
where course.title = "ÐÐ½Ð³Ð»Ð¸Ð¹ÑÐºÐ¸Ð¹ ÑÐ·Ñ‹Ðº";

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 33.1 Ð¢Ð¸Ð¿ Name Ñ ÑÐºÐ·ÐµÐ¼Ð¿Ð»ÑÑ€Ð¾Ð¼ Show
data Name = Name { firstName ::String
                   , lastName :: String }
instance Show Name where
   show (Name first last) = mconcat [first," ",last]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 33.2 Ð¢Ð¸Ð¿ GradeLevel Ð¿Ñ€ÐµÐ´ÑÑ‚Ð°Ð²Ð»ÑÐµÑ‚ ÑÑ‚ÑƒÐ¿ÐµÐ½ÑŒ Ð¾Ð±ÑƒÑ‡ÐµÐ½Ð¸Ñ
data GradeLevel = Freshman
                 | Sophmore
                 | Junior
                 | Senior deriving (Eq,Ord,Enum,Show)

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 33.3 Ð¢Ð¸Ð¿ Student
data Student = Student
        { studentId :: Int
          , gradeLevel :: GradeLevel
          , studentName :: Name } deriving Show

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 33.4 Ð¢ÐµÑÑ‚Ð¾Ð²Ñ‹Ð¹ ÑÐ¿Ð¸ÑÐ¾Ðº ÑÑ‚ÑƒÐ´ÐµÐ½Ñ‚Ð¾Ð²
students :: [Student]
students = [(Student 1 Senior (Name "ÐžÐ´Ñ€Ð¸" "Ð›Ð¾Ñ€Ð´"))
             ,(Student 2 Junior (Name "Ð›ÐµÑÐ»Ð¸" "Ð¡Ð¸Ð»ÐºÐ¾"))
             ,(Student 3 Freshman (Name "Ð”Ð¶ÑƒÐ´Ð¸Ñ‚" "Ð‘Ð°Ñ‚Ð»ÐµÑ€"))
             ,(Student 4 Senior (Name "Ð“Ð¸" "Ð”ÐµÐ±Ð¾Ñ€"))
             ,(Student 5 Sophmore (Name "Ð–Ð°Ð½" "Ð‘Ð¾Ð´Ñ€Ð¸Ð¹ÑÑ€"))
             ,(Student 6 Junior (Name "Ð®Ð»Ð¸Ñ" "ÐšÑ€Ð¸ÑÑ‚ÐµÐ²Ð°"))]

Ð¢Ð¸Ð¿ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ select
(a -> b) -> [a] -> [b]
Ð¢Ð¸Ð¿ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ where
(a -> Bool) -> [a] -> [a]

Eq c => [a] -> [b] -> (a -> c) -> (b -> c) -> [(a,b)]

select studentName from students;
select * from students where gradeLevel = â€™Seniorâ€™;

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 33.5 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ _select â€” ÑÑ‚Ð¾ Ñ‚Ð° Ð¶Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ fmap
_select :: (a -> b) -> [a] -> [b]
_select prop vals = do
   val <- vals
   return (prop val)

GHCi> _select (firstName . studentName) students
["ÐžÐ´Ñ€Ð¸","Ð›ÐµÑÐ»Ð¸","Ð”Ð¶ÑƒÐ´Ð¸Ñ‚","Ð“Ð¸","Ð–Ð°Ð½","Ð®Ð»Ð¸Ñ"]
GHCi> _select gradeLevel students
[Senior,Junior,Freshman,Senior,Sophmore,Junior]

GHCi> _select (\x -> (studentName x, gradeLevel x)) students
[(ÐžÐ´Ñ€Ð¸ Ð›Ð¾Ñ€Ð´,Senior),(Ð›ÐµÑÐ»Ð¸ Ð¡Ð¸Ð»ÐºÐ¾,Junior),
Ã‡ (Ð”Ð¶ÑƒÐ´Ð¸Ñ‚ Ð‘Ð°Ñ‚Ð»ÐµÑ€,Freshman),(Ð“Ð¸ Ð”ÐµÐ±Ð¾Ñ€,Senior),
Ã‡ (Ð–Ð°Ð½ Ð‘Ð¾Ð´Ñ€Ð¸Ð¹ÑÑ€,Sophmore),(Ð®Ð»Ð¸Ñ ÐšÑ€Ð¸ÑÑ‚ÐµÐ²Ð°,Junior)]


Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 33.6 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ _where Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÐµÑ‚ Ñ„Ð¸Ð»ÑŒÑ‚Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð·Ð°Ð¿Ñ€Ð¾ÑÑ‹
_where :: (a -> Bool) -> [a] -> [a]
_where test vals = do
   val <- vals
   guard (test val)
   return val

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 33.7 ÐŸÑ€Ð¸Ð¼ÐµÑ€ Ð¿Ñ€ÐµÐ´Ð¸ÐºÐ°Ñ‚Ð° Ð´Ð»Ñ _where
startsWith :: Char -> String -> Bool
startsWith char string = char == (head string)

GHCi> _where (startsWith â€™Ð‘â€™ . lastName) (_select studentName
                                          Ã‡ students)
[Ð”Ð¶ÑƒÐ´Ð¸Ñ‚ Ð‘Ð°Ñ‚Ð»ÐµÑ€,Ð–Ð°Ð½ Ð‘Ð¾Ð´Ñ€Ð¸Ð¹ÑÑ€]

Ð¡Ð¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ Ñ‚Ð¸Ð¿Ð¾Ð² Ð´Ð°Ð½Ð½Ñ‹Ñ… Course Ð¸ Teacher
Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 33.8 Ð¢Ð¸Ð¿ Teacher
data Teacher = Teacher
  { teacherId :: Int
    , teacherName :: Name } deriving Show

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 33.9 Ð¡Ð¿Ð¸ÑÐ¾Ðº Ð¿Ñ€ÐµÐ¿Ð¾Ð´Ð°Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¹
teachers :: [Teacher]
teachers = [Teacher 100 (Name "Ð¡Ð¸Ð¼Ð¾Ð½Ð°" "Ð´Ðµ Ð‘Ð¾Ð²ÑƒÐ°Ñ€")
            ,Teacher 200 (Name "Ð¡ÑŒÑŽÐ·ÐµÐ½" "Ð—Ð¾Ð½Ñ‚Ð°Ð³")]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 33.10 Ð¢Ð¸Ð¿ Course
data Course = Course { courseId :: Int
                       , courseTitle :: String
                       , teacher :: Int } deriving Show

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 33.11 Ð¡Ð¿Ð¸ÑÐ¾Ðº ÐºÑƒÑ€ÑÐ¾Ð²
courses :: [Course]
courses = [Course 101 "Ð¤Ñ€Ð°Ð½Ñ†ÑƒÐ·ÑÐºÐ¸Ð¹ ÑÐ·Ñ‹Ðº" 100
           ,Course 201 "ÐÐ½Ð³Ð»Ð¸Ð¹ÑÐºÐ¸Ð¹ ÑÐ·Ñ‹Ðº" 200]

select * from
teachers inner join courses
on (teachers.teacherId = courses.teacher);

_join :: Eq c => [a] -> [b] -> (a -> c) -> (b -> c) -> [(a,b)]

_join data1 data2 prop1 prop2 = do
  d1 <- data1
  d2 <- data2
  let dpairs = (d1,d2)
  guard ((prop1 (fst dparis)) == (prop2 (snd dpairs)))
  return dpairs

GHCi> _join teachers courses teacherId teacher
[(Teacher {teacherId = 100, teacherName = Ð¡Ð¸Ð¼Ð¾Ð½Ð° Ð´Ðµ Ð‘Ð¾Ð²ÑƒÐ°Ñ€},
Ã‡ Course {courseId = 101, courseTitle = "Ð¤Ñ€Ð°Ð½Ñ†ÑƒÐ·ÑÐºÐ¸Ð¹ ÑÐ·Ñ‹Ðº",
Ã‡ teacher = 100}), (Teacher {teacherId = 200,
Ã‡ teacherName = Ð¡ÑŒÑŽÐ·ÐµÐ½ Ð—Ð¾Ð½Ñ‚Ð°Ð³},Course {courseId = 201,
Ã‡ courseTitle = "ÐÐ½Ð³Ð»Ð¸Ð¹ÑÐºÐ¸Ð¹ ÑÐ·Ñ‹Ðº", teacher = 200})]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 33.12 ÐŸÑ€Ð¸Ð¼ÐµÑ€ ÑÐ¾Ð²Ð¼ÐµÑ‰ÐµÐ½Ð¸Ñ _join, _select Ð¸ _where
joinData = (_join teachers courses teacherId teacher)
whereResult = _where ((== "ÐÐ½Ð³Ð»Ð¸Ð¹ÑÐºÐ¸Ð¹ ÑÐ·Ñ‹Ðº") . courseTitle
                                             . snd) joinData
selectResult = _select (teacherName . fst) whereResult

(_select (teacherName . fst))
(_join teachers courses teacherId teacher)
(_where ((== "ÐÐ½Ð³Ð»Ð¸Ð¹ÑÐºÐ¸Ð¹ ÑÐ·Ñ‹Ðº") .courseTitle . snd))

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 33.13 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ _hinq Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÐµÑ‚ Ð¿ÐµÑ€ÐµÑÑ‚Ñ€Ð¾Ð¸Ñ‚ÑŒ Ñ‚ÐµÐºÑÑ‚ Ð·Ð°Ð¿Ñ€Ð¾ÑÐ°
_hinq selectQuery joinQuery whereQuery =
  (\joinData ->
    (\whereResult ->
       selectQuery whereResult)
    (whereQuery joinData)
  ) joinQuery

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 33.14 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ _hinq ÐºÐ°Ðº Ð¿Ñ€Ð¸Ð±Ð»Ð¸Ð¶ÐµÐ½Ð¸Ðµ Haskell Ðº SQL
finalResult :: [Name]
finalResult =
_hinq (_select (teacherName . fst))
      (_join teachers courses teacherId teacher)
      (_where ((== "ÐÐ½Ð³Ð»Ð¸Ð¹ÑÐºÐ¸Ð¹ ÑÐ·Ñ‹Ðº") .courseTitle . snd))

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 33.15 Ð’Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ Ñ€ÐµÑˆÐµÐ½Ð¸Ðµ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ñ‹ Ð¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ð²ÑƒÑŽÑ‰ÐµÐ³Ð¾ _where
teacherLastName :: [String]
teacherLastName = _hinq (_select lastName)
                         finalResult
                        (_where (\_ -> True))

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 33.16 Ð¢Ð¸Ð¿Ñ‹ _select, _where Ð¸ _join Ð´Ð»Ñ Ð¼Ð¾Ð½Ð°Ð´
_select :: Monad m => (a -> b) -> m a -> m b
_where :: (Monad m, Alternative m) => (a -> Bool) -> m a -> m a
_join :: (Monad m, Alternative m, Eq c) =>
          m a -> m b -> (a -> c) -> (b -> c) -> m (a,b)

data HINQ m a b = HINQ (m a -> m b) (m a) (m a -> m a)
                  | HINQ_ (m a -> m b) (m a)

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 33.17 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ runHINQ Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÐµÑ‚ Ð²Ñ‹Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÑŒ HINQ-Ð·Ð°Ð¿Ñ€Ð¾Ñ
runHINQ :: (Monad m, Alternative m) => HINQ m a b -> m b
runHINQ (HINQ sClause jClause wClause) =
    _hinq sClause jClause wClause
runHINQ (HINQ_ sClause jClause) =
    _hinq sClause jClause (_where (\_ -> True))

query1 :: HINQ [] (Teacher, Course) Name
query1 =
  HINQ (_select (teacherName . fst))
       (_join teachers courses teacherId teacher)
       (_where ((== "ÐÐ½Ð³Ð»Ð¸Ð¹ÑÐºÐ¸Ð¹ ÑÐ·Ñ‹Ðº") .courseTitle . snd))

GHCi> runHINQ query1
[Ð¡ÑŒÑŽÐ·ÐµÐ½ Ð—Ð¾Ð½Ñ‚Ð°Ð³]

query2 :: HINQ [] Teacher Name
query2 = HINQ_ (_select teacherName) teachers

GHCi> runHINQ query2
[Ð¡Ð¸Ð¼Ð¾Ð½Ð° Ð´Ðµ Ð‘Ð¾Ð²ÑƒÐ°Ñ€,Ð¡ÑŒÑŽÐ·ÐµÐ½ Ð—Ð¾Ð½Ñ‚Ð°Ð³]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 33.18 ÐŸÑ€Ð¸Ð¼ÐµÑ€ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð² Maybe
possibleTeacher :: Maybe Teacher
possibleTeacher = Just (head teachers)

possibleCourse :: Maybe Course
possibleCourse = Just (head courses)

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 33.19 ÐŸÑ€Ð¸Ð¼ÐµÑ€ Ð·Ð°Ð¿Ñ€Ð¾ÑÐ° Ð´Ð»Ñ Maybe
maybeQuery1 :: HINQ Maybe (Teacher,Course) Name
maybeQuery1 =
HINQ (_select (teacherName . fst))
     (_join possibleTeacher possibleCourse teacherId teacher)
     (_where ((== "Ð¤Ñ€Ð°Ð½Ñ†ÑƒÐ·ÑÐºÐ¸Ð¹ ÑÐ·Ñ‹Ðº") . courseTitle . snd))

GHCi> runHINQ maybeQuery1
Just Ð¡Ð¸Ð¼Ð¾Ð½Ð° Ð´Ðµ Ð‘Ð¾Ð²ÑƒÐ°Ñ€


Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 33.20 Ð¡Ð¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ Ð¸ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ð²Ð¸Ñ Ð² Maybe
missingCourse :: Maybe Course
missingCourse = Nothing
maybeQuery2 :: HINQ Maybe (Teacher,Course) Name
maybeQuery2 =
  HINQ (_select (teacherName . fst))
       (_join possibleTeacher missingCourse teacherId teacher)
       (_where ((== "Ð¤Ñ€Ð°Ð½Ñ†ÑƒÐ·ÑÐºÐ¸Ð¹ ÑÐ·Ñ‹Ðº") .courseTitle . snd))

GHCi> runHINQ maybeQuery2
Nothing

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 33.21 Ð¢Ð¸Ð¿ Enrollment ÑÐ²ÑÐ·Ñ‹Ð²Ð°ÐµÑ‚ ÑÑ‚ÑƒÐ´ÐµÐ½Ñ‚Ð° Ñ ÐºÑƒÑ€ÑÐ¾Ð¼
data Enrollment = Enrollment { student :: Int
                               , course :: Int } deriving Show

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 33.22 ÐŸÑ€Ð¸Ð¼ÐµÑ€ ÑÐ¿Ð¸ÑÐºÐ° Ð·Ð°Ð¿Ð¸ÑÐµÐ¹ Ð½Ð° ÐºÑƒÑ€ÑÑ‹
enrollments :: [Enrollment]
enrollments = [ (Enrollment 1 101), (Enrollment 2 101)
                , (Enrollment 2 201), (Enrollment 3 101)
                , (Enrollment 4 201), (Enrollment 4 101)
                , (Enrollment 5 101), (Enrollment 6 201) ]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 33.23 Ð—Ð°Ð¿Ñ€Ð¾Ñ Ð¿Ð¾ ÑÑ‚ÑƒÐ´ÐµÐ½Ñ‚Ð°Ð¼ Ð¸ Ð·Ð°Ð¿Ð¸ÑÐ¸ Ð¸Ñ… Ð½Ð° ÐºÑƒÑ€ÑÑ‹
studentEnrollmentsQ =
   HINQ_ (_select (\(st,en) -> (studentName st, course en))
         (_join students enrollments studentId student)

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 33.24 Ð˜ÑÐ¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ðµ Ð·Ð°Ð¿Ñ€Ð¾ÑÐ° studentEnrollmentQ
studentEnrollments :: [(Name, Int)]
studentEnrollments = runHINQ studentEnrollmentsQ

GHCi> studentEnrollments
[(ÐžÐ´Ñ€Ð¸ Ð›Ð¾Ñ€Ð´,101),(Ð›ÐµÑÐ»Ð¸ Ð¡Ð¸Ð»ÐºÐ¾,101),(Ð›ÐµÑÐ»Ð¸ Ð¡Ð¸Ð»ÐºÐ¾,201),
Ã‡ (Ð”Ð¶ÑƒÐ´Ð¸Ñ‚ Ð‘Ð°Ñ‚Ð»ÐµÑ€,101),(Ð“Ð¸ Ð”ÐµÐ±Ð¾Ñ€,201),(Ð“Ð¸ Ð”ÐµÐ±Ð¾Ñ€,101),
Ã‡ (Ð–Ð°Ð½ Ð‘Ð¾Ð´Ñ€Ð¸Ð¹ÑÑ€,101),(Ð®Ð»Ð¸Ñ ÐšÑ€Ð¸ÑÑ‚ÐµÐ²Ð°,201)]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 33.25 Ð¡Ð¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ ÑÐ¿Ð¸ÑÐºÐ° studentEnrollments Ñ ÐºÑƒÑ€ÑÐ°Ð¼Ð¸
englishStudentsQ =
  HINQ (_select (fst . fst))
       (_join studentEnrollments courses snd courseId)
       (_where ((== "ÐÐ½Ð³Ð»Ð¸Ð¹ÑÐºÐ¸Ð¹ ÑÐ·Ñ‹Ðº") . courseTitle . snd))

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 33.26 ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ ÑÐ¿Ð¸ÑÐºÐ° ÑÑ‚ÑƒÐ´ÐµÐ½Ñ‚Ð¾Ð², Ð¸Ð·ÑƒÑ‡Ð°ÑŽÑ‰Ð¸Ñ… Ð°Ð½Ð³Ð»Ð¸Ð¹ÑÐºÐ¸Ð¹
englishStudents :: [Name]
englishStudents = runHINQ englishStudentsQ

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 33.27 Ð—Ð°Ð¿Ñ€Ð¾Ñ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¾ Ð·Ð°Ð¿Ð¸ÑÑÑ…
getEnrollments :: String -> [Name]
getEnrollments courseName = runHINQ courseQuery
   where courseQuery = HINQ (_select (fst . fst))
                            (_join studentEnrollments courses snd courseId)
                            (_where ((== courseName) . courseTitle . snd))

GHCi> getEnrollments "ÐÐ½Ð³Ð»Ð¸Ð¹ÑÐºÐ¸Ð¹ ÑÐ·Ñ‹Ðº"
[Ð›ÐµÑÐ»Ð¸ Ð¡Ð¸Ð»ÐºÐ¾,Ð“Ð¸ Ð”ÐµÐ±Ð¾Ñ€,Ð®Ð»Ð¸Ñ ÐšÑ€Ð¸ÑÑ‚ÐµÐ²Ð°]
GHCi> getEnrollments "Ð¤Ñ€Ð°Ð½Ñ†ÑƒÐ·ÑÐºÐ¸Ð¹ ÑÐ·Ñ‹Ðº"
[ÐžÐ´Ñ€Ð¸ Ð›Ð¾Ñ€Ð´,Ð›ÐµÑÐ»Ð¸ Ð¡Ð¸Ð»ÐºÐ¾,Ð”Ð¶ÑƒÐ´Ð¸Ñ‚ Ð‘Ð°Ñ‚Ð»ÐµÑ€,Ð“Ð¸ Ð”ÐµÐ±Ð¾Ñ€,Ð–Ð°Ð½ Ð‘Ð¾Ð´Ñ€Ð¸Ð¹ÑÑ€]

ÐžÑ€Ð³Ð°Ð½Ð¸Ð·Ð°Ñ†Ð¸Ñ ÐºÐ¾Ð´Ð° Ð½Ð° Haskell c Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ Ð¼Ð¾Ð´ÑƒÐ»ÐµÐ¹

data Book = Book
  { title :: String
    , price :: Double }
data Magazine = Magazine
  { title :: String
   , price :: Double }

ÐžÐ±Ð° Ñ‚Ð¸Ð¿Ð° Ñ€ÐµÐ°Ð»Ð¸Ð·Ð¾Ð²Ð°Ð½Ñ‹ ÐºÐ°Ðº Ð·Ð°Ð¿Ð¸ÑÐ¸, Ñ‡Ñ‚Ð¾ ÑƒÑÐ»Ð¾Ð¶Ð½ÑÐµÑ‚ Ð·Ð°Ð´Ð°Ñ‡Ñƒ, Ñ‚Ð°Ðº ÐºÐ°Ðº
Ð´Ð»Ñ ÑÑ‚Ð¸Ñ… Ñ‚Ð¸Ð¿Ð¾Ð² Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸ Ð³ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÑŽÑ‚ÑÑ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ Ð´Ð»Ñ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð°
Ðº Ð¿Ð¾Ð»ÑÐ¼ title Ð¸ price.

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 34.1 ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ head Ð¸Ð· Prelude
head :: [a] -> a
head (x:_) = x
head [] = errorEmptyList "head"

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 34.2 ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ ÐºÐ»Ð°ÑÑÐ° Ñ‚Ð¸Ð¿Ð¾Ð² Monoid
class Monoid m where
  mempty :: m
  mappend :: m -> m -> m
  mconcat :: [m] -> m

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 34.3 ÐžÐ¹, Ð¼Ñ‹ ÑÐ»ÑƒÑ‡Ð°Ð¹Ð½Ð¾ ÑÐ¾Ð·Ð´Ð°Ð»Ð¸ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ Ñ Ð·Ð°Ð½ÑÑ‚Ñ‹Ð¼ Ð¸Ð¼ÐµÐ½ÐµÐ¼!
head :: Monoid a => [a] -> a
head (x:xs) = x
head [] = mempty

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 34.4 ÐŸÑ€Ð¸Ð¼ÐµÑ€ ÑÐ¿Ð¸ÑÐºÐ° ÑÐ¾ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸ÑÐ¼Ð¸ Ð¸Ð· ÐºÐ»Ð°ÑÑÐ° Monoid
example :: [[Int]]
example = []
Ambiguous occurrence â€™headâ€™
It could refer to either â€™Main.headâ€™
defined at ...
or â€™Prelude.headâ€™

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 34.5 Ð¯Ð²Ð½Ð¾Ðµ ÑƒÐºÐ°Ð·Ð°Ð½Ð¸Ðµ Ð¼Ð¾Ð´ÑƒÐ»Ñ
module Main where

head :: Monoid a => [a] -> a
head (x:xs) = x
head [] = mempty

example :: [[Int]]
example = []

GHCi> Main.head example
[]
GHCi> Prelude.head example
*** Exception: Prelude.head: empty list

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 34.1. ÐŸÑ€ÐµÐ´Ð¿Ð¾Ð»Ð¾Ð¶Ð¸Ð¼, Ñ‡Ñ‚Ð¾ Ð²Ð°Ð¼ Ð½ÑƒÐ¶Ð½Ð¾ ÑÐ¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ Ð´Ð»Ð¸Ð½Ñƒ Ð½ÐµÐºÐ¾Ñ‚Ð¾Ñ€Ð¾Ð³Ð¾ Ð¾Ð±ÑŠÐµÐºÑ‚Ð° Ð² Ð²Ð¸Ð´Ðµ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ð¾Ð¹. ÐÐ°Ð¿Ñ€Ð¸Ð¼ÐµÑ€:
length :: Int
length = 8
ÐšÐ°Ðº Ð±Ñ‹ Ð²Ñ‹ Ð¾Ð±Ñ€Ð°Ñ‚Ð¸Ð»Ð¸ÑÑŒ Ðº ÑÑ‚Ð¾Ð¼Ñƒ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸ÑŽ, Ð½Ðµ Ð²Ñ‹Ð·Ñ‹Ð²Ð°Ñ ÐºÐ¾Ð½Ñ„Ð»Ð¸ÐºÑ‚Ð¾Ð²
Ñ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÐµÐ¹ length Ð¸Ð· Prelude?

ÐžÑ‚Ð²ÐµÑ‚ 34.1. Ð¯Ð²Ð½Ð¾ ÑƒÐºÐ°Ð¶Ð¸Ñ‚Ðµ Ð¼Ð¾Ð´ÑƒÐ»ÑŒ, Ð¸Ð¼Ñ Ð¸Ð· ÐºÐ¾Ñ‚Ð¾Ñ€Ð¾Ð³Ð¾ Ñ…Ð¾Ñ‚Ð¸Ñ‚Ðµ Ð¿Ñ€Ð¸Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ:
length :: Int
length = 8
doubleLength :: Int
doubleLength = Main.length * 2

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 34.6 ÐŸÐµÑ€Ð²Ð°Ñ Ð²ÐµÑ€ÑÐ¸Ñ Ð¼Ð¾Ð´ÑƒÐ»Ñ Main
module Main where

isPalindrome :: String -> Bool
isPalindrome text = text == reverse text

main :: IO ()
main = do
  putStrLn "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÑÐ»Ð¾Ð²Ð¾, Ñ‡Ñ‚Ð¾Ð±Ñ‹ ÑƒÐ·Ð½Ð°Ñ‚ÑŒ, ÑÐ²Ð»ÑÐµÑ‚ÑÑ Ð»Ð¸ Ð¾Ð½Ð¾
            Ã‡ Ð¿Ð°Ð»Ð¸Ð½Ð´Ñ€Ð¾Ð¼Ð¾Ð¼."
  text <- getLine
  let response = if isPalindrome text
                 then "Ð”Ð°, ÑÑ‚Ð¾ Ð¿Ð°Ð»Ð¸Ð½Ð´Ñ€Ð¾Ð¼."
                 else "ÐÐµÑ‚, ÑÑ‚Ð¾ Ð½Ðµ Ð¿Ð°Ð»Ð¸Ð½Ð´Ñ€Ð¾Ð¼."
  putStrLn response

GHCi> main
Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÑÐ»Ð¾Ð²Ð¾, Ñ‡Ñ‚Ð¾Ð±Ñ‹ ÑƒÐ·Ð½Ð°Ñ‚ÑŒ, ÑÐ²Ð»ÑÐµÑ‚ÑÑ Ð»Ð¸ Ð¾Ð½Ð¾ Ð¿Ð°Ð»Ð¸Ð½Ð´Ñ€Ð¾Ð¼Ð¾Ð¼.
Ð´Ð¾Ñ…Ð¾Ð´
Ð”Ð°, ÑÑ‚Ð¾ Ð¿Ð°Ð»Ð¸Ð½Ð´Ñ€Ð¾Ð¼.
GHCi> main
Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÑÐ»Ð¾Ð²Ð¾, Ñ‡Ñ‚Ð¾Ð±Ñ‹ ÑƒÐ·Ð½Ð°Ñ‚ÑŒ, ÑÐ²Ð»ÑÐµÑ‚ÑÑ Ð»Ð¸ Ð¾Ð½Ð¾ Ð¿Ð°Ð»Ð¸Ð½Ð´Ñ€Ð¾Ð¼Ð¾Ð¼.
ÐœÐµÑ‡ - Ð° Ð·Ð°Ñ‡ÐµÐ¼?
ÐÐµÑ‚, ÑÑ‚Ð¾ Ð½Ðµ Ð¿Ð°Ð»Ð¸Ð½Ð´Ñ€Ð¾Ð¼.

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 34.7 Ð¤Ð°Ð¹Ð» Palindrome.hs
module Palindrome (isPalindrome) where

import Data.Char (toLower,isSpace,isPunctuation)

stripWhiteSpace :: String -> String
stripWhiteSpace text = filter (not . isSpace) text

stripPunctuation :: String -> String
stripPunctuation text = filter (not . isPunctuation) text

toLowerCase :: String -> String
toLowerCase text = map toLower text

preprocess :: String -> String
preprocess = stripWhiteSpace . stripPunctuation . toLowerCase

isPalindrome :: String -> Bool
isPalindrome text = cleanText == reverse cleanText
   where cleanText = preprocess text


module Palindrome where
module Palindrome (isPalindrome) where
module Palindrome
   ( isPalindrome
    ) where

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 34.8 Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»Ñ‘Ð½Ð½Ð¾Ð³Ð¾ Ð¼Ð½Ð¾Ð¶ÐµÑÑ‚Ð²Ð° Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹ Data.Char
import Data.Char (toLower,isSpace,isPunctuation)

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 34.9 ÐšÐ¾Ð´, Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÑŽÑ‰Ð¸Ð¹ ÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ð¾ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÑÑ‚ÑŒ Ð¿Ð°Ð»Ð¸Ð½Ð´Ñ€Ð¾Ð¼Ñ‹
stripWhiteSpace :: String -> String
stripWhiteSpace text = filter (not . isSpace) text

stripPunctuation :: String -> String
stripPunctuation text = filter (not . isPunctuation) text

toLowerCase :: String -> String
toLowerCase text = map toLower text

preprocess :: String -> String
preprocess = stripWhiteSpace . stripPunctuation . toLowerCase

isPalindrome :: String -> Bool
isPalindrome text = cleanText == reverse cleanText
  where cleanText = preprocess text

GHCi> isPalindrome "Ð´Ð¾Ñ…Ð¾Ð´"
True
GHCi> isPalindrome "ÐœÐµÑ‡ - Ð° Ð·Ð°Ñ‡ÐµÐ¼?"
True

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 34.2. Ð˜Ð·Ð¼ÐµÐ½Ð¸Ñ‚Ðµ Ð¾Ð±ÑŠÑÐ²Ð»ÐµÐ½Ð¸Ðµ Ð¼Ð¾Ð´ÑƒÐ»Ñ Ñ‚Ð°Ðº, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ
preprocess Ñ‚Ð¾Ð¶Ðµ ÑÐºÑÐ¿Ð¾Ñ€Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ð»Ð°ÑÑŒ.

ÐžÑ‚Ð²ÐµÑ‚ 34.2
module Palindrome(
   isPalindrome
   , preprocess
   ) where

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 34.10 ÐšÐ²Ð°Ð»Ð¸Ñ„Ð¸Ñ†Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ Ð¸Ð¼Ð¿Ð¾Ñ€Ñ‚ Ð¼Ð¾Ð´ÑƒÐ»Ñ Palindrome
module Main where
import qualified Palindrome

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 34.11 Ð’Ñ‹Ð·Ð¾Ð² Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ Palindrome.isPalindrome
let response = if Palindrome.isPalindrome text


Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 34.12 Ð’ Main.hs Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚ÑÑ Ñ„Ð°Ð¹Ð» Palindrome.hs
module Main where
import qualified Palindrome

isPalindrome :: String -> Bool
isPalindrome text = text == (reverse text)

main :: IO ()
main = do
  putStrLn "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÑÐ»Ð¾Ð²Ð¾, Ñ‡Ñ‚Ð¾Ð±Ñ‹ ÑƒÐ·Ð½Ð°Ñ‚ÑŒ, ÑÐ²Ð»ÑÐµÑ‚ÑÑ Ð»Ð¸ Ð¾Ð½Ð¾
            Ã‡ Ð¿Ð°Ð»Ð¸Ð½Ð´Ñ€Ð¾Ð¼Ð¾Ð¼."
  text <- getLine
  let response = if Palindrome.isPalindrome text
                 then "Ð”Ð°, ÑÑ‚Ð¾ Ð¿Ð°Ð»Ð¸Ð½Ð´Ñ€Ð¾Ð¼."
                 else "ÐÐµÑ‚, ÑÑ‚Ð¾ Ð½Ðµ Ð¿Ð°Ð»Ð¸Ð½Ð´Ñ€Ð¾Ð¼."
  putStrLn response

$ ghc Main.hs
[1 of 2] Compiling Palindrome ( Palindrome.hs, Palindrome.o )
[2 of 2] Compiling Main ( Main.hs, Main.o )
Linking Main ...

$ ./Main
Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÑÐ»Ð¾Ð²Ð¾, Ñ‡Ñ‚Ð¾Ð±Ñ‹ ÑƒÐ·Ð½Ð°Ñ‚ÑŒ, ÑÐ²Ð»ÑÐµÑ‚ÑÑ Ð»Ð¸ Ð¾Ð½Ð¾ Ð¿Ð°Ð»Ð¸Ð½Ð´Ñ€Ð¾Ð¼Ð¾Ð¼.
ÐœÐµÑ‡ - Ð° Ð·Ð°Ñ‡ÐµÐ¼?
Ð”Ð°, ÑÑ‚Ð¾ Ð¿Ð°Ð»Ð¸Ð½Ð´Ñ€Ð¾Ð¼.

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 34.3. Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ Main.isPalindrome Ð½Ð¸Ð³Ð´Ðµ Ð½Ðµ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚ÑÑ,
Ð¿Ð¾ÑÑ‚Ð¾Ð¼Ñƒ Ð¾ÑÑ‚Ð°Ð²Ð»ÑÑ‚ÑŒ ÐµÑ‘ Ð² Ñ„Ð°Ð¹Ð»Ðµ Ð½ÐµÐ¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ð¾. Ð¡Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð»Ð¸ Ð²Ñ‹ Ð¿ÐµÑ€ÐµÐ´ÐµÐ»Ð°Ñ‚ÑŒ Ñ„Ð°Ð¹Ð» Ñ‚Ð°ÐºÐ¸Ð¼ Ð¾Ð±Ñ€Ð°Ð·Ð¾Ð¼, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¿Ð¾ÑÐ»Ðµ ÐµÑ‘ ÑƒÐ´Ð°Ð»ÐµÐ½Ð¸Ñ Ð½Ðµ Ð¿Ñ€Ð¸Ñ…Ð¾Ð´Ð¸Ð»Ð¾ÑÑŒ
ÑƒÐºÐ°Ð·Ñ‹Ð²Ð°Ñ‚ÑŒ Ð¼Ð¾Ð´ÑƒÐ»ÑŒ Ð¿Ñ€Ð¸ Ð¾Ð±Ñ€Ð°Ñ‰ÐµÐ½Ð¸Ð¸ Ðº Palindrome.isPalindrome?

ÐžÑ‚Ð²ÐµÑ‚ 34.3 Ð˜Ð·Ð¼ÐµÐ½Ð¸Ñ‚Ðµ ÑÑ‚Ñ€Ð¾ÐºÑƒ import qualified Palindrome
Ð½Ð° import Palindrome, Ð¿Ð¾ÑÐ»Ðµ Ñ‡ÐµÐ³Ð¾ Ð¸Ð·Ð±Ð°Ð²ÑŒÑ‚ÐµÑÑŒ Ð¾Ñ‚ Ð¿Ñ€ÐµÑ„Ð¸ÐºÑÐ° Palindrome.
Ð² Palindrome.isPalindrome.

Ð¡Ð±Ð¾Ñ€ÐºÐ° Ð¿Ñ€Ð¾ÐµÐºÑ‚Ð¾Ð² Ð¿Ñ€Ð¸ Ð¿Ð¾Ð¼Ð¾Ñ‰Ð¸ stack
Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ð½Ð¾Ð²Ð¾Ð³Ð¾ Ð¿Ñ€Ð¾ÐµÐºÑ‚Ð° stack
$ stack update
$ stack new palindrome-checker
LICENSE src Setup.hs
stack.yaml test app
palindrome-checker.cabal

ÐšÐ°Ñ‚Ð°Ð»Ð¾Ð³Ð¸ app, src Ð¸ test

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 35.1 Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼Ñ‹Ð¹ Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ Ð¼Ð¾Ð´ÑƒÐ»ÑŒ Main
module Main where

import Lib

main :: IO ()
main = someFunc

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 35.2 Ð¡Ñ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ñ‹Ð¹ Ð¼Ð¾Ð´ÑƒÐ»ÑŒ Lib, Ð³ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼Ñ‹Ð¹ stack
module Lib
   ( someFunc
   ) where

someFunc :: IO ()
someFunc = putStrLn "someFunc"

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 35.3 Ð˜Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ Ð¼Ð¾Ð´ÑƒÐ»Ñ Palindrome Ð´Ð»Ñ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹ Ñ Text
{-# LANGUAGE OverloadedStrings #-}

module Lib
( isPalindrome
) where

import qualified Data.Text as T
import Data.Char (toLower,isSpace,isPunctuation)

stripWhiteSpace :: T.Text -> T.Text
stripWhiteSpace text = T.filter (not . isSpace) text

stripPunctuation :: T.Text -> T.Text
stripPunctuation text = T.filter (not . isPunctuation) text

preprocess :: T.Text -> T.Text
preprocess = stripWhiteSpace . stripPunctuation . T.toLower

isPalindrome :: T.Text -> Bool
isPalindrome text = cleanText == T.reverse cleanText
   where cleanText = preprocess text


Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 35.4 Main.hs Ð´Ð»Ñ Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ñ‹, Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÑÑŽÑ‰ÐµÐ¹ Ð¿Ð°Ð»Ð¸Ð½Ð´Ñ€Ð¾Ð¼Ñ‹
{-# LANGUAGE OverloadedStrings #-}

module Main where

import Lib
import Data.Text as T
import Data.Text.IO as TIO

main :: IO ()
main = do
  TIO.putStrLn "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÑÐ»Ð¾Ð²Ð¾, Ñ‡Ñ‚Ð¾Ð±Ñ‹ ÑƒÐ·Ð½Ð°Ñ‚ÑŒ, ÑÐ²Ð»ÑÐµÑ‚ÑÑ Ð»Ð¸ Ð¾Ð½Ð¾
                Ã‡ Ð¿Ð°Ð»Ð¸Ð½Ð´Ñ€Ð¾Ð¼Ð¾Ð¼."
  text <- TIO.getLine
  let response = if isPalindrome text
                 then "Ð”Ð°, ÑÑ‚Ð¾ Ð¿Ð°Ð»Ð¸Ð½Ð´Ñ€Ð¾Ð¼."
                 else "ÐÐµÑ‚, ÑÑ‚Ð¾ Ð½Ðµ Ð¿Ð°Ð»Ð¸Ð½Ð´Ñ€Ð¾Ð¼."
  TIO.putStrLn response

library
hs-source-dirs: src
exposed-modules: Lib
build-depends: base >= 4.7 && < 5
               , text
default-language: Haskell2010
executable palindrome-checker-exe
hs-source-dirs: app
main-is: Main.hs
ghc-options: -threaded -rtsopts -with-rtsopts=-N
build-depends: base
               , palindrome-checker
               , text
default-language: Haskell2010

$ stack setup
$ stack build

$ stack exec palindrome-checker-exe
Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÑÐ»Ð¾Ð²Ð¾, Ñ‡Ñ‚Ð¾Ð±Ñ‹ ÑƒÐ·Ð½Ð°Ñ‚ÑŒ, ÑÐ²Ð»ÑÐµÑ‚ÑÑ Ð»Ð¸ Ð¾Ð½Ð¾ Ð¿Ð°Ð»Ð¸Ð½Ð´Ñ€Ð¾Ð¼Ð¾Ð¼.
ÐœÐµÑ‡ - Ð° Ð·Ð°Ñ‡ÐµÐ¼?
Ð”Ð°, ÑÑ‚Ð¾ Ð¿Ð°Ð»Ð¸Ð½Ð´Ñ€Ð¾Ð¼.

extensions: OverloadedStrings

Ð¢ÐµÑÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ ÑÐ²Ð¾Ð¹ÑÑ‚Ð² Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ QuickCheck
$ stack new palindrome-testing

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 36.1 ÐšÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð¸Ñ€Ð¾Ð²ÐºÐ° Main.hs Ð´Ð»Ñ Ð½Ð°Ñ‡Ð°Ð»Ð° Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹ Ñ Lib.hs
module Main where

import Lib

main :: IO ()
main = putStrLn "ÐŸÑ€Ð¸Ð²ÐµÑ‚, Ð¼Ð¸Ñ€!"

 src/Lib.hs

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 36.2 ÐŸÑ€Ð¾ÑÑ‚ÐµÐ¹ÑˆÐµÐµ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ isPalindrome
module Lib
   ( isPalindrome
   ) where

isPalindrome :: String -> Bool
isPalindrome text = text == reverse text

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 36.1. Ð’Ð°Ð¼ Ð½ÑƒÐ¶Ð½Ð¾ Ð±ÑƒÐ´ÐµÑ‚ Ð´Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ð²ÑÐµÐ³Ð¾ Ð½ÐµÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹
Ð² Ð¼Ð¾Ð´ÑƒÐ»ÑŒ Lib, Ð° Ð¿Ð¾Ñ‚Ð¾Ð¼ ÑÐºÑÐ¿Ð¾Ñ€Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð¸Ñ… Ð²ÑÐµ. ÐšÐ°Ðº Ð² ÑÑ‚Ð¾Ð¼ ÑÐ»ÑƒÑ‡Ð°Ðµ Ð»ÑƒÑ‡ÑˆÐµ
Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»Ð¸Ñ‚ÑŒ Ð¼Ð¾Ð´ÑƒÐ»ÑŒ?

ÐžÑ‚Ð²ÐµÑ‚ 36.1
module Lib where

isPalindrome :: String -> Bool
isPalindrome text = text == reverse text

$ cd palindrome-testing
$ stack setup
...
$ stack build

$ stack ghci
*Main Lib>

*Main Lib> isPalindrome "Ð´Ð¾Ñ…Ð¾Ð´"
True
*Main Lib> isPalindrome "ÐºÐ¾Ñ‚"
False
*Main Lib> isPalindrome "Ð´Ð¾Ñ…Ð¾Ð´!"
False

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 36.3 Ð˜ÑÐ¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ isPalindrome Ð¿Ð¾ Ð¸Ñ‚Ð¾Ð³Ð°Ð¼ Ñ‚ÐµÑÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ
isPalindrome :: String -> Bool
isPalindrome text = cleanText == reverse cleanText
  where cleanText = filter (not . (== â€™!â€™)) text

*Main Lib> :r
*Main Lib> isPalindrome "Ð´Ð¾Ñ…Ð¾Ð´!"
True

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 36.2. Ð¯Ð²Ð»ÑÐµÑ‚ÑÑ Ð»Ð¸ Ð¿Ð°Ð»Ð¸Ð½Ð´Ñ€Ð¾Ð¼Ð¾Ð¼ "Ð¼Ð°Ñ‚ Ð¸ Ñ‚ÑƒÑ‚ Ð¸ Ñ‚Ð°Ð¼"?
ÐžÑ‚Ð²ÐµÑ‚ 36.2
*Main Lib> isPalindrome "Ð¼Ð°Ñ‚ Ð¸ Ñ‚ÑƒÑ‚ Ð¸ Ñ‚Ð°Ð¼"
True

ÐÐ°Ð¿Ð¸ÑÐ°Ð½Ð¸Ñ ÑÐ¾Ð±ÑÑ‚Ð²ÐµÐ½Ð½Ñ‹Ñ… Ð¼Ð¾Ð´ÑƒÐ»ÑŒÐ½Ñ‹Ñ… Ñ‚ÐµÑÑ‚Ð¾Ð² Ð¸ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 36.4 Ð—Ð°Ð³Ð¾Ñ‚Ð¾Ð²ÐºÐ° Ð´Ð»Ñ Ñ„Ð°Ð¹Ð»Ð° Spec.hs
main :: IO ()
main = putStrLn "Test suite not yet implemented"

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 36.5 ÐŸÑ€Ð¾ÑÑ‚ÐµÐ¹ÑˆÐ°Ñ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ Ð´Ð»Ñ Ð¼Ð¾Ð´ÑƒÐ»ÑŒÐ½Ð¾Ð³Ð¾ Ñ‚ÐµÑÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ
assert :: Bool -> String -> String -> IO ()
assert test passStatement failStatement =
       if test
       then putStrLn passStatement
       else putStrLn failStatement

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 36.6 Spec.hs Ñ Ð½ÐµÑÐºÐ¾Ð»ÑŒÐºÐ¸Ð¼Ð¸ Ð¿Ñ€Ð¾ÑÑ‚Ñ‹Ð¼Ð¸ Ð¼Ð¾Ð´ÑƒÐ»ÑŒÐ½Ñ‹Ð¼Ð¸ Ñ‚ÐµÑÑ‚Ð°Ð¼Ð¸
import Lib
assert :: Bool -> String -> String -> IO ()
assert test passStatement failStatement =
    if test
    then putStrLn passStatement
    else putStrLn failStatement

main :: IO ()
main = do
   putStrLn "Ð—Ð°Ð¿ÑƒÑÐº Ñ‚ÐµÑÑ‚Ð¾Ð²..."
   assert (isPalindrome "Ð´Ð¾Ñ…Ð¾Ð´") "Ð¿Ñ€Ð¾Ð¹Ð´ÐµÐ½Ð¾: â€™Ð´Ð¾Ñ…Ð¾Ð´â€™"
          "Ð¿Ñ€Ð¾Ð²Ð°Ð»: â€™Ð´Ð¾Ñ…Ð¾Ð´â€™"
   assert (isPalindrome "Ð´Ð¾Ñ…Ð¾Ð´!") "Ð¿Ñ€Ð¾Ð¹Ð´ÐµÐ½Ð¾: â€™Ð´Ð¾Ñ…Ð¾Ð´!â€™"
           "Ð¿Ñ€Ð¾Ð²Ð°Ð»: â€™Ð´Ð¾Ñ…Ð¾Ð´!â€™"
   assert ((not . isPalindrome) "ÐºÐ¾Ñ‚") "Ð¿Ñ€Ð¾Ð¹Ð´ÐµÐ½Ð¾: â€™ÐºÐ¾Ñ‚â€™"
          "Ð¿Ñ€Ð¾Ð²Ð°Ð»: â€™ÐºÐ¾Ñ‚â€™"
   putStrLn "Ð“Ð¾Ñ‚Ð¾Ð²Ð¾!"

$ stack test
Ð—Ð°Ð¿ÑƒÑÐº Ñ‚ÐµÑÑ‚Ð¾Ð²...
Ð¿Ñ€Ð¾Ð¹Ð´ÐµÐ½Ð¾: â€™Ð´Ð¾Ñ…Ð¾Ð´â€™
Ð¿Ñ€Ð¾Ð¹Ð´ÐµÐ½Ð¾: â€™Ð´Ð¾Ñ…Ð¾Ð´!â€™
Ð¿Ñ€Ð¾Ð¹Ð´ÐµÐ½Ð¾: â€™ÐºÐ¾Ñ‚â€™
Ð“Ð¾Ñ‚Ð¾Ð²Ð¾!

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 36.7 Ð”Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð´Ñ€ÑƒÐ³Ð¾Ð³Ð¾ Ñ‚ÐµÑÑ‚Ð° Ð² main
assert (isPalindrome "Ð´Ð¾Ñ…Ð¾Ð´.") "Ð¿Ñ€Ð¾Ð¹Ð´ÐµÐ½Ð¾: â€™Ð´Ð¾Ñ…Ð¾Ð´.â€™"
                               "Ð¿Ñ€Ð¾Ð²Ð°Ð»: â€™Ð´Ð¾Ñ…Ð¾Ð´.â€™"

Ð—Ð°Ð¿ÑƒÑÐº Ñ‚ÐµÑÑ‚Ð¾Ð²...
Ð¿Ñ€Ð¾Ð¹Ð´ÐµÐ½Ð¾: â€™Ð´Ð¾Ñ…Ð¾Ð´â€™
Ð¿Ñ€Ð¾Ð¹Ð´ÐµÐ½Ð¾: â€™Ð´Ð¾Ñ…Ð¾Ð´!â€™
Ð¿Ñ€Ð¾Ð¹Ð´ÐµÐ½Ð¾: â€™ÐºÐ¾Ñ‚â€™
Ð¿Ñ€Ð¾Ð²Ð°Ð»: â€™Ð´Ð¾Ñ…Ð¾Ð´.â€™
Ð“Ð¾Ñ‚Ð¾Ð²Ð¾!

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 36.8 Ð•Ñ‰Ñ‘ Ð¾Ð´Ð½Ð¾ Ð¸ÑÐ¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ñ‹ Ñ isPalindrome
isPalindrome :: String -> Bool
isPalindrome text = cleanText == reverse cleanText
      where cleanText = filter (not . ( â€˜ elem â€˜ [â€™!â€™,â€™.â€™])) text

Ð—Ð°Ð¿ÑƒÑÐº Ñ‚ÐµÑÑ‚Ð¾Ð²...
Ð¿Ñ€Ð¾Ð¹Ð´ÐµÐ½Ð¾: â€™Ð´Ð¾Ñ…Ð¾Ð´â€™
Ð¿Ñ€Ð¾Ð¹Ð´ÐµÐ½Ð¾: â€™Ð´Ð¾Ñ…Ð¾Ð´!â€™
Ð¿Ñ€Ð¾Ð¹Ð´ÐµÐ½Ð¾: â€™ÐºÐ¾Ñ‚â€™
Ð¿Ñ€Ð¾Ð¹Ð´ÐµÐ½Ð¾: â€™Ð´Ð¾Ñ…Ð¾Ð´.â€™
Ð“Ð¾Ñ‚Ð¾Ð²Ð¾!

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 36.3. Ð”Ð¾Ð±Ð°Ð²ÑŒÑ‚Ðµ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÑƒ ":Ð´Ð¾Ñ…Ð¾Ð´:" Ðº ÑÐ¿Ð¸ÑÐºÑƒ Ñ‚ÐµÑÑ‚Ð¾Ð² Ð¸ Ð¿ÐµÑ€ÐµÐ·Ð°Ð¿ÑƒÑÑ‚Ð¸Ñ‚Ðµ Ð½Ð°Ð±Ð¾Ñ€ Ñ‚ÐµÑÑ‚Ð¾Ð².

ÐžÑ‚Ð²ÐµÑ‚ 36.3
main :: IO ()
main = do
   putStrLn "Ð—Ð°Ð¿ÑƒÑÐº Ñ‚ÐµÑÑ‚Ð¾Ð²..."
   assert (isPalindrome "Ð´Ð¾Ñ…Ð¾Ð´") "Ð¿Ñ€Ð¾Ð¹Ð´ÐµÐ½Ð¾: â€™Ð´Ð¾Ñ…Ð¾Ð´â€™"
           "Ð¿Ñ€Ð¾Ð²Ð°Ð»: â€™Ð´Ð¾Ñ…Ð¾Ð´â€™"
   assert (isPalindrome "Ð´Ð¾Ñ…Ð¾Ð´!") "Ð¿Ñ€Ð¾Ð¹Ð´ÐµÐ½Ð¾: â€™Ð´Ð¾Ñ…Ð¾Ð´!â€™"
            "Ð¿Ñ€Ð¾Ð²Ð°Ð»: â€™Ð´Ð¾Ñ…Ð¾Ð´!â€™"
   assert ((not . isPalindrome) "ÐºÐ¾Ñ‚") "Ð¿Ñ€Ð¾Ð¹Ð´ÐµÐ½Ð¾: â€™ÐºÐ¾Ñ‚â€™"
          "Ð¿Ñ€Ð¾Ð²Ð°Ð»: â€™ÐºÐ¾Ñ‚â€™"
   assert (isPalindrome "Ð´Ð¾Ñ…Ð¾Ð´.") "Ð¿Ñ€Ð¾Ð¹Ð´ÐµÐ½Ð¾: â€™Ð´Ð¾Ñ…Ð¾Ð´.â€™"
           "Ð¿Ñ€Ð¾Ð²Ð°Ð»: â€™Ð´Ð¾Ñ…Ð¾Ð´.â€™"
   assert (isPalindrome ":Ð´Ð¾Ñ…Ð¾Ð´:") "Ð¿Ñ€Ð¾Ð¹Ð´ÐµÐ½Ð¾: â€™:Ð´Ð¾Ñ…Ð¾Ð´:â€™"
           "Ð¿Ñ€Ð¾Ð²Ð°Ð»: â€™:Ð´Ð¾Ñ…Ð¾Ð´:â€™"
   putStrLn "Ð“Ð¾Ñ‚Ð¾Ð²Ð¾!"

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 36.9 ÐšÐ¾Ð´ ÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚ÑÑ Ð±Ð¾Ð»ÐµÐµ Ð°ÐºÐºÑƒÑ€Ð°Ñ‚Ð½Ñ‹Ð¼
module Lib
   ( isPalindrome
     , preprocess
    ) where

preprocess :: String -> String
preprocess text = filter (not . ( â€˜ elem â€˜ [â€™!â€™,â€™.â€™])) text

isPalindrome :: String -> Bool
isPalindrome text = cleanText == reverse cleanText
   where cleanText = preprocess text

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 36.10 ÐŸÑ€ÐµÐ´ÑÑ‚Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼Ð¾Ð³Ð¾ ÑÐ²Ð¾Ð¹ÑÑ‚Ð²Ð° Ñ„ÑƒÐ½ÐºÑ†Ð¸ÐµÐ¹
prop_punctuationInvariant text = preprocess text ==
preprocess noPuncText
   where noPuncText = filter (not . isPunctuation) text

"Ð’Ñ‹Ð·Ð¾Ð² preprocess Ð½Ð° ÑÑ‚Ñ€Ð¾ÐºÐµ Ð´Ð¾Ð»Ð¶ÐµÐ½ Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°Ñ‚ÑŒ Ñ‚Ð¾Ñ‚ Ð¶Ðµ Ð¾Ñ‚Ð²ÐµÑ‚
Ñ‡Ñ‚Ð¾ Ð¸ Ð²Ñ‹Ð·Ð¾Ð² Ð½Ð° Ñ‚Ð¾Ð¼ Ð¶Ðµ Ñ‚ÐµÐºÑÑ‚Ðµ, Ð½Ð¾ Ð±ÐµÐ· ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð² Ð¿ÑƒÐ½ÐºÑ‚ÑƒÐ°Ñ†Ð¸Ð¸"

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 36.4. Ð ÐµÐ°Ð»Ð¸Ð·ÑƒÐ¹Ñ‚Ðµ ÑÐ²Ð¾Ð¹ÑÑ‚Ð²Ð¾ prop_reverseInvariant, ÐºÐ¾Ñ‚Ð¾Ñ€Ð¾Ðµ Ð¿Ð¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÑ‚ Ð¾Ñ‡ÐµÐ²Ð¸Ð´Ð½Ñ‹Ð¹ Ñ„Ð°ÐºÑ‚, 
Ñ‡Ñ‚Ð¾ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚ isPalindrome Ð´Ð¾Ð»Ð¶ÐµÐ½
Ð±Ñ‹Ñ‚ÑŒ Ð¾Ð´Ð¸Ð½Ð°ÐºÐ¾Ð²Ñ‹Ð¼ Ð½Ð° ÑÑ‚Ñ€Ð¾ÐºÐµ Ð¸ Ð½Ð° ÐµÑ‘ Ð¿ÐµÑ€ÐµÐ²Ñ‘Ñ€Ð½ÑƒÑ‚Ð¾Ð¹ Ð²ÐµÑ€ÑÐ¸Ð¸.

ÐžÑ‚Ð²ÐµÑ‚ 36.4
prop_reverseInvariant text = isPalindrome text
                             == (isPalindrome (reverse text))

ÐŸÑ€ÐµÐ´ÑÑ‚Ð°Ð²Ð»ÑÐµÐ¼ Ð²Ð°Ð¼ QuickCheck
Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 36.11 Ð˜Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ palindrome-testing.cabal
test-suite palindrome-testing-test
type: exitcode-stdio-1.0
hs-source-dirs: test
main-is: Spec.hs
build-depends: base
               , palindrome-testing
               , QuickCheck
ghc-options: -threaded -rtsopts -with-rtsopts=-N
default-language: Haskell2010

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 36.12 Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ quickCheck Ð² Spec.hs
main :: IO ()
main = do
   quickCheck prop_punctuationInvariant
   putStrLn "Ð“Ð¾Ñ‚Ð¾Ð²Ð¾!"

Progress: 1/2***
Failed! Falsifiable (after 4 tests and 2 shrinks):
"\187"

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 36.13 Ð£Ð´Ð¾Ð²Ð»ÐµÑ‚Ð²Ð¾Ñ€ÑÐµÐ¼ Ð·Ð°Ð¼ÐµÑ‡Ð°Ð½Ð¸Ðµ QuickCheck
preprocess :: String -> String
preprocess text = filter (not . ( â€˜ elem â€˜ [â€™!â€™,â€™.â€™,â€™\187â€™]))
                          text

Failed! Falsifiable (after 11 tests and 2 shrinks):
";"

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 36.14 ÐšÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð¸Ñ€Ð¾Ð²ÐºÐ° Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¸ ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð² Ð¿ÑƒÐ½ÐºÑ‚ÑƒÐ°Ñ†Ð¸Ð¸
import Data.Char(isPunctuation)

preprocess :: String -> String
preprocess text = filter (not . isPunctuation) text

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 36.15 Ð—Ð°Ð´Ð°Ð½Ð¸Ðµ ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð° Ñ‚ÐµÑÑ‚Ð¾Ð² QuickCheck
main :: IO ()
main = do
  quickCheckWith stdArgs {maxSuccess = 1000}
  prop_punctuationInvariant
  putStrLn "Ð“Ð¾Ñ‚Ð¾Ð²Ð¾!"

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 36.5. Ð”Ð¾Ð±Ð°Ð²ÑŒÑ‚Ðµ Ð² main Ð²Ñ‹Ð·Ð¾Ð² quickCheck Ð´Ð»Ñ ÑÐ²Ð¾Ð¹ÑÑ‚Ð²Ð°
prop_reverseInvariant, Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»Ñ‘Ð½Ð½Ð¾Ð³Ð¾ Ð² Ð¿Ñ€ÐµÐ´Ñ‹Ð´ÑƒÑ‰ÐµÐ¼ ÑƒÐ¿Ñ€Ð°Ð¶Ð½ÐµÐ½Ð¸Ð¸.

ÐžÑ‚Ð²ÐµÑ‚ 36.5
prop_reverseInvariant text = isPalindrome text
                             == isPalindrome (reverse text)
main :: IO ()
main = do
  quickCheckWith stdArgs {maxSuccess = 1000}
  prop_punctuationInvariant
  quickCheck prop_reverseInvariant
  putStrLn "Ð“Ð¾Ñ‚Ð¾Ð²Ð¾!"

ÐŸÑ€Ð¸Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ QuickCheck Ñ Ñ€Ð°Ð·Ð½Ñ‹Ð¼Ð¸ Ñ‚Ð¸Ð¿Ð°Ð¼Ð¸ Ð¸ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ° Ð±Ð¸Ð±Ð»Ð¸Ð¾Ñ‚ÐµÐº
$ stack install quickcheck-instances
Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 36.16 Ð ÐµÑ„Ð°ÐºÑ‚Ð¾Ñ€Ð¸Ð½Ð³ Ð¼Ð¾Ð´ÑƒÐ»Ñ Lib Ð¿Ð¾ Ð·Ð°Ð¼ÐµÐ½Ðµ String Ð½Ð° Data.Text

module Lib
   ( isPalindrome
     , preprocess
    ) where

import Data.Text as T
import Data.Char(isPunctuation)

preprocess :: T.Text -> T.Text
preprocess text = T.filter (not . isPunctuation) text

isPalindrome :: T.Text -> Bool
isPalindrome text = cleanText == T.reverse cleanText
  where cleanText = preprocess text

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 36.17 Ð˜ÑÐ¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Spec.hs Ð´Ð»Ñ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹ Ñ Data.Text
import Lib
import Test.QuickCheck
import Test.QuickCheck.Instances
import Data.Char(isPunctuation)
import Data.Text as T

prop_punctuationInvariant text = preprocess text ==
                                 preprocess noPuncText
    where noPuncText = T.filter (not . isPunctuation) text

main :: IO ()
main = do
  quickCheckWith stdArgs { maxSuccess = 1000}
  prop_punctuationInvariant
  putStrLn "Ð“Ð¾Ñ‚Ð¾Ð²Ð¾!"

Ð”Ð¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ text Ð¸ quickcheck-instances Ð² Ñ€Ð°Ð·Ð´ÐµÐ» build-depends ÑÐµÐºÑ†Ð¸Ð¸ Ñ‚ÐµÑÑ‚Ð¾Ð², 
Ð¸, Ð½Ð°ÐºÐ¾Ð½ÐµÑ†, Ð¼Ð¾Ð¶Ð½Ð¾ Ð¿Ñ€Ð¾Ñ‚ÐµÑÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ ÑƒÐ»ÑƒÑ‡ÑˆÐµÐ½Ð½Ñ‹Ð¹ ÐºÐ¾Ð´:
$ stack test
...
OK, passed 1000 tests.

Ð˜Ñ‚Ð¾Ð³Ð¾Ð²Ñ‹Ð¹ Ð¿Ñ€Ð¾ÐµÐºÑ‚: Ð±Ð¸Ð±Ð»Ð¸Ð¾Ñ‚ÐµÐºÐ° Ð´Ð»Ñ Ð¿Ñ€Ð¾ÑÑ‚Ñ‹Ñ… Ñ‡Ð¸ÑÐµÐ»
primes :: [Int]
sieve :: [Int] -> [Int]

isPrime :: Int -> Maybe Bool
primeFactors :: Int -> Maybe [Int]

Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ð½Ð¾Ð²Ð¾Ð³Ð¾ Ð¿Ñ€Ð¾ÐµÐºÑ‚Ð°
$ stack new primes
$ cd primes
Ð”Ð»Ñ Ð¾ÑÐ²ÐµÐ¶ÐµÐ½Ð¸Ñ Ð² Ð¿Ð°Ð¼ÑÑ‚Ð¸ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ñ‹ Ð¿Ñ€Ð¾ÐµÐºÑ‚Ð° Ð¿Ð¾ÑÐ¼Ð¾Ñ‚Ñ€Ð¸Ñ‚Ðµ Ð½Ð° Ñ„Ð°Ð¹Ð»Ñ‹ Ð¸ ÐºÐ°Ñ‚Ð°Ð»Ð¾Ð³Ð¸, ÑÐ¾Ð·Ð´Ð°Ð½Ð½Ñ‹Ðµ stack. Ð’Ð¾Ñ‚ ÑÐ¿Ð¸ÑÐ¾Ðº ÐºÐ°Ñ‚Ð°Ð»Ð¾Ð³Ð¾Ð²:
â€š app â€” ÑÑ‚Ð¾ ÐºÐ°Ñ‚Ð°Ð»Ð¾Ð³ Ð´Ð»Ñ Ð¼Ð¾Ð´ÑƒÐ»Ñ Main, Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ñ‚ Ñ„Ð°Ð¹Ð»
Main.hs;
â€š src â€” Ð·Ð´ÐµÑÑŒ Ð²ÑÐµ Ð±Ð¸Ð±Ð»Ð¸Ð¾Ñ‚ÐµÑ‡Ð½Ñ‹Ðµ Ñ„Ð°Ð¹Ð»Ñ‹, Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ñ‚ Lib.hs;
â€š test â€” ÐºÐ°Ñ‚Ð°Ð»Ð¾Ð³ Ñ ÐºÐ¾Ð´Ð¾Ð¼ Ð´Ð»Ñ Ñ‚ÐµÑÑ‚Ð¾Ð², Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ñ‚ Spec.hs.
â€š primes.cabal â€” Ñ„Ð°Ð¹Ð», Ð² ÐºÐ¾Ñ‚Ð¾Ñ€Ð¾Ð¼ ÑƒÐºÐ°Ð·Ñ‹Ð²Ð°ÑŽÑ‚ÑÑ Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ Ð¿Ð¾ ÑÐ±Ð¾Ñ€ÐºÐµ Ð¿Ñ€Ð¾ÐµÐºÑ‚Ð°;
â€š LICENSE â€” Ñ‚ÐµÐºÑÑ‚ Ð»Ð¸Ñ†ÐµÐ½Ð·Ð¸Ð¸, Ð¿Ð¾Ð´ ÐºÐ¾Ñ‚Ð¾Ñ€Ð¾Ð¹ Ð²Ð°ÑˆÐ° Ð±Ð¸Ð±Ð»Ð¸Ð¾Ñ‚ÐµÐºÐ° Ð±ÑƒÐ´ÐµÑ‚ Ñ€Ð°ÑÐ¿Ñ€Ð¾ÑÑ‚Ñ€Ð°Ð½ÑÑ‚ÑŒÑÑ;
â€š stack.yaml â€” ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ñ‚ Ð´Ð¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ ÐºÐ¾Ð½Ñ„Ð¸Ð³ÑƒÑ€Ð°Ñ†Ð¸Ð¾Ð½Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ;
â€š Setup.hs â€” Ñ„Ð°Ð¹Ð», Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼Ñ‹Ð¹ ÑÐ¸ÑÑ‚ÐµÐ¼Ð¾Ð¹ Cabal, ÐµÐ³Ð¾ Ð¼Ð¾Ð¶Ð½Ð¾ Ð¸Ð³Ð½Ð¾Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ.

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 37.1 ÐÐ¾Ð²Ð°Ñ Ð²ÐµÑ€ÑÐ¸Ñ Ð¼Ð¾Ð´ÑƒÐ»Ñ Main Ð² app/Main.hs
module Main where
import Primes

main :: IO ()
main = return ()

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 37.2 Ð˜Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ src/Lib.hs Ð½Ð° src/Primes.hs
module Primes where

primes :: [Int]
primes = [1 .. ]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 37.3 ÐžÑ‚Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ Ð¿ÐµÑ€ÐµÐ¸Ð¼ÐµÐ½Ð¾Ð²Ð°Ð½Ð¸Ñ Ð¼Ð¾Ð´ÑƒÐ»Ñ Ð² primes.cabal
library
hs-source-dirs: src
exposed-modules: Primes
build-depends: base >= 4.7 && < 5
default-language: Haskell2010

$ stack setup
...
$ stack build

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 37.4 Ð ÐµÐºÑƒÑ€ÑÐ¸Ð²Ð½Ð°Ñ Ñ€ÐµÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ Ñ€ÐµÑˆÐµÑ‚Ð° Ð­Ñ€Ð°Ñ‚Ð¾ÑÑ„ÐµÐ½Ð°
sieve :: [Int] -> [Int]
sieve [] = []
sieve (nextPrime:rest) = nextPrime : sieve noFactors
    where noFactors = filter (not . (== 0)
                                  . (â€˜modâ€˜ nextPrime)) rest

GHCi> sieve [2 .. 20]
[2,3,5,7,11,13,17,19]
GHCi> sieve [2 .. 200]
[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,
Ã‡ 79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,
Ã‡ 157,163,167,173,179,181,191,193,197,199]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 37.5 Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ ÑÐ¿Ð¸ÑÐºÐ° Ð²ÑÐµÑ… Ð¿Ñ€Ð¾ÑÑ‚Ñ‹Ñ… Ñ‡Ð¸ÑÐµÐ»
primes :: [Int]
primes = sieve [2 .. ]

GHCi> maxBound :: Int
9223372036854775807

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 37.6 Ð¡Ð¿Ð¸ÑÐ¾Ðº Ð¿Ñ€Ð¾ÑÑ‚Ñ‹Ñ… Ñ‡Ð¸ÑÐµÐ» Ñ€Ð°Ð·ÑƒÐ¼Ð½Ð¾Ð³Ð¾ Ñ€Ð°Ð·Ð¼ÐµÑ€Ð°
primes :: [Int]
primes = sieve [2 .. 10000]

GHCi> length primes
1229
GHCi> take 10 primes
[2,3,5,7,11,13,17,19,23,29]

ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ isPrime
isPrime :: Int -> Bool

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 37.7 Ð‘Ð¾Ð»ÐµÐµ ÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ð°Ñ Ð²ÐµÑ€ÑÐ¸Ñ isPrime
isPrime :: Int -> Maybe Bool
isPrime n | n < 0 = Nothing
          | n >= length primes = Nothing
          | otherwise = Just (n â€˜elemâ€˜ primes)

GHCi> isPrime 8
Just False
GHCi> isPrime 17
Just True

GHCi> map isPrime [2 .. 20]
[Just True,Just True,Just False,Just True,Just False,Just True,
Ã‡ Just False,Just False,Just False,Just True,Just False,
Ã‡ Just True,Just False,Just False,Just False,Just True,
Ã‡ Just False,Just True,Just False]
GHCi> isPrime (-13)
Nothing

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 37.8 Ð’Ð½ÐµÑÐµÐ½Ð¸Ðµ QuickCheck Ð² ÑÐ¿Ð¸ÑÐ¾Ðº Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾ÑÑ‚ÐµÐ¹ test-suite
test-suite primes-test
type: exitcode-stdio-1.0
hs-source-dirs: test
main-is: Spec.hs
build-depends: base
, primes
, QuickCheck
ghc-options: -threaded -rtsopts -with-rtsopts=-N
default-language: Haskell2010

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 37.9 Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚ Ð½ÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ñ‹Ñ… Ð¼Ð¾Ð´ÑƒÐ»ÐµÐ¹ Ð² test/Spec.hs
import Test.QuickCheck
import Primes

main :: IO ()
main = putStrLn "Test suite not yet implemented"

$ stack test
Test suite not yet implemented

ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ ÑÐ²Ð¾Ð¹ÑÑ‚Ð² isPrime
Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 37.10 ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ Nothing Ð¸Ð»Ð¸ Just-Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ
import Data.Maybe
prop_validPrimesOnly val =
    if val < 0 || val >= length primes
    then result == Nothing
    else isJust result
  where result = isPrime val

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 37.11 Ð”Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ prop_validPrimesOnly Ð² main
main :: IO ()
main = do
  quickCheck prop_validPrimesOnly

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 37.12 Ð¢ÐµÑÑ‚ Ð½Ð° ÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ð¾ÑÑ‚ÑŒ Ð²Ñ‹ÑÐ²Ð»ÐµÐ½Ð¸Ñ Ð¿Ñ€Ð¾ÑÑ‚Ñ‹Ñ… Ñ‡Ð¸ÑÐµÐ»
prop_primesArePrime val = if result == Just True
                          then length divisors == 0
                          else True
   where result = isPrime val
        divisors = filter ((== 0) . (val â€˜modâ€˜ ))
                          [2 .. (val - 1)]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 37.13 Ð¢ÐµÑÑ‚ Ð½Ð° ÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ð¾ÑÑ‚ÑŒ Ð²Ñ‹ÑÐ²Ð»ÐµÐ½Ð¸Ñ ÑÐ¾ÑÑ‚Ð°Ð²Ð½Ñ‹Ñ… Ñ‡Ð¸ÑÐµÐ»
prop_nonPrimesAreComposite val = if result == Just False
                                 then length divisors > 0
                                 else True
   where result = isPrime val
         divisors = filter ((== 0) . (val â€˜modâ€˜ ))
                    [2 .. (val - 1)]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 37.14 ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð´Ð¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ñ… ÑÐ²Ð¾Ð¹ÑÑ‚Ð² Ð² main
main :: IO ()
main = do
     quickCheck prop_validPrimesOnly
     quickCheckWith stdArgs {maxSuccess = 1000}
     prop_primesArePrime
     quickCheckWith stdArgs {maxSuccess = 1000}
     prop_nonPrimesAreComposite
Ð•ÑÐ»Ð¸ Ð·Ð°Ð¿ÑƒÑÑ‚Ð¸Ñ‚ÑŒ Ñ‚ÐµÑÑ‚Ñ‹, Ñ‚Ð¾ Ð²Ñ‹ ÑƒÐ²Ð¸Ð´Ð¸Ñ‚Ðµ, Ñ‡Ñ‚Ð¾ ÐºÐ¾Ðµ-Ñ‡Ñ‚Ð¾ Ð±Ñ‹Ð»Ð¾ ÑƒÐ¿ÑƒÑ‰ÐµÐ½Ð¾!
+++ OK, passed 100 tests.
+++ OK, passed 1000 tests.
*** Failed! Falsifiable (after 1 test):
0


Ð˜ÑÐ¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð¾ÑˆÐ¸Ð±ÐºÐ¸
Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 37.15 Ð˜ÑÐ¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð¾ÑˆÐ¸Ð±ÐºÐ¸ Ð² isPrime
isPrime :: Int -> Maybe Bool
isPrime n | n < 2 = Nothing
          | n >= length primes = Nothing
          | otherwise = Just (n â€˜elemâ€˜ primes)


Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 37.16 ÐžÐ±Ð½Ð¾Ð²Ð»Ñ‘Ð½Ð½Ð¾Ðµ ÑÐ²Ð¾Ð¹ÑÑ‚Ð²Ð° prop_validPrimesOnly
prop_validPrimesOnly val =
    if val < 2 || val >= length primes
    then result == Nothing
    else isJust result
 where result = isPrime val


+++ OK, passed 100 tests.
+++ OK, passed 1000 tests.
+++ OK, passed 1000 tests.
4 = [2,2]
6 = [2,3]
18 = [2,3,3]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 37.17 ÐÐµÐ±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð°Ñ Ð²ÐµÑ€ÑÐ¸Ñ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ Ñ„Ð°ÐºÑ‚Ð¾Ñ€Ð¸Ð·Ð°Ñ†Ð¸Ð¸
unsafePrimeFactors :: Int -> [Int] -> [Int]
unsafePrimeFactors 0 [] = []
unsafePrimeFactors n [] = []
unsafePrimeFactors n (next:primes) =
   if n â€˜modâ€˜ next == 0
   then next:unsafePrimeFactors (n â€˜divâ€˜ next) (next:primes)
   else unsafePrimeFactors n primes

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 37.18 Ð‘ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð°Ñ Ð¾Ð±Ñ‘Ñ€Ñ‚ÐºÐ° Ð´Ð»Ñ unsafePrimeFactors
primeFactors :: Int -> Maybe [Int]
primeFactors n
  | n < 2 = Nothing
  | n >= length primes = Nothing
  | otherwise = Just (unsafePrimeFactors n primesLessThanN)
  where primesLessThanN = filter (<= n) primes

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 37.19 ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð¿Ñ€Ð¾Ð¸Ð·Ð²ÐµÐ´ÐµÐ½Ð¸Ñ Ñ‡Ð¸ÑÐµÐ» Ð¸Ð· Ñ€Ð°Ð·Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ
prop_factorsMakeOriginal val =
   if result == Nothing
   then True
   else product (fromJust result) == val
  where result = primeFactors val

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 37.20 ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð² Ñ€Ð°Ð·Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ Ð½Ð° Ð¿Ñ€Ð¾ÑÑ‚Ð¾Ñ‚Ñƒ
prop_allFactorsPrime val =
   if result == Nothing
   then True
   else all (== Just True) resultsPrime
  where result = primeFactors val
        resultsPrime = map isPrime (fromJust result)

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 37.21 Ð—Ð°Ð¿ÑƒÑÐº Ð²ÑÐµÑ… Ñ‚ÐµÑÑ‚Ð¾Ð² Ð² main Ð¸Ð· src/Spec.hs
main :: IO ()
main = do
   quickCheck prop_validPrimesOnly
   quickCheckWith stdArgs {maxSuccess = 1000}
   prop_primesArePrime
   quickCheckWith stdArgs {maxSuccess = 1000}
   prop_nonPrimesAreComposite
   quickCheck prop_factorsSumToOriginal
   quickCheck prop_allFactorsPrime

+++ OK, passed 100 tests.
+++ OK, passed 1000 tests.
+++ OK, passed 1000 tests.
+++ OK, passed 100 tests.
+++ OK, passed 100 tests.

$ stack exec primes-exe
Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ñ‡Ð¸ÑÐ»Ð¾, Ñ‡Ñ‚Ð¾Ð±Ñ‹ ÑƒÐ·Ð½Ð°Ñ‚ÑŒ, ÑÐ²Ð»ÑÐµÑ‚ÑÑ Ð»Ð¸ Ð¾Ð½Ð¾ Ð¿Ñ€Ð¾ÑÑ‚Ñ‹Ð¼:
4
ÐžÐ½Ð¾ ÑÐ¾ÑÑ‚Ð°Ð²Ð½Ð¾Ðµ!
Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ñ‡Ð¸ÑÐ»Ð¾, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ ÐµÐ³Ð¾ ÐºÐ°Ð½Ð¾Ð½Ð¸Ñ‡ÐµÑÐºÐ¾Ðµ Ñ€Ð°Ð·Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ:
100000000000
Ðš ÑÐ¾Ð¶Ð°Ð»ÐµÐ½Ð¸ÑŽ, ÑÑ‚Ð¾ Ñ‡Ð¸ÑÐ»Ð¾ ÑÐ»Ð¸ÑˆÐºÐ¾Ð¼ Ð²ÐµÐ»Ð¸ÐºÐ¾.

ÐŸÑ€Ð¸Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ Haskell Ð½Ð° Ð¿Ñ€Ð°ÐºÑ‚Ð¸ÐºÐµ
ÐžÑˆÐ¸Ð±ÐºÐ¸ Ð² Haskell Ð¸ Ñ‚Ð¸Ð¿ Either

GHCi> head [1]
1
GHCi> head []
*** Exception: Prelude.head: empty list

head :: [a] -> a
Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 38.1 ÐšÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ð°Ñ, Ð½Ð¾ Ð¿Ð¾Ð´Ð²ÐµÑ€Ð¶ÐµÐ½Ð½Ð°Ñ Ð¾ÑˆÐ¸Ð±ÐºÐ°Ð¼ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ
myTake :: Int -> [a] -> [a]
myTake 0 _ = []
myTake n xs = head xs : myTake (n-1) (tail xs)

executable headaches-exe
hs-source-dirs: app
main-is: Main.hs
ghc-options: -threaded -rtsopts -with-rtsopts=-N -Wall
build-depends: base
, headaches
default-language: Haskell2010

GHCi> myTake 2 [1,2,3] :: [Int]
[1,2]
GHCi> myTake 4 [1,2,3] :: [Int]
[1,2,3,*** Exception: Prelude.head: empty list

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 38.2 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ, Ð²Ñ‹Ð·Ñ‹Ð²Ð°ÑŽÑ‰Ð°Ñ Ð¿Ñ€ÐµÐ´ÑƒÐ¿Ñ€ÐµÐ¶Ð´ÐµÐ½Ð¸Ðµ ÐºÐ¾Ð¼Ð¿Ð¸Ð»ÑÑ‚Ð¾Ñ€Ð°
myTakePM :: Int -> [a] -> [a]
myTakePM 0 _ = []
myTakePM n (x:xs) = x : myTakePM (n-1) xs

Pattern match(es) are non-exhaustive
In an equation for â€™myTakePMâ€™:
Patterns not matched: p [] where p is not one of {0}

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 38.1. ÐšÐ°ÐºÐ¾Ð¹ Ð¸Ð· Ð¾Ð±Ñ€Ð°Ð·Ñ†Ð¾Ð² ÑÐ¿Ð°ÑÑ‘Ñ‚ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ myTakePM?
myTakePM _0 [] = []
myTakePM _ [] = []
myTakePM 0 (x:xs) = []

ÐžÑ‚Ð²ÐµÑ‚ 38.1. Ð’Ð°Ð¼ Ð½ÑƒÐ¶Ð½Ð¾ Ð´Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ ÑÐ»ÐµÐ´ÑƒÑŽÑ‰Ð¸Ð¹ Ð¾Ð±Ñ€Ð°Ð·ÐµÑ†:
myTakePM _ [] = []

Head Ð¸ Ñ‡Ð°ÑÑ‚Ð¸Ñ‡Ð½Ñ‹Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 38.3 ÐŸÑ€Ð¸Ð¼ÐµÑ€ Ð²Ñ‹Ð±Ñ€Ð°ÑÑ‹Ð²Ð°Ð½Ð¸Ñ Ð¾ÑˆÐ¸Ð±ÐºÐ¸, myHead
myHead :: [a] -> a
myHead [] = error "empty list"
myHead (x:_) = x

GHCi> 2 / 0
Infinity

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 38.2. Ð’Ð¾Ñ‚ Ð½ÐµÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ñ‡Ð°ÑÑ‚Ð¸Ñ‡Ð½Ñ‹Ñ… Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹ Ð¸Ð· Prelude:
â€š maximum
â€š succ
â€š sum
ÐšÐ°Ðº Ð²Ñ‹ Ð´ÑƒÐ¼Ð°ÐµÑ‚Ðµ, Ð´Ð»Ñ ÐºÐ°ÐºÐ¸Ñ… Ð²Ñ…Ð¾Ð´Ð½Ñ‹Ñ… Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¾Ð½Ð¸ Ð½Ðµ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ñ‹?

ÐžÑ‚Ð²ÐµÑ‚ 38.2
â€š maximum â€” Ð¾Ñ‚ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÑ‚ Ð½Ð° Ð¿ÑƒÑÑ‚Ñ‹Ñ… ÑÐ¿Ð¸ÑÐºÐ°Ñ…;
â€š succ â€” Ð½Ðµ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ Ð½Ð° Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ð¸ maxBound Ñ‚Ð¸Ð¿Ð° Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ð°;
â€š sum â€” Ð·Ð°Ñ†Ð¸ÐºÐ»Ð¸Ð²Ð°ÐµÑ‚ÑÑ Ð½Ð° Ð±ÐµÑÐºÐ¾Ð½ÐµÑ‡Ð½Ñ‹Ñ… ÑÐ¿Ð¸ÑÐºÐ°Ñ….
ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ñ‡Ð°ÑÑ‚Ð¸Ñ‡Ð½Ñ‹Ñ… Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹ Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ Maybe

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 38.4 ÐŸÑ€ÐµÐ¾Ð±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¸Ðµ head Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ Maybe
maybeHead :: [a] -> Maybe a
maybeHead [] = Nothing
maybeHead (x:_) = Just x

GHCi> maybeHead [1]
Just 1
GHCi> maybeHead []
Nothing

GHCi> (+2) <$> maybeHead [1]
Just 3
GHCi> (+2) <$> maybeHead []
Nothing

GHCi> (:) <$> maybeHead [1,2,3] <*> Just []
Just [1]
GHCi> (:) <$> maybeHead [] <*> Just []
Nothing

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 38.5 Ð‘Ð¾Ð»ÐµÐµ Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð°Ñ Ð²ÐµÑ€ÑÐ¸Ñ myTake
myTakeSafer :: Int -> Maybe [a] -> Maybe [a]
myTakeSafer 0 _ = Just []
myTakeSafer n (Just xs) =
    (:) <$> maybeHead xs
    <*> myTakeSafer (n-1) (Just (tail xs))

GHCi> myTakeSafer 3 (Just [1,2,3])
Just [1,2,3]
GHCi> myTakeSafer 6 (Just [1,2,3])
Nothing

ÐŸÐµÑ€Ð²Ð°Ñ Ð²ÑÑ‚Ñ€ÐµÑ‡Ð° Ñ Either
primes :: [Int]
primes = [2,3,5,7]

maxN :: Int
maxN = 10

isPrime :: Int -> Maybe Bool
isPrime n
     | n < 2 = Nothing
     | n > maxN = Nothing
     | otherwise = Just (n â€˜ elem â€˜ primes)

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 38.3. ÐŸÑ€ÐµÐ´Ð¿Ð¾Ð»Ð¾Ð¶Ð¸Ð¼, Ñƒ Ð²Ð°Ñ ÐµÑÑ‚ÑŒ ÑÐ¿Ð¸ÑÐ¾Ðº:
oddList :: [Maybe Int]
oddList = [Nothing]
Ð•ÑÐ»Ð¸ Ð±Ñ‹ Ð²Ñ‹ Ð¿Ð¸ÑÐ°Ð»Ð¸ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ, Ð²Ñ‹Ñ‡Ð¸ÑÐ»ÑÑŽÑ‰ÑƒÑŽ Ð½Ð°Ð¸Ð±Ð¾Ð»ÑŒÑˆÐµÐµ ÑÑ€ÐµÐ´Ð¸ Ð¸Ð¼ÐµÑŽÑ‰Ð¸Ñ…ÑÑ Ð² Ñ‚Ð°ÐºÐ¾Ð³Ð¾ Ñ‚Ð¸Ð¿Ð° ÑÐ¿Ð¸ÑÐºÐµ Ñ‡Ð¸ÑÐµÐ», Ð¾Ð±Ñ‘Ñ€Ð½ÑƒÑ‚Ñ‹Ñ… Ð² Just, ÐºÐ°ÐºÐ¾Ð¹ Ñ‚Ð¸Ð¿ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð° Ð²Ñ‹ Ð±Ñ‹ Ð´Ð»Ñ Ð½ÐµÑ‘ Ð²Ñ‹Ð±Ñ€Ð°Ð»Ð¸?
ÐžÑ‚Ð²ÐµÑ‚ 38.3. Ð’ ÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ðµ Ñ‚Ð¸Ð¿Ð° Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð° Ð¼Ð¾Ð¶Ð½Ð¾ Ð²Ð·ÑÑ‚ÑŒ Maybe Int.

data Either a b = Left a | Right b
data Either a b = Fail a | Correct b

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 38.6 Ð‘Ð¾Ð»ÐµÐµ Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð°Ñ Ð²ÐµÑ€ÑÐ¸Ñ head, Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÑŽÑ‰Ð°Ñ Either
eitherHead :: [a] -> Either String a
eitherHead [] = Left "Ð£ ÑÐ¿Ð¸ÑÐºÐ° Ð½ÐµÑ‚ Ð¿ÐµÑ€Ð²Ð¾Ð³Ð¾ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°, Ð¾Ð½ Ð¿ÑƒÑÑ‚"
eitherHead (x:xs) = Right x

intExample :: [Int]
intExample = [1,2,3]

intExampleEmpty :: [Int]
intExampleEmpty = []

charExample :: [Char]
charExample = "ÐºÐ¾Ñ‚"

charExampleEmpty :: [Char]
charExampleEmpty = ""

GHCi> eitherHead intExample
Right 1
GHCi> eitherHead intExampleEmpty
Left "Ð£ ÑÐ¿Ð¸ÑÐºÐ° Ð½ÐµÑ‚ Ð¿ÐµÑ€Ð²Ð¾Ð³Ð¾ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°, Ð¾Ð½ Ð¿ÑƒÑÑ‚"
GHCi> eitherHead charExample
Right â€™Ðºâ€™
GHCi> eitherHead charExampleEmpty
Left "Ð£ ÑÐ¿Ð¸ÑÐºÐ° Ð½ÐµÑ‚ Ð¿ÐµÑ€Ð²Ð¾Ð³Ð¾ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°, Ð¾Ð½ Ð¿ÑƒÑÑ‚"

GHCi> (+1) <$> (eitherHead intExample)
Right 2
GHCi> (+1) <$> (eitherHead intExampleEmpty)
Left "Ð£ ÑÐ¿Ð¸ÑÐºÐ° Ð½ÐµÑ‚ Ð¿ÐµÑ€Ð²Ð¾Ð³Ð¾ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°, Ð¾Ð½ Ð¿ÑƒÑÑ‚"

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 38.4. Ð’Ð¾ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚ÐµÑÑŒ Ð¾Ð¿ÐµÑ€Ð°Ñ†Ð¸ÑÐ¼Ð¸ <*> Ð¸ <$> 
Ð´Ð»Ñ ÑÑƒÐ¼Ð¼Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ Ð¿ÐµÑ€Ð²Ð¾Ð³Ð¾ Ð¸ Ð²Ñ‚Ð¾Ñ€Ð¾Ð³Ð¾ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð² ÑÐ¿Ð¸ÑÐºÐ° intExample, Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð½Ñ‹Ñ…
Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹ eitherHead Ð¸ tail
ÐžÑ‚Ð²ÐµÑ‚ 38.4
(+) <$> eitherHead intExample <*> eitherHead (tail intExample)
ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð½Ð° Ð¿Ñ€Ð¾ÑÑ‚Ð¾Ñ‚Ñƒ Ñ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸ÐµÐ¼ Either
Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 38.7 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ isPrime Ñ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸ÑÐ¼Ð¸ Ð¾Ð± Ð¾ÑˆÐ¸Ð±ÐºÐ°Ñ…
isPrime :: Int -> Either String Bool
isPrime n
   | n < 2 = Left "Ð§Ð¸ÑÐ»Ð° Ð¼ÐµÐ½ÑŒÑˆÐµ 2 Ð½Ðµ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÑŽÑ‚ÑÑ Ð½Ð° Ð¿Ñ€Ð¾ÑÑ‚Ð¾Ñ‚Ñƒ"
   | n > maxN = Left "Ð§Ð¸ÑÐ»Ð¾ ÑÐ»Ð¸ÑˆÐºÐ¾Ð¼ Ð²ÐµÐ»Ð¸ÐºÐ¾ Ð´Ð»Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸"
   | otherwise = Right (n â€˜elemâ€˜ primes)

GHCi> isPrime 5
Right True
GHCi> isPrime 6
Right False
GHCi> isPrime 100
Left "Ð§Ð¸ÑÐ»Ð¾ ÑÐ»Ð¸ÑˆÐºÐ¾Ð¼ Ð²ÐµÐ»Ð¸ÐºÐ¾ Ð´Ð»Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸"
GHCi> isPrime (-29)
Left "Ð§Ð¸ÑÐ»Ð° Ð¼ÐµÐ½ÑŒÑˆÐµ 2 Ð½Ðµ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÑŽÑ‚ÑÑ Ð½Ð° Ð¿Ñ€Ð¾ÑÑ‚Ð¾Ñ‚Ñƒ"

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 38.8 Ð¢Ð¸Ð¿ PrimeError Ð´Ð»Ñ Ð¿Ñ€ÐµÐ´ÑÑ‚Ð°Ð²Ð»ÐµÐ½Ð¸Ñ Ð¾ÑˆÐ¸Ð±Ð¾Ðº
data PrimeError = TooLarge | InvalidValue

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 38.9 Ð­ÐºÐ·ÐµÐ¼Ð¿Ð»ÑÑ€ Show Ð´Ð»Ñ PrimeError
instance Show PrimeError where
show TooLarge = "Ð§Ð¸ÑÐ»Ð¾ ÑÐ»Ð¸ÑˆÐºÐ¾Ð¼ Ð²ÐµÐ»Ð¸ÐºÐ¾"
show InvalidValue = "Ð§Ð¸ÑÐ»Ð¾ Ð½Ðµ Ð¿Ð¾Ð´Ñ…Ð¾Ð´Ð¸Ñ‚ Ð´Ð»Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸"

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 38.10 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ isPrime Ñ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸ÐµÐ¼ PrimeError
isPrime :: Int -> Either PrimeError Bool
isPrime n
    | n < 2 = Left InvalidValue
    | n > maxN = Left TooLarge
    | otherwise = Right (n â€˜ elem â€˜ primes)

GHCi> isPrime 5
Right True
GHCi> isPrime 6
Right False
GHCi> isPrime 99
Left Ð§Ð¸ÑÐ»Ð¾ ÑÐ»Ð¸ÑˆÐºÐ¾Ð¼ Ð²ÐµÐ»Ð¸ÐºÐ¾
GHCi> isPrime 0
Left Ð§Ð¸ÑÐ»Ð¾ Ð½Ðµ Ð¿Ð¾Ð´Ñ…Ð¾Ð´Ð¸Ñ‚ Ð´Ð»Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸


Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 38.11 ÐŸÐµÑ€ÐµÐ²Ð¾Ð´ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð° isPrime Ð² Ñ‡Ð¸Ñ‚Ð°ÐµÐ¼Ñ‹Ð¹ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚
displayResult :: Either PrimeError Bool -> String
displayResult (Right True) = "Ð­Ñ‚Ð¾ Ð¿Ñ€Ð¾ÑÑ‚Ð¾Ðµ Ñ‡Ð¸ÑÐ»Ð¾"
displayResult (Right False) = "Ð­Ñ‚Ð¾ ÑÐ¾ÑÑ‚Ð°Ð²Ð½Ð¾Ðµ Ñ‡Ð¸ÑÐ»Ð¾"
displayResult (Left primeError) = show primeError

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 38.12 ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð½Ð° Ð¿Ñ€Ð¾ÑÑ‚Ð¾Ñ‚Ñƒ Ð²Ð²Ð¾Ð´Ð¸Ð¼Ñ‹Ñ… Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¼ Ñ‡Ð¸ÑÐµÐ»
main :: IO ()
main = do
   putStrLn "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ñ‡Ð¸ÑÐ»Ð¾ Ð´Ð»Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸ Ð½Ð° Ð¿Ñ€Ð¾ÑÑ‚Ð¾Ñ‚Ñƒ:"
   n <- read <$> getLine
   let result = isPrime n
   putStrLn (displayResult result)

$ stack build
$ stack exec primechecker-exe
Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ñ‡Ð¸ÑÐ»Ð¾ Ð´Ð»Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸ Ð½Ð° Ð¿Ñ€Ð¾ÑÑ‚Ð¾Ñ‚Ñƒ:
6
Ð­Ñ‚Ð¾ ÑÐ¾ÑÑ‚Ð°Ð²Ð½Ð¾Ðµ Ñ‡Ð¸ÑÐ»Ð¾
$ stack exec headaches-exe
Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ñ‡Ð¸ÑÐ»Ð¾ Ð´Ð»Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸ Ð½Ð° Ð¿Ñ€Ð¾ÑÑ‚Ð¾Ñ‚Ñƒ:
5
Ð­Ñ‚Ð¾ Ð¿Ñ€Ð¾ÑÑ‚Ð¾Ðµ Ñ‡Ð¸ÑÐ»Ð¾
$ stack exec headaches-exe
Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ñ‡Ð¸ÑÐ»Ð¾ Ð´Ð»Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸ Ð½Ð° Ð¿Ñ€Ð¾ÑÑ‚Ð¾Ñ‚Ñƒ:
213
Ð§Ð¸ÑÐ»Ð¾ ÑÐ»Ð¸ÑˆÐºÐ¾Ð¼ Ð²ÐµÐ»Ð¸ÐºÐ¾
$ stack exec headaches-exe
Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ñ‡Ð¸ÑÐ»Ð¾ Ð´Ð»Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸ Ð½Ð° Ð¿Ñ€Ð¾ÑÑ‚Ð¾Ñ‚Ñƒ:
0
Ð§Ð¸ÑÐ»Ð¾ Ð½Ðµ Ð¿Ð¾Ð´Ñ…Ð¾Ð´Ð¸Ñ‚ Ð´Ð»Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸

Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ HTTP-Ð·Ð°Ð¿Ñ€Ð¾ÑÐ¾Ð² Ð² Haskell
ÐÐ° ÑÐ°Ð¹Ñ‚Ðµ Ñ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸ÐµÐ¼ ÑÑ‚Ð¾Ð³Ð¾ API (https://
www.ncdc.noaa.gov/cdo-web/webservices/v2#gettingStarted) Ð²Ñ‹ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð½Ð°Ð¹Ñ‚Ð¸ ÑÐ¿Ð¸ÑÐ¾Ðº Ð²ÑÐµÑ… Ð¾ÐºÐ¾Ð½ÐµÑ‡Ð½Ñ‹Ñ… Ñ‚Ð¾Ñ‡ÐµÐº, Ð¿Ñ€ÐµÐ´Ð»Ð°Ð³Ð°ÐµÐ¼Ñ‹Ñ… API. Ð’Ð¾Ñ‚ Ð½ÐµÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ð¸Ð· Ð½Ð¸Ñ…:
â€š /datasets â€” ÑÐ¾Ð¾Ð±Ñ‰Ð°ÐµÑ‚ Ð¾ Ñ‚Ð¾Ð¼, ÐºÐ°ÐºÐ¸Ðµ Ð½Ð°Ð±Ð¾Ñ€Ñ‹ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹;
â€š /locations â€” Ð¿Ð¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÑ‚, ÐºÐ°ÐºÐ¸Ðµ Ð¼ÐµÑÑ‚Ð½Ð¾ÑÑ‚Ð¸ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹ Ð´Ð»Ñ Ð¿Ñ€Ð¾ÑÐ¼Ð¾Ñ‚Ñ€Ð°;
â€š /stations â€” Ð¿Ñ€ÐµÐ´Ð¾ÑÑ‚Ð°Ð²Ð»ÑÐµÑ‚ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÑŽ Ð¾ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹Ñ… Ð¼ÐµÑ‚ÐµÐ¾ÑÑ‚Ð°Ð½Ñ†Ð¸ÑÑ…;
â€š /data â€” Ð¿Ñ€ÐµÐ´Ð¾ÑÑ‚Ð°Ð²Ð»ÑÐµÑ‚ Ð´Ð¾ÑÑ‚ÑƒÐ¿ Ðº ÑÑ‹Ñ€Ñ‹Ð¼ Ð´Ð°Ð½Ð½Ñ‹Ð¼.
"uid":"gov.noaa.ncdc:C00822",
"mindate":"2010-01-01",
"maxdate":"2010-12-01",
"name":"Normals Monthly",
"datacoverage":1,
"id":"NORMAL_MLY"

Ð’Ð°Ð¼ Ð½ÑƒÐ¶Ð½Ð¾ Ð±ÑƒÐ´ÐµÑ‚ ÑÐ¾Ð·Ð´Ð°Ñ‚ÑŒ Ð¿Ñ€Ð¾ÐµÐºÑ‚ http-lesson. Ð’ ÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ðµ Ð½Ð°Ð¿Ð¾Ð¼Ð¸Ð½Ð°Ð½Ð¸Ñ
Ñ‚ÑƒÑ‚ Ð¿Ñ€Ð¸Ð²ÐµÐ´ÐµÐ½Ð° Ð¿Ð¾ÑˆÐ°Ð³Ð¾Ð²Ð°Ñ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐºÑ†Ð¸Ñ Ð¿Ð¾ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸ÑŽ Ð¸ ÑÐ±Ð¾Ñ€ÐºÐµ Ð¿Ñ€Ð¾ÐµÐºÑ‚Ð°:
$ stack update
$ stack new http-lesson
$ cd http-lesson
$ stack setup
$ stack build

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 39.1 ÐžÐ±ÑŠÑÐ²Ð»ÐµÐ½Ð¸Ñ Ð¸Ð¼Ð¿Ð¾Ñ€Ñ‚Ð° Ð² Ñ„Ð°Ð¹Ð»Ðµ app/Main.hs
module Main where
import qualified Data.ByteString as B
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as L
import qualified Data.ByteString.Lazy.Char8 as LC
import Network.HTTP.Simple

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 39.2 Ð˜Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ cabal-Ñ„Ð°Ð¹Ð»Ð° Ð¿Ñ€Ð¾ÐµÐºÑ‚Ð°
executable http-lesson-exe
hs-source-dirs: app
main-is: Main.hs
ghc-options: -threaded -rtsopts -with-rtsopts=-N
build-depends: base
, http-lesson
, bytestring
, http-conduit
default-language: Haskell2010
extensions: OverloadedStrings

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 39.3 ÐŸÐ¾Ð»ÐµÐ·Ð½Ñ‹Ðµ Ð¿Ñ€Ð¸ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ð¸ HTTP-Ð·Ð°Ð¿Ñ€Ð¾ÑÐ¾Ð² Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ
myToken :: BC.ByteString
myToken = "<Ð²Ð°Ñˆ API-Ñ‚Ð¾ÐºÐµÐ½>"
noaaHost :: BC.ByteString
noaaHost = "www.ncdc.noaa.gov"
apiPath :: BC.ByteString
apiPath = "/cdo-web/api/v2/datasets"

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 39.4 Ð—Ð°Ð³Ð»ÑƒÑˆÐºÐ° Ð´Ð»Ñ main
main :: IO ()
main = putStrLn "Ð¿Ñ€Ð¸Ð²ÐµÑ‚"

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 39.1. Ð•ÑÐ»Ð¸ Ð±Ñ‹ Ð²Ñ‹ Ð½Ðµ ÑÑ‚Ð°Ð»Ð¸ ÑƒÐºÐ°Ð·Ñ‹Ð²Ð°Ñ‚ÑŒ Ð² cabal-Ñ„Ð°Ð¹Ð»Ðµ Ñ€Ð°ÑÑˆÐ¸Ñ€ÐµÐ½Ð¸Ðµ OverloadedStrings, 
Ñ‚Ð¾ ÐºÐ°ÐºÐ¸Ðµ Ð±Ñ‹ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ñ Ð¿Ñ€Ð¸ÑˆÐ»Ð¾ÑÑŒ Ð²Ð½ÐµÑÑ‚Ð¸
Ð² Main.hs Ð´Ð»Ñ Ð¿Ð¾Ð´Ð´ÐµÑ€Ð¶ÐºÐ¸ ÑÑ‚Ð¾Ð³Ð¾ Ñ€Ð°ÑÑˆÐ¸Ñ€ÐµÐ½Ð¸Ñ?

ÐžÑ‚Ð²ÐµÑ‚ 39.1. Ð’Ñ‹ Ð¼Ð¾Ð³Ð»Ð¸ Ð±Ñ‹ Ð²Ð¾ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒÑÑ Ð´Ð¸Ñ€ÐµÐºÑ‚Ð¸Ð²Ð¾Ð¹ LANGUAGE:
{-# LANGUAGE OverloadedStrings #-}


GHCi> import Network.HTTP.Simple
GHCi> response = httpLBS "http://news.ycombinator.com"

GHCi> response
<Ð´Ð»Ð¸Ð½Ð½Ñ‹Ð¹ Ð¾Ñ‚Ð²ÐµÑ‚>

Ð§Ð°ÑÑ‚Ð¾ Ð²ÑÑ‚Ñ€ÐµÑ‡Ð°ÑŽÑ‰Ð¸ÐµÑÑ HTTP-ÐºÐ¾Ð´Ñ‹
Ð•ÑÐ»Ð¸ Ð²Ñ‹ Ð½ÐµÐ·Ð½Ð°ÐºÐ¾Ð¼Ñ‹ Ñ ÐºÐ¾Ð´Ð°Ð¼Ð¸ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ñ HTTP, Ð²Ð¾Ñ‚ ÑÐ°Ð¼Ñ‹Ðµ Ñ‡Ð°ÑÑ‚Ð¾ Ð²ÑÑ‚Ñ€ÐµÑ‡Ð°ÑŽÑ‰Ð¸ÐµÑÑ:
â€š 200 OK â€” Ð·Ð°Ð¿Ñ€Ð¾Ñ Ð±Ñ‹Ð» ÑƒÑÐ¿ÐµÑˆÐµÐ½;
â€š 301 Moved Permanently â€” Ð·Ð°Ð¿Ñ€Ð°ÑˆÐ¸Ð²Ð°ÐµÐ¼Ñ‹Ð¹ Ñ€ÐµÑÑƒÑ€Ñ Ð¿ÐµÑ€ÐµÐ¼ÐµÑ‰Ñ‘Ð½;
â€š 404 Not Found â€” Ñ€ÐµÑÑƒÑ€Ñ Ð½Ðµ Ð±Ñ‹Ð» Ð½Ð°Ð¹Ð´ÐµÐ½.

GHCi> getResponseStatusCode response
<interactive>:6:23: error:
No instance for (Control.Monad.IO.Class.MonadIO Response)
arising from a use of â€™responseâ€™

getResponseStatusCode :: Response a -> Int
Ð° Network.HTTP.Simple

GHCi> getResponseStatusCode <$> response
200

GHCi> :t getResponseStatusCode <$> response
getResponseStatusCode <$> response
:: Control.Monad.IO.Class.MonadIO f => f Int

GHCi> response <- httpLBS "http://news.ycombinator.com"
GHCi> getResponseStatusCode response
200

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 39.2. Ð’ Ð±Ð¸Ð±Ð»Ð¸Ð¾Ñ‚ÐµÐºÐµ ÐµÑÑ‚ÑŒ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ getResponseHeader. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÑ ÐµÑ‘ Ð²Ð¼ÐµÑÑ‚Ðµ Ñ <$> Ð¸ <-, Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚Ðµ Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº Ð¾Ñ‚Ð²ÐµÑ‚Ð°.
ÐžÑ‚Ð²ÐµÑ‚ 39.2 ÐŸÐµÑ€Ð²Ñ‹Ð¹ Ð¼ÐµÑ‚Ð¾Ð´:
  GHCi> import Network.HTTP.Simple
  GHCi> response = httpLBS "http://news.ycombinator.com"
  GHCi> getResponseHeader <$> response
Ð’Ñ‚Ð¾Ñ€Ð¾Ð¹ Ð¼ÐµÑ‚Ð¾Ð´:
  GHCi> response <- httpLBS "http://news.ycombinator.com"
  GHCi> getResponseHeader response

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 39.5 ÐšÐ¾Ð´ Ð´Ð»Ñ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ñ HTTPS-Ð·Ð°Ð¿Ñ€Ð¾ÑÐ° Ðº API
buildRequest :: BC.ByteString -> BC.ByteString
                -> BC.ByteString -> BC.ByteString
                -> Request
buildRequest token host method path =
     setRequestMethod method
  $ setRequestHost host
  $ setRequestHeader "token" [token]
  $ setRequestPath path
  $ setRequestSecure True
  $ setRequestPort 443
  $ defaultRequest

request :: Request
request = buildRequest myToken noaaHost "GET" apiPath

GHCi> (*2) 2 + 2
6
GHCi> (*2) (2 + 2)
8

GHCi> (*2) $ 2 + 2
8

GHCi> head (map (++"!") ["dog","cat"])
"dog!"
GHCi> head $ map (++"!") ["dog","cat"]
"dog!"
($) :: (a -> b) -> a -> b

GHCi> :t setRequestMethod
setRequestMethod :: BC.ByteString -> Request -> Request

GHCi> :t setRequestHeader
setRequestHeader:: HeaderName -> [BC.ByteString] -> Request
                                                 -> Request

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 39.6 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ buildRequest Ñ ÑÐ²Ð½Ñ‹Ð¼ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸ÐµÐ¼
buildRequest token host method path =
  let state1 = setRequestPort 443 defaultRequest
  in let state2 = setRequestSecure True state1
     in let state3 = setRequestPath path state2
        in let state4 = setRequestHeader "token" [token] state3
           in setRequestHost host state4

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 39.7 Ð¤Ð¸Ð½Ð°Ð»ÑŒÐ½Ð°Ñ Ð²ÐµÑ€ÑÐ¸Ñ main Ñ Ð·Ð°Ð¿Ð¸ÑÑŒÑŽ Ð·Ð°Ð¿Ñ€Ð¾ÑÐ° Ð² JSON-Ñ„Ð°Ð¹Ð»
main :: IO ()
main = do
  response <- httpLBS request
  let status = getResponseStatusCode response
  if status == 200
     then do
        putStrLn "Ð ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ñ‹ Ð·Ð°Ð¿Ñ€Ð¾ÑÐ° Ð±Ñ‹Ð»Ð¸ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ñ‹ Ð² Ñ„Ð°Ð¹Ð»"
        let jsonBody = getResponseBody response
        L.writeFile "data.json" jsonBody
     else
        putStrLn "Ð—Ð°Ð¿Ñ€Ð¾Ñ Ð½Ðµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ ÑÐ¾Ð²ÐµÑ€ÑˆÐ¸Ñ‚ÑŒ Ð¸Ð·-Ð·Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ¸"

Ð Ð°Ð±Ð¾Ñ‚Ð° Ñ Ð´Ð°Ð½Ð½Ñ‹Ð¼Ð¸ JSON Ñ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸ÐµÐ¼ Aeson

{
"reportRequests":[
{
"viewId":"XXXX",
"dateRanges":[
{
"startDate":"2015-06-15",
"endDate":"2015-06-30"
}],
"metrics":[
{
"expression":"ga:sessions"
}],
"dimensions": [
{
"name":"ga:browser"
}]
}]
}

data User =
   User
   { userId :: Int
   , userName :: T.Text
   , email :: T.Text
   }

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 40.1 Ð¤Ð°Ð¹Ð» Main.hs

module Main where

import Data.Aeson
import Data.Text as T
import Data.ByteString.Lazy as B
import Data.ByteString.Lazy.Char8 as BC
import GHC.Generics

main :: IO ()
main = print "Ð¿Ñ€Ð¸Ð²ÐµÑ‚"

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 40.2 Ð”Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾ÑÑ‚ÐµÐ¹ Ð¸ Ð²ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ Ñ€Ð°ÑÑˆÐ¸Ñ€ÐµÐ½Ð¸Ð¹
build-depends: base
              , json-lesson
              , aeson
              , bytestring
              , text
default-language: Haskell2010
extensions: OverloadedStrings
            , DeriveGeneric

decode :: FromJSON a => ByteString -> Maybe a
eitherDecode :: FromJSON a => ByteString -> Either String a

encode :: ToJSON a => a -> ByteString

Ð­ÐºÐ·ÐµÐ¼Ð¿Ð»ÑÑ€Ñ‹ FromJSON Ð¸ ToJSON Ð´Ð»Ñ ÑÐ²Ð¾Ð¸Ñ… Ñ‚Ð¸Ð¿Ð¾Ð²
data Book = Book
    { title :: T.Text
    , author :: T.Text
    , year :: Int
    } deriving Show

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 40.4 Ð”Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ deriving Generic Ðº Ñ‚Ð¸Ð¿Ñƒ Book
data Book = Book
  { title :: T.Text
  , author :: T.Text
  , year :: Int
  } deriving (Show,Generic)

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 40.5 ÐžÐ±ÑŠÑÐ²Ð»ÐµÐ½Ð¸Ðµ Book ÑÐºÐ·ÐµÐ¼Ð¿Ð»ÑÑ€Ð¾Ð¼ ToJSON Ð¸ FromJSON
instance FromJSON Book
instance ToJSON Book

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 40.6 ÐŸÑ€ÐµÐ¾Ð±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¸Ðµ Book Ð² JSON
myBook :: Book
myBook = Book { author="Ð£Ð¸Ð»Ð» ÐšÑƒÑ€Ñ‚"
              , title="ÐŸÑ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ð¸Ñ€ÑƒÐ¹ Ð½Ð° Haskell"
              , year=2019}

myBookJSON :: BC.ByteString
myBookJSON = encode myBook

GHCi> myBook
Book {title = "ÐŸÑ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ð¸Ñ€ÑƒÐ¹ Ð½Ð° Haskell", author = "Ð£Ð¸Ð»Ð» ÐšÑƒÑ€Ñ‚",
                                                               Ã‡ year = 2019}
GHCi> myBookJSON
"{\"author\":\"Ð£Ð¸Ð»Ð» ÐšÑƒÑ€Ñ‚\",\"title\":
Ã‡ \"ÐŸÑ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ð¸Ñ€ÑƒÐ¹ Ð½Ð° Haskell\",\"year\":2019}"

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 40.7 ÐŸÑ€ÐµÐ¾Ð±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¸Ðµ JSON ÐºÐ½Ð¸Ð³Ð¸ Ð² Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Ñ‚Ð¸Ð¿Ð° Book
rawJSON :: BC.ByteString
rawJSON = "{\"author\":\"Ð­Ð¼Ð¸Ð»ÑŒ Ð§Ð¾Ñ€Ð°Ð½\",\"title\":
                       \"Ð¢Ñ€Ð°ÐºÑ‚Ð°Ñ‚ Ð¾ Ñ€Ð°Ð·Ð»Ð¾Ð¶ÐµÐ½Ð¸Ð¸ Ð¾ÑÐ½Ð¾Ð²\",\"year=1949}"

bookFromJSON :: Maybe Book
bookFromJSON = decode rawJSON

GHCi> bookFromJSON
Just (Book { title = "Ð¢Ñ€Ð°ÐºÑ‚Ð°Ñ‚ Ð¾ Ñ€Ð°Ð·Ð»Ð¾Ð¶ÐµÐ½Ð¸Ð¸ Ð¾ÑÐ½Ð¾Ð²"
             , author = "Ð­Ð¼Ð¸Ð»ÑŒ Ð§Ð¾Ñ€Ð°Ð½"
             , year = 1949})

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 40.8 ÐžÐ±ÑŠÐµÐºÑ‚ JSON, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¹ Ð½Ðµ ÑÐ¾Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²ÑƒÐµÑ‚ Ð½ÑƒÐ¶Ð½Ð¾Ð¼Ñƒ Ñ‚Ð¸Ð¿Ñƒ
wrongJSON :: BC.ByteString
wrongJSON = "{\"writer\":\"Ð­Ð¼Ð¸Ð»ÑŒ Ð§Ð¾Ñ€Ð°Ð½\",\"title\":
                Ã‡ \"Ð¢Ñ€Ð°ÐºÑ‚Ð°Ñ‚ Ð¾ Ñ€Ð°Ð·Ð»Ð¾Ð¶ÐµÐ½Ð¸Ð¸ Ð¾ÑÐ½Ð¾Ð²\",\"year\"=1949}"

bookFromWrongJSON :: Maybe Book
bookFromWrongJSON = decode wrongJSON

GHCi> bookFromWrongJSON
Nothing

GHCi> eitherDecode wrongJSON :: Either String Book
Left "Error in $: The key \"author\" was not found"

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 40.2. Ð’Ð¾ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚ÐµÑÑŒ Generic Ð´Ð»Ñ Ñ€ÐµÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ð¸ ToJSON
Ð¸ FromJSON Ð´Ð»Ñ ÑÑ‚Ð¾Ð³Ð¾ Ñ‚Ð¸Ð¿Ð°:
data Name = Name
  { firstName :: T.Text
  , lastName :: T.Text
  } deriving (Show)

ÐžÑ‚Ð²ÐµÑ‚ 40.2
data Name = Name
   { firstName :: T.Text
   , lastName :: T.Text
   } deriving (Show,Generic)
instance FromJSON Name
instance ToJSON Name

ÐÐ°Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ ÑÐ¾Ð±ÑÑ‚Ð²ÐµÐ½Ð½Ñ‹Ñ… ÑÐºÐ·ÐµÐ¼Ð¿Ð»ÑÑ€Ð¾Ð² FromJSON Ð¸ ToJSON
Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 40.9 ÐŸÑ€Ð¸Ð¼ÐµÑ€ Ð½ÐµÐ¿Ð¾Ð´ÐºÐ¾Ð½Ñ‚Ñ€Ð¾Ð»ÑŒÐ½Ð¾Ð³Ð¾ Ð²Ð°Ð¼ Ð¾Ð±ÑŠÐµÐºÑ‚Ð° JSON
sampleError :: BC.ByteString
sampleError = "{\"message\":\"ÑƒÐ¿Ñ!\",\"error\": 123}"

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 40.10 ÐŸÑ€Ð¾Ð±Ð»ÐµÐ¼Ð° Ñ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸ÐµÐ¼ JSON-Ð¼Ð¾Ð´ÐµÐ»Ð¸ Ð½Ð° Haskell
data ErrorMessage = ErrorMessage
   { message :: T.Text
   , error :: Int
   } deriving Show

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 40.11 Ð¢Ð¸Ð¿, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¹ Ð½Ðµ ÑÐ¾Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²ÑƒÐµÑ‚ Ð¾Ñ€Ð¸Ð³Ð¸Ð½Ð°Ð»ÑŒÐ½Ð¾Ð¼Ñƒ JSON
data ErrorMessage = ErrorMessage
   { message :: T.Text
   , errorCode :: Int
   } deriving Show

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 40.12 Ð ÐµÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ ÑÐºÐ·ÐµÐ¼Ð¿Ð»ÑÑ€Ð° FromJSON Ð´Ð»Ñ ErrorMessage
instance FromJSON ErrorMessage where
   parseJSON (Object v) =
       ErrorMessage <$> v .: "message"
                    <*> v .: "error"

parseJSON (Object v)

ErrorMessage <$> Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ <*> Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ
Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 40.13 Ð¡Ð¾Ð·Ð´Ð°Ñ‘Ð¼ ErrorMessage Ð² ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ðµ Maybe
exampleMessage :: Maybe T.Text
exampleMessage = Just "ÑƒÐ¿Ñ!"

exampleError :: Maybe Int
exampleError = Just 123

GHCi> ErrorMessage <$> exampleMessage <*> exampleError
Just (ErrorMessage {message = "ÑƒÐ¿Ñ!", errorCode = 123})

(.:) :: FromJSON a => Object -> Text -> Parser a
v .: "message"

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 40.3. Ð¡Ð´ÐµÐ»Ð°Ð¹Ñ‚Ðµ Name ÑÐºÐ·ÐµÐ¼Ð¿Ð»ÑÑ€Ð¾Ð¼ FromJSON Ð±ÐµÐ· Generic:
data Name = Name
     { firstName :: T.Text
     , lastName :: T.Text
     } deriving (Show)

ÐžÑ‚Ð²ÐµÑ‚ 40.3
instance FromJSON Name where
parseJSON (Object v) =
Name <$> v .: "firstName"
<*> v .: "lastName"

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 40.14 Ð Ð°Ð·Ð±Ð¾Ñ€ JSON Ð² Ñ‚Ð¸Ð¿ ErrorMessage

sampleErrorMessage :: Maybe ErrorMessage
sampleErrorMessage = decode sampleError

Ð’ GHCi Ð²Ñ‹ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ ÑƒÐ±ÐµÐ´Ð¸Ñ‚ÑŒÑÑ, Ñ‡Ñ‚Ð¾ Ð²ÑÑ‘ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ Ñ‚Ð°Ðº, ÐºÐ°Ðº Ð¿Ñ€ÐµÐ´Ð¿Ð¾Ð»Ð°Ð³Ð°Ð»Ð¾ÑÑŒ:

GHCi> sampleErrorMessage
Just (ErrorMessage {message = "ÑƒÐ¿Ñ!", errorCode = 123})

Ð¢ÐµÐ¿ÐµÑ€ÑŒ Ð½ÑƒÐ¶Ð½Ð¾ Ð¿Ñ€Ð¾Ð´ÐµÐ»Ð°Ñ‚ÑŒ Ð¾Ð±Ñ€Ð°Ñ‚Ð½Ð¾Ðµ Ð¿Ñ€ÐµÐ¾Ð±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¸Ðµ. Ð¡Ð¸Ð½Ñ‚Ð°ÐºÑÐ¸Ñ Ð´Ð»Ñ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ñ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹ Ð½ÐµÐ¼Ð½Ð¾Ð³Ð¾ Ð´Ñ€ÑƒÐ³Ð¾Ð¹:

instance ToJSON ErrorMessage where
   toJSON (ErrorMessage message errorCode) =
       object [ "message" .= message
              , "error" .= errorCode
              ]

toJSON (ErrorMessage message errorCode)

object [ "message" .= message
         , "error" .= errorCode
       ]

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 40.4. ÐÐ°ÐºÐ¾Ð½ÐµÑ†, ÑÐ´ÐµÐ»Ð°Ð¹Ñ‚Ðµ Name ÑÐºÐ·ÐµÐ¼Ð¿Ð»ÑÑ€Ð¾Ð¼ ToJSON Ð±ÐµÐ· Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ñ Generic:
data Name = Name
  { firstName :: T.Text
   , lastName :: T.Text
  } deriving (Show)

ÐžÑ‚Ð²ÐµÑ‚ 40.4
instance ToJSON Name where
    toJSON (Name firstName lastName) =
    object [ "firstName" .= firstName
             , "lastName" .= lastName
           ]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 40.15 Ð¡Ð¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð¾Ð± Ð¾ÑˆÐ¸Ð±ÐºÐµ Ð´Ð»Ñ Ð¿Ñ€ÐµÐ¾Ð±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¸Ñ Ð² JSON
anErrorMessage :: ErrorMessage
anErrorMessage = ErrorMessage "Ð’ÑÑ‘ Ð¿Ñ€ÐµÐºÑ€Ð°ÑÐ½Ð¾" 0

GHCi> encode anErrorMessage
"{\"error\":0,\"message\":\"Ð’ÑÑ‘ Ð¿Ñ€ÐµÐºÑ€Ð°ÑÐ½Ð¾\"}"

Ð§Ñ‚ÐµÐ½Ð¸Ðµ Ð´Ð°Ð½Ð½Ñ‹Ñ…, Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð½Ñ‹Ñ… Ð¾Ñ‚ NOAA
Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 40.16 JSON, Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð½Ñ‹Ð¹ Ð¾Ñ‚ NOAA
{
"metadata":{
"resultset":{
"offset":1,
"count":11,
"limit":25
}
},
"results":[
{
"uid":"gov.noaa.ncdc:C00861",
"mindate":"1763-01-01",
"maxdate":"2017-02-01",
"name":"Daily Summaries",
"datacoverage":1,
"id":"GHCND"
},
.....

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 40.17 Ð¢Ð¸Ð¿ NOAAResult Ñ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÑÐ¼Ð¸ Ð½Ð°Ð±Ð¾Ñ€Ð¾Ð² Ð´Ð°Ð½Ð½Ñ‹Ñ…
data NOAAResult = NOAAResult { uid :: T.Text
                               , mindate :: T.Text
                               , maxdate :: T.Text
                               , name :: T.Text
                               , datacoverage :: Int
                               , resultId :: T.Text
                              } deriving Show

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 40.18 ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ ÑÐºÐ·ÐµÐ¼Ð¿Ð»ÑÑ€Ð° FromJSON Ð´Ð»Ñ NOAAResult
instance FromJSON NOAAResult where
   parseJSON (Object v) =
      NOAAResult <$> v .: "uid"
                 <*> v .: "mindate"
                 <*> v .: "maxdate"
                 <*> v .: "name"
                 <*> v .: "datacoverage"
                 <*> v .: "id"

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 40.19 Ð¢Ð¸Ð¿ Resultset Ñ Ð¿Ð¾Ñ€Ð¾Ð¶Ð´ÐµÐ½Ð¸ÐµÐ¼ ÑÐºÐ·ÐµÐ¼Ð¿Ð»ÑÑ€Ð° FromJSON
data Resultset = Resultset { offset :: Int
                             , count :: Int
                             , limit :: Int
                           } deriving (Show,Generic)
instance FromJSON Resultset

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 40.20 Ð¢Ð¸Ð¿ Metadata Ñ Ð¿Ð¾Ñ€Ð¾Ð¶Ð´ÐµÐ½Ð¸ÐµÐ¼ ÑÐºÐ·ÐµÐ¼Ð¿Ð»ÑÑ€Ð° FromJSON
data Metadata = Metadata { resultset :: Resultset
                         } deriving (Show,Generic)
instance FromJSON Metadata

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 40.21 Ð¡Ð¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð½Ñ‹Ñ… Ñ‚Ð¸Ð¿Ð¾Ð² Ð² NOAAResponse
data NOAAResponse = NOAAResponse
                    { metadata :: Metadata
                      , results :: [NOAAResult]
                    } deriving (Show,Generic)
instance FromJSON NOAAResponse

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 40.22 Ð’Ñ‹Ð²Ð¾Ð´ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð¾Ð²
printResults :: Maybe [NOAAResult] -> IO ()
printResults Nothing = putStrLn "Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸ Ð´Ð°Ð½Ð½Ñ‹Ñ…"
printResults (Just results) = forM_ results (print . name)

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 40.23 Ð¡Ð¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ Ð²ÑÐµÐ³Ð¾ Ð½Ð°Ð¿Ð¸ÑÐ°Ð½Ð½Ð¾Ð³Ð¾ Ð² Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸Ð¸ main
main :: IO ()
main = do
  jsonData <- B.readFile "data.json"
  let noaaResponse = decode jsonData :: Maybe NOAAResponse
  let noaaResults = results <$> noaaResponse
  printResults noaaResults

GHCi> main
"Daily Summaries"
"Global Summary of the Month"
"Global Summary of the Year"
"Weather Radar (Level II)"
"Weather Radar (Level III)"
"Normals Annual/Seasonal"
"Normals Daily"
"Normals Hourly"
"Normals Monthly"
"Precipitation 15 Minute"
"Precipitation Hourly"

Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð±Ð°Ð· Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð² Haskell
CRUD, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ðµ Ð¾Ð±Ñ‹Ñ‡Ð½Ð¾ Ð°ÑÑÐ¾Ñ†Ð¸Ð¸Ñ€ÑƒÑŽÑ‚ÑÑ Ñ Ñ€Ð°Ð±Ð¾Ñ‚Ð¾Ð¹ Ñ Ð‘Ð” Ð¸ Ð²ÐºÐ»ÑŽÑ‡Ð°ÑŽÑ‚ Ð² ÑÐµÐ±Ñ:
â€š create â€” Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð½Ð¾Ð²Ñ‹Ñ… Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð² Ð±Ð°Ð·Ñƒ;
â€š read â€” Ð·Ð°Ð¿Ñ€Ð¾Ñ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¸Ð· Ð±Ð°Ð·Ñ‹;
â€š update â€” Ð¼Ð¾Ð´Ð¸Ñ„Ð¸ÐºÐ°Ñ†Ð¸Ñ ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÑŽÑ‰ÐµÐ¹ Ð² Ð±Ð°Ð·Ðµ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ð¸;
â€š delete â€” ÑƒÐ´Ð°Ð»ÐµÐ½Ð¸Ðµ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¸Ð· Ð±Ð°Ð·Ñ‹.

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 41.1 ÐŸÐµÑ€Ð²Ð¾Ð½Ð°Ñ‡Ð°Ð»ÑŒÐ½Ð°Ñ Ð²ÐµÑ€ÑÐ¸Ñ app/Main.hs
module Main where

import Control.Applicative
import Database.SQLite.Simple
import Database.SQLite.Simple.FromRow
import Data.Time

main :: IO ()
main = print "db-lesson"

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 41.2 Ð˜Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ ÑÐ¿Ð¸ÑÐºÐ° Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾ÑÑ‚ÐµÐ¹ Ð² db-lesson.cabal
build-depends: base
               , db-notes
               , time
               , sqlite-simple

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 41.3 Ð Ð°ÑÑˆÐ¸Ñ€ÐµÐ½Ð¸Ðµ OverloadedStrings Ð² db-lesson.cabal
extensions: OverloadedStrings

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 41.4 ÐšÐ¾Ð´ Ð´Ð»Ñ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ñ Ð±Ð°Ð·Ñ‹ Ð´Ð°Ð½Ð½Ñ‹Ñ…
DROP TABLE IF EXISTS checkedout;
DROP TABLE IF EXISTS tools;
DROP TABLE IF EXISTS users;
CREATE TABLE users (
id INTEGER PRIMARY KEY,
username TEXT
);
CREATE TABLE tools (
id INTEGER PRIMARY KEY,
name TEXT,
description TEXT,
lastReturned TEXT,
timesBorrowed INTEGER
);
CREATE TABLE checkedout (
user_id INTEGER,
tool_id INTEGER
);
INSERT INTO users (username) VALUES (â€™ÑƒÐ¸Ð»Ð»ÐºÑƒÑ€Ñ‚â€™);
INSERT INTO tools (name,description,lastReturned,timesBorrowed)
VALUES (â€™Ð¼Ð¾Ð»Ð¾Ñ‚Ð¾Ðºâ€™,â€™Ð·Ð°Ð±Ð¸Ð²Ð°ÐµÑ‚ Ð²ÑÑÐºÐ¾Ðµâ€™,â€™2017-01-01â€™,0);
INSERT INTO tools (name,description,lastReturned,timesBorrowed)
VALUES (â€™Ð¿Ð¸Ð»Ð°â€™,â€™Ð¿Ð¸Ð»Ð¸Ñ‚ Ñ€Ð°Ð·Ð½Ð¾Ðµâ€™,â€™2017-01-01â€™,0);

$ sqlite3 tools.db < build_db.sql

$ sqlite3 tools.db
sqlite> select * from tools;
1|Ð¼Ð¾Ð»Ð¾Ñ‚Ð¾Ðº|Ð·Ð°Ð±Ð¸Ð²Ð°ÐµÑ‚ Ð²ÑÑÐºÐ¾Ðµ|2017-01-01|0
2|Ð¿Ð¸Ð»Ð°|Ð¿Ð¸Ð»Ð¸Ñ‚ Ñ€Ð°Ð·Ð½Ð¾Ðµ|2017-01-01|0

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 41.5 ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ Ñ‚Ð¸Ð¿Ð° Tool Ð¸Ð· app/Main.hs
data Tool = Tool { toolId :: Int
                 , name :: String
                 , description :: String
                 , lastReturned :: Day
                 , timesBorrowed :: Int
                 }

GHCi> getCurrentTime
2017-02-26 07:05:12.218684 UTC
GHCi> utctDay <$> getCurrentTime
2017-02-26

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 41.6 Ð¢Ð¸Ð¿ User
data User = User { userId :: Int
                   , userName :: String
                 }

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 41.7 ÐÐ°Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ ÑÐºÐ·ÐµÐ¼Ð¿Ð»ÑÑ€Ð¾Ð² User Ð¸ Tool Ð´Ð»Ñ Show
instance Show User where
show user = mconcat [ show $ userId user
, ".) "
, userName user]
instance Show Tool where
show tool = mconcat [ show $ toolId tool
                      , ".) "
                      , name tool
                      , "\n Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ: "
                      , description tool
                      , "\n Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ð¹ Ñ€Ð°Ð· Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰ÐµÐ½Ð¾: "
                      , show $ lastReturned tool
                      , "\n ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ñ€Ð°Ð· ÑÐ´Ð°Ð½Ð¾ Ð² Ð°Ñ€ÐµÐ½Ð´Ñƒ: "
                      , show $ timesBorrowed tool
                      , "\n"]

1.) ÑƒÐ¸Ð»Ð»ÐºÑƒÑ€Ñ‚
1.) Ð¼Ð¾Ð»Ð¾Ñ‚Ð¾Ðº
Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ: Ð·Ð°Ð±Ð¸Ð²Ð°ÐµÑ‚ Ð²ÑÑÐºÐ¾Ðµ
Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ð¹ Ñ€Ð°Ð· Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰ÐµÐ½Ð¾: 2017-01-01
ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ñ€Ð°Ð· ÑÐ´Ð°Ð½Ð¾ Ð² Ð°Ñ€ÐµÐ½Ð´Ñƒ: 0

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 41.8 Ð¡Ð¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ Ñ Ð‘Ð” Ð¸ Ð²ÑÑ‚Ð°Ð²ÐºÐ° Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
addUser :: String -> IO ()
addUser userName = do
    conn <- open "tools.db"
    execute conn "INSERT INTO users (username) VALUES (?)"
            (Only userName)
    putStrLn "Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½"
    close conn

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 41.9 ÐÐ±ÑÑ‚Ñ€Ð°Ð³Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ñ Ñ Ð±Ð°Ð·Ð¾Ð¹ Ð´Ð°Ð½Ð½Ñ‹Ñ…
withConn :: String -> (Connection -> IO ()) -> IO ()
withConn dbName action = do
   conn <- open dbName
   action conn
   close conn

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 41.2. ÐŸÐµÑ€ÐµÐ¿Ð¸ÑˆÐ¸Ñ‚Ðµ addUser, Ð²Ð¾ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð²ÑˆÐ¸ÑÑŒ withConn.
ÐžÑ‚Ð²ÐµÑ‚ 41.2
addUser :: String -> IO ()
addUser userName =
   withConn "tools.db" $
    \conn -> do
       execute conn "INSERT INTO users (username) VALUES (?)"
               (Only userName)
   putStrLn "Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½"

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 41.10 Ð’ÑÑ‚Ð°Ð²ÐºÐ° Ð·Ð°Ð¿Ð¸ÑÐ¸ Ð¾Ð± Ð°Ñ€ÐµÐ½Ð´Ðµ
checkout :: Int -> Int -> IO ()
checkout userId toolId =
   withConn "tools.db" $
     \conn ->
        execute conn "INSERT INTO checkedout (user_id, tool_id)
                      VALUES (?,?)" (userId, toolId)

Ð§Ñ‚ÐµÐ½Ð¸Ðµ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¸Ð· Ð‘Ð” Ð¸ ÐºÐ»Ð°ÑÑ Ñ‚Ð¸Ð¿Ð¾Ð² FromRow

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 41.11 ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ ÐºÐ»Ð°ÑÑÐ° Ñ‚Ð¸Ð¿Ð¾Ð² FromRow
class FromRow a where
   fromRow :: RowParser a

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 41.12 ÐÐ°Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ Ñ€ÐµÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ð¹ FromRow Ð´Ð»Ñ User Ð¸ Tool
instance FromRow User where
fromRow = User <$> field
               <*> field

instance FromRow Tool where
fromRow = Tool <$> field
               <*> field
               <*> field
               <*> field
               <*> field

ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ ÑÐ¿Ð¸ÑÐºÐ¾Ð² Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¹ Ð¸ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð²
query :: (FromRow r, ToRow q) =>
Ã‡ Connection -> Query -> q -> IO [r]
query_ :: FromRow r => Connection -> Query -> IO [r]

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 41.3. Ð—Ð°Ñ‡ÐµÐ¼ Ñ‚Ñ€ÐµÐ±ÑƒÐµÑ‚ÑÑ Ð´Ð²Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ query Ð¸ query_?
ÐžÑ‚Ð²ÐµÑ‚ 41.3. Ð’ Ð¾ÑÐ½Ð¾Ð²Ð½Ð¾Ð¼ Ð¸Ð·-Ð·Ð° Ñ‚Ð¾Ð³Ð¾, ÐºÐ°Ðº Haskell Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ Ñ Ñ‚Ð¸Ð¿Ð°Ð¼Ð¸,
Ð² Ð½Ñ‘Ð¼ Ð½Ðµ Ð¿Ð¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°ÐµÑ‚ÑÑ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ð¾Ðµ ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð². ÐÐ»ÑŒÑ‚ÐµÑ€Ð½Ð°Ñ‚Ð¸Ð²Ð¾Ð¹ Ð½Ð°Ð¿Ð¸ÑÐ°Ð½Ð¸ÑŽ Ð½ÐµÑÐºÐ¾Ð»ÑŒÐºÐ¸Ñ… Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹ Ð¼Ð¾Ð¶ÐµÑ‚ ÑÐ»ÑƒÐ¶Ð¸Ñ‚ÑŒ Ñ‚Ð¸Ð¿-ÑÑƒÐ¼Ð¼Ð°
Ð´Ð»Ñ Ð¿Ñ€ÐµÐ´ÑÑ‚Ð°Ð²Ð»ÐµÐ½Ð¸Ñ Ð¾Ð±Ð¾Ð¸Ñ… Ð½Ð°Ð±Ð¾Ñ€Ð¾Ð² Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð² Ð¸ ÑÐ¾Ð¿Ð¾ÑÑ‚Ð°Ð²Ð»ÐµÐ½Ð¸ÐµÐ¼ Ñ Ð¾Ð±Ñ€Ð°Ð·Ñ†Ð¾Ð¼ Ð² Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ð¸ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸.

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 41.13 ÐŸÐµÑ‡Ð°Ñ‚ÑŒ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¹ Ð¸Ð· Ð±Ð°Ð·Ñ‹ Ð´Ð°Ð½Ð½Ñ‹Ñ…
printUsers :: IO ()
printUsers =
  withConn "tools.db" $
    \conn -> do
       resp <- query_ conn "SELECT * FROM users;" :: IO [User]
       mapM_ print resp

GHCi> printUsers
1.) ÑƒÐ¸Ð»Ð»ÐºÑƒÑ€Ñ‚
GHCi> addUser "Ñ‚ÐµÑÑ‚Ð¾Ð²Ñ‹Ð¹ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ"
Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½
GHCi> printUsers
1.) ÑƒÐ¸Ð»Ð»ÐºÑƒÑ€Ñ‚
2.) Ñ‚ÐµÑÑ‚Ð¾Ð²Ñ‹Ð¹ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ


Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 41.14 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ð¸ Ð·Ð°Ð¿Ñ€Ð¾ÑÐ¾Ð² Ð½Ð° Ð²Ñ‹Ð²Ð¾Ð´ ÑÐ¿Ð¸ÑÐºÐ¾Ð² Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð²
printToolQuery :: Query -> IO ()
printToolQuery q = withConn "tools.db" $
                   \conn -> do
                      resp <- query_ conn q :: IO [Tool]
                      mapM_ print resp

printTools :: IO ()
printTools = printToolQuery "SELECT * FROM tools;"

printAvailable :: IO ()
printAvailable = printToolQuery $
     mconcat [ "select * from tools "
               , "where id not in "
               , "(select tool_id from checkedout);"]

printCheckedout :: IO ()
printCheckedout = printToolQuery $
mconcat [ "select * from tools "
        , "where id in "
        , "(select tool_id from checkedout);"]

GHCi> printTools
1.) Ð¼Ð¾Ð»Ð¾Ñ‚Ð¾Ðº
Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ: Ð·Ð°Ð±Ð¸Ð²Ð°ÐµÑ‚ Ð²ÑÑÐºÐ¾Ðµ
Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ð¹ Ñ€Ð°Ð· Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰ÐµÐ½Ð¾: 2017-01-01
ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ñ€Ð°Ð· ÑÐ´Ð°Ð½Ð¾ Ð² Ð°Ñ€ÐµÐ½Ð´Ñƒ: 0
2.) Ð¿Ð¸Ð»Ð°
Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ: Ð¿Ð¸Ð»Ð¸Ñ‚ Ñ€Ð°Ð·Ð½Ð¾Ðµ
Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ð¹ Ñ€Ð°Ð· Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰ÐµÐ½Ð¾: 2017-01-01
ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ñ€Ð°Ð· ÑÐ´Ð°Ð½Ð¾ Ð² Ð°Ñ€ÐµÐ½Ð´Ñƒ: 0
GHCi> checkout 1 2
GHCi> printCheckedout
2.) Ð¿Ð¸Ð»Ð°
Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ: Ð¿Ð¸Ð»Ð¸Ñ‚ Ñ€Ð°Ð·Ð½Ð¾Ðµ
Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ð¹ Ñ€Ð°Ð· Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰ÐµÐ½Ð¾: 2017-01-01
ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ñ€Ð°Ð· ÑÐ´Ð°Ð½Ð¾ Ð² Ð°Ñ€ÐµÐ½Ð´Ñƒ: 0

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 41.15 Ð‘ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð°Ñ Ð²Ñ‹Ð±Ð¾Ñ€ÐºÐ° Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ Tool, Ð½Ð°Ð¹Ð´ÐµÐ½Ð½Ð¾Ð³Ð¾ Ð¿Ð¾ ID
selectTool :: Connection -> Int -> IO (Maybe Tool)
selectTool conn toolId = do
    resp <- query conn
            "SELECT * FROM tools WHERE id = (?)"
            (Only toolId) :: IO [Tool]
    return $ firstOrNothing resp

firstOrNothing :: [a] -> Maybe a
firstOrNothing [] = Nothing
firstOrNothing (x:_) = Just x

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 41.16 ÐžÐ±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ð¸ Ð¾Ð± Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ðµ
updateTool :: Tool -> Day -> Tool
updateTool tool date = tool
  { lastReturned = date
  , timesBorrowed = 1 + timesBorrowed tool
  }

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 41.17 Ð‘ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾Ðµ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ Ð±Ð°Ð·Ñ‹ Ð´Ð°Ð½Ð½Ñ‹Ñ…
updateOrWarn :: Maybe Tool -> IO ()
updateOrWarn Nothing = putStrLn "id Ð½Ðµ Ð±Ñ‹Ð» Ð½Ð°Ð¹Ð´ÐµÐ½"
updateOrWarn (Just tool) =
  withConn "tools.db" $
    \conn -> do
      let q = mconcat [ "UPDATE TOOLS SET "
                      , "lastReturned = ?,"
                      , " timesBorrowed = ? "
                      , "WHERE ID = ?;"]
      execute conn q (lastReturned tool,
                      timesBorrowed tool,
                      toolId tool)
      putStrLn "Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð¾Ð± Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ðµ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ñ‹"

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 41.18 Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ updateToolTable Ð¾Ð±Ð½Ð¾Ð²Ð»ÑÐµÑ‚ Ð‘Ð”
updateToolTable :: Int -> IO ()
updateToolTable toolId =
  withConn "tools.db" $
    \conn -> do
       tool <- selectTool conn toolId
       currentDay <- utctDay <$> getCurrentTime
       let updatedTool = updateTool <$> tool
                                    <*> pure currentDay
       updateOrWarn updatedTool

instance ToRow Tool where
toRow tool =
  [ SQLInteger $ fromIntegral $ toolId tool
  , SQLText $ T.pack $ name tool
  , SQLText $ T.pack $ description tool
  , SQLText $ T.pack $ show $ lastReturned tool
  , SQLInteger $ fromIntegral $ timesBorrowed tool ]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 41.19 Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰ÐµÐ½Ð¸Ðµ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð° Ð² Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ checkin
checkin :: Int -> IO ()
checkin toolId =
   withConn "tools.db" $ \conn ->
      execute conn
              "DELETE FROM checkedout WHERE tool_id = (?);"
              (Only toolId)

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 41.20 ÐŸÐ¾Ð»Ð½Ð¾Ðµ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ð¸ Ð¾Ð± Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ðµ
checkinAndUpdate :: Int -> IO ()
checkinAndUpdate toolId = do
   checkin toolId
   updateToolTable toolId

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 41.21 ÐžÑ€Ð³Ð°Ð½Ð¸Ð·Ð°Ñ†Ð¸Ñ Ð²Ð·Ð°Ð¸Ð¼Ð¾Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ Ñ Ð‘Ð”
promptAndAddUser :: IO ()
promptAndAddUser = do
    putStrLn "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¸Ð¼Ñ Ð½Ð¾Ð²Ð¾Ð³Ð¾ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ:"
    userName <- getLine
    addUser userName

promptAndCheckout :: IO ()
promptAndCheckout = do
    putStrLn "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ID Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ:"
    userId <- pure read <*> getLine
    putStrLn "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ID Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð°:"
    toolId <- pure read <*> getLine
    checkout userId toolId

promptAndCheckin :: IO ()
promptAndCheckin = do
   putStrLn "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ID Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð°:"
   toolId <- pure read <*> getLine
   checkinAndUpdate toolId

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 41.22 ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒÑÐºÐ¸Ð¹ Ð¸Ð½Ñ‚ÐµÑ€Ñ„ÐµÐ¹Ñ Ð² ÐºÐ¾Ð¼Ð°Ð½Ð´Ð½Ð¾Ð¹ ÑÑ‚Ñ€Ð¾ÐºÐµ
performCommand :: String -> IO ()
performCommand "users" = printUsers >> main
performCommand "tools" = printTools >> main
performCommand "adduser" = promptAndAddUser >> main
performCommand "checkout" = promptAndCheckout >> main
performCommand "checkin" = promptAndCheckin >> main
performCommand "in" = printAvailable >> main
performCommand "out" = printCheckedout >> main
performCommand "quit" = putStrLn "Ð§Ð°Ð¾!"
performCommand _ = putStrLn "ÐšÐ¾Ð¼Ð°Ð½Ð´Ð° Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð°" >> main

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 41.23 ÐžÐºÐ¾Ð½Ñ‡Ð°Ñ‚ÐµÐ»ÑŒÐ½Ð°Ñ Ð²ÐµÑ€ÑÐ¸Ñ IO-Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ main
main :: IO ()
main = do
  putStrLn "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñƒ:"
  command <- getLine
  performCommand command

$ stack exec db-lesson-exe
Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñƒ:
users
1.) ÑƒÐ¸Ð»Ð»ÐºÑƒÑ€Ñ‚
Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñƒ:
adduser
Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¸Ð¼Ñ Ð½Ð¾Ð²Ð¾Ð³Ð¾ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ:
test user
Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½
Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñƒ:
tools
1.) Ð¼Ð¾Ð»Ð¾Ñ‚Ð¾Ðº
Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ: Ð·Ð°Ð±Ð¸Ð²Ð°ÐµÑ‚ Ð²ÑÑÐºÐ¾Ðµ
Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ð¹ Ñ€Ð°Ð· Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰ÐµÐ½Ð¾: 2017-01-01
ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ñ€Ð°Ð· ÑÐ´Ð°Ð½Ð¾ Ð² Ð°Ñ€ÐµÐ½Ð´Ñƒ: 0
2.) Ð¿Ð¸Ð»Ð°
Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ: Ð¿Ð¸Ð»Ð¸Ñ‚ Ñ€Ð°Ð·Ð½Ð¾Ðµ
Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ð¹ Ñ€Ð°Ð· Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰ÐµÐ½Ð¾: 2017-01-01
ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ñ€Ð°Ð· ÑÐ´Ð°Ð½Ð¾ Ð² Ð°Ñ€ÐµÐ½Ð´Ñƒ: 0
Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñƒ:
checkout
Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ID Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ:
1
Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ID Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð°:
2
Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñƒ:
out
2.) Ð¿Ð¸Ð»Ð°
Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ: Ð¿Ð¸Ð»Ð¸Ñ‚ Ñ€Ð°Ð·Ð½Ð¾Ðµ
Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ð¹ Ñ€Ð°Ð· Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰ÐµÐ½Ð¾: 2017-01-01
ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ñ€Ð°Ð· ÑÐ´Ð°Ð½Ð¾ Ð² Ð°Ñ€ÐµÐ½Ð´Ñƒ: 0
Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñƒ:
checkin
Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ID Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð°:
2
Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð¾Ð± Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ðµ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ñ‹
Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñƒ:
in
1.) Ð¼Ð¾Ð»Ð¾Ñ‚Ð¾Ðº
Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ: Ð·Ð°Ð±Ð¸Ð²Ð°ÐµÑ‚ Ð²ÑÑÐºÐ¾Ðµ
Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ð¹ Ñ€Ð°Ð· Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰ÐµÐ½Ð¾: 2017-01-01
ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ñ€Ð°Ð· ÑÐ´Ð°Ð½Ð¾ Ð² Ð°Ñ€ÐµÐ½Ð´Ñƒ: 0
2.) Ð¿Ð¸Ð»Ð°
Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ: Ð¿Ð¸Ð»Ð¸Ñ‚ Ñ€Ð°Ð·Ð½Ð¾Ðµ
Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ð¹ Ñ€Ð°Ð· Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰ÐµÐ½Ð¾: 2017-02-26
ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ñ€Ð°Ð· ÑÐ´Ð°Ð½Ð¾ Ð² Ð°Ñ€ÐµÐ½Ð´Ñƒ: 1
Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñƒ:
quit
Ð§Ð°Ð¾!

Ð­Ñ„Ñ„ÐµÐºÑ‚Ð¸Ð²Ð½Ñ‹Ðµ Ð¼Ð°ÑÑÐ¸Ð²Ñ‹ Ñ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸ÐµÐ¼ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ñ
Ð² Haskell

data MyList a = EmptyList | Cons a (MyList a)

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 42.1 ÐŸÑ€Ð¸Ð¼ÐµÑ€ ÑÐ¿Ð¸ÑÐºÐ° Ð¸Ð· 10 Ð¼Ð¸Ð»Ð»Ð¸Ð¾Ð½Ð¾Ð² ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð²
  aLargeList :: [Int]
  aLargeList = [1 .. 10000000]

GHCi> :set +s
GHCi> aLargeList !! 9999999
10000000
(0.05 secs, 460,064 bytes)

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 42.2 ÐœÐ°ÑÑÐ¸Ð² Ñ‚Ð¸Ð¿Ð° UArray Ñ 10 Ð¼Ð¸Ð»Ð»Ð¸Ð¾Ð½Ð°Ð¼Ð¸ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð²
aLargeArray :: UArray Int Int
aLargeArray = array (0,9999999) []

GHCi> aLargeArray ! 9999999
0
(0.00 secs, 456,024 bytes)

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 42.3 Ð£Ð´Ð²Ð¾ÐµÐ½Ð¸Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ð¹ Ð² ÑÐ¿Ð¸ÑÐºÐµ Ð¸ Ð¿Ñ€Ð¾Ð¸Ð·Ð²Ð¾Ð´Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚ÑŒ
aLargeListDoubled :: [Int]
aLargeListDoubled = map (*2) aLargeList

GHCi> length aLargeListDoubled
10000000
(1.58 secs, 1,680,461,376 bytes)

GHCi> length aLargeListDoubled
10000000
(0.07 secs, 459,840 bytes)

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 42.4 Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ð¼Ð°ÑÑÐ¸Ð²Ð° Bool, Ð¸Ð½Ð´ÐµÐºÑÐ¸Ñ€ÑƒÐµÐ¼Ð¾Ð³Ð¾ Ñ Ð½ÑƒÐ»Ñ
zeroIndexArray :: UArray Int Bool
zeroIndexArray = array (0,9) [(3,True)]

GHCi> zeroIndexArray ! 5
False
GHCi> zeroIndexArray ! 3
True

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 42.5 ÐœÐ°ÑÑÐ¸Ð², Ð¸Ð½Ð´ÐµÐºÑÐ¸Ñ€ÑƒÐµÐ¼Ñ‹Ð¹ Ñ ÐµÐ´Ð¸Ð½Ð¸Ñ†Ñ‹
oneIndexArray :: UArray Int Bool
oneIndexArray = array (1,10) $ zip [1 .. 10] $ cycle [True]

GHCi> oneIndexArray ! 1
True
GHCi> oneIndexArray ! 10
True

GHCi> oneIndexArray ! 0
*** Exception: Ix{Int}.index: Index (0) out of range ((1,10))

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 42.1. Ð¡Ð¾Ð·Ð´Ð°Ð¹Ñ‚Ðµ Ð¼Ð°ÑÑÐ¸Ð² qcArray Ñ‚Ð¸Ð¿Ð° UArray Int Bool, ÑÐ¾Ð´ÐµÑ€Ð¶Ð°Ñ‰Ð¸Ð¹ Ð¿ÑÑ‚ÑŒ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð², Ð¸Ð½Ð´ÐµÐºÑÐ¸Ñ€ÑƒÐµÐ¼Ñ‹Ð¹ Ñ Ð½ÑƒÐ»Ñ Ð¸ Ñ‚Ð°ÐºÐ¾Ð¹, Ñ‡Ñ‚Ð¾Ð±Ñ‹ ÐµÐ³Ð¾
Ð²Ñ‚Ð¾Ñ€Ð¾Ð¹ Ð¸ Ñ‚Ñ€ÐµÑ‚Ð¸Ð¹ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ‹ Ð±Ñ‹Ð»Ð¸ Ñ€Ð°Ð²Ð½Ñ‹ True.

ÐžÑ‚Ð²ÐµÑ‚ 42.1
qcArray :: UArray Int Bool
qcArray = array (0,4) [(1,True),(2,True)]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 42.6 ÐœÐ°ÑÑÐ¸Ð² UArray, Ð¿Ñ€ÐµÐ´ÑÑ‚Ð°Ð²Ð»ÑÑŽÑ‰Ð¸Ð¹ Ð±Ð¾Ð±Ñ‹ Ð² ÐºÐ¾Ñ€Ð·Ð¸Ð½ÐºÐ°Ñ…
beansInBuckets :: UArray Int Int
beansInBuckets = array (0,3) []

GHCi> beansInBuckets ! 0
0
GHCi> beansInBuckets ! 2
0

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 42.2. ÐÐµ Ð¿Ð¾Ð»Ð°Ð³Ð°ÑÑÑŒ Ð½Ð° ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸Ñ, ÑÐ²Ð½Ð¾ ÑƒÐºÐ°Ð¶Ð¸Ñ‚Ðµ, Ñ‡Ñ‚Ð¾ Ð¼Ð°ÑÑÐ¸Ð²
ÑÐ»ÐµÐ´ÑƒÐµÑ‚ Ð¸Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð½ÑƒÐ»ÑÐ¼Ð¸.
ÐžÑ‚Ð²ÐµÑ‚ 42.2
beansInBucketsâ€™ :: UArray Int Int
beansInBucketsâ€™ = array (0,3) $ zip [0 .. 3] $ cycle [0]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 42.7 Ð˜Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ UArray Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ Ð¾Ð¿ÐµÑ€Ð°Ñ†Ð¸Ð¸ //
updatedBiB :: UArray Int Int
updatedBiB = beansInBuckets // [(1,5),(3,6)]

GHCi> updatedBiB ! 1
5
GHCi> updatedBiB ! 2
0
GHCi> updatedBiB ! 3
6

GHCi> accum (+) updatedBiB $ zip [0 .. 3] $ cycle [2]
array (0,3) [(0,2),(1,7),(2,2),(3,8)]

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 42.3. Ð£Ð²ÐµÐ»Ð¸Ñ‡ÑŒÑ‚Ðµ Ñ‡Ð¸ÑÐ»Ð¾ Ð±Ð¾Ð±Ð¾Ð² Ð² ÐºÐ°Ð¶Ð´Ð¾Ð¹ ÐºÐ¾Ñ€Ð·Ð¸Ð½ÐºÐµ Ð²Ñ‚Ñ€Ð¾Ðµ.
ÐžÑ‚Ð²ÐµÑ‚ 42.3
accum (*) updatedBiB $ zip [0 .. 3] $ cycle [3]

Ð˜Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ñ Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ STUArray
import Data.Array.ST
import Control.Monad
import Control.Monad.ST

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 42.8 ÐŸÐµÑ€Ð²Ñ‹Ð¹ Ð½Ð°Ð±Ñ€Ð¾ÑÐ¾Ðº listToSTUArray
listToSTUArray :: [Int] -> ST s (STUArray s Int Int)
listToSTUArray vals = do
   let end = length vals - 1
   stArray <- newArray (0,end) 0
   return stArray

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 42.9 ÐšÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ð¼Ð¾Ð³Ð¾ ÑÐ¿Ð¸ÑÐºÐ° Ð² STUArray
listToSTUArray :: [Int] -> ST s (STUArray s Int Int)
listToSTUArray vals = do
  let end = length vals - 1
  myArray <- newArray (0,end) 0
  forM_ [0 .. end] $ \i -> do
     let val = vals !! i
     writeArray myArray i val
  return myArray

GHCi> listToSTUArray [1,2,3]
<<ST action>>

runSTUArray :: ST s (STUArray s i e) -> UArray i e
Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 42.10 Ð§Ð¸ÑÑ‚Ð°Ñ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ listToUArray

listToUArray :: [Int] -> UArray Int Int
listToUArray vals = runSTUArray $ listToSTUArray vals

GHCi> listToUArray [1,2,3]
array (0,2) [(0,1),(1,2),(2,3)]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 42.11 ÐžÐ±Ñ‹Ñ‡Ð½Ñ‹Ð¹ Ð¼ÐµÑ‚Ð¾Ð´ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹ Ñ STUArray Ð¸ runSTUArray
listToUArray :: [Int] -> UArray Int Int
listToUArray vals = runSTUArray $ do
  let end = length vals - 1
  myArray <- newArray (0,end) 0
  forM_ [0 .. end] $ \i -> do
      let val = vals !! i
      writeArray myArray i val
  return myArray

swapST :: (Int,Int) -> (Int,Int)
swapST (x,y) = runST $ do
  xâ€™ <- newSTRef x
  yâ€™ <- newSTRef y
  writeSTRef xâ€™ y
  writeSTRef yâ€™ x
  xfinal <- readSTRef xâ€™
  yfinal <- readSTRef yâ€™
  return (xfinal,yfinal)

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 42.12 Ð¢ÐµÑÑ‚Ð¾Ð²Ñ‹Ð¹ Ð¼Ð°ÑÑÐ¸Ð², ÑÐ¾Ð·Ð´Ð°Ð½Ð½Ñ‹Ð¹ Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ listArray
myData :: UArray Int Int
myData = listArray (0,5) [7,6,4,8,10,2]

ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° 42.4. ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»Ð¸Ñ‚Ðµ myData, Ð¿Ð¾Ð»ÑŒÐ·ÑƒÑÑÑŒ listToUArray
ÐžÑ‚Ð²ÐµÑ‚ 42.4
myDataâ€™ :: UArray Int Int
myDataâ€™ = listToUArray [7,6,4,8,10,2]

Ð›Ð¸ÑÑ‚Ð¸Ð½Ð³ 42.13 Ð ÐµÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ ÑÐ¾Ñ€Ñ‚Ð¸Ñ€Ð¾Ð²ÐºÐ¸ Ð¼ÐµÑ‚Ð¾Ð´Ð¾Ð¼ Ð¿ÑƒÐ·Ñ‹Ñ€ÑŒÐºÐ°
bubbleSort :: UArray Int Int -> UArray Int Int
bubbleSort myArray = runSTUArray $ do
    stArray <- thaw myArray
    let end = (snd . bounds) myArray
    forM_ [1 .. end] $ \i -> do
        forM_ [0 .. (end - i)] $ \j -> do
            val <- readArray stArray j
            nextVal <- readArray stArray (j + 1)
            let outOfOrder = val > nextVal
            when outOfOrder $ do
                 writeArray stArray j nextVal
                 writeArray stArray (j + 1) val
    return stArray

GHCi> bubbleSort myData
array (0,5) [(0,2),(1,4),(2,6),(3,7),(4,8),(5,10)]







































